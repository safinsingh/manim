<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.mobject.svg.svg_mobject API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.mobject.svg.svg_mobject</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools as it
import re
import string
import warnings

from xml.dom import minidom

from manimlib.constants import *
from manimlib.mobject.geometry import Circle
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.geometry import RoundedRectangle
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.color import *
from manimlib.utils.config_ops import digest_config
from manimlib.utils.config_ops import digest_locals


def string_to_numbers(num_string):
    num_string = num_string.replace(&#34;-&#34;, &#34;,-&#34;)
    num_string = num_string.replace(&#34;e,-&#34;, &#34;e-&#34;)
    return [
        float(s)
        for s in re.split(&#34;[ ,]&#34;, num_string)
        if s != &#34;&#34;
    ]


class SVGMobject(VMobject):
    CONFIG = {
        &#34;should_center&#34;: True,
        &#34;height&#34;: 2,
        &#34;width&#34;: None,
        # Must be filled in in a subclass, or when called
        &#34;file_name&#34;: None,
        &#34;unpack_groups&#34;: True,  # if False, creates a hierarchy of VGroups
        &#34;stroke_width&#34;: DEFAULT_STROKE_WIDTH,
        &#34;fill_opacity&#34;: 1.0,
        # &#34;fill_color&#34; : LIGHT_GREY,
    }

    def __init__(self, file_name=None, **kwargs):
        digest_config(self, kwargs)
        self.file_name = file_name or self.file_name
        self.ensure_valid_file()
        VMobject.__init__(self, **kwargs)
        self.move_into_position()

    def ensure_valid_file(self):
        if self.file_name is None:
            raise Exception(&#34;Must specify file for SVGMobject&#34;)
        possible_paths = [
            os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name),
            os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name + &#34;.svg&#34;),
            os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name + &#34;.xdv&#34;),
            self.file_name,
        ]
        for path in possible_paths:
            if os.path.exists(path):
                self.file_path = path
                return
        raise IOError(&#34;No file matching %s in image directory&#34; %
                      self.file_name)

    def generate_points(self):
        doc = minidom.parse(self.file_path)
        self.ref_to_element = {}
        for svg in doc.getElementsByTagName(&#34;svg&#34;):
            mobjects = self.get_mobjects_from(svg)
            if self.unpack_groups:
                self.add(*mobjects)
            else:
                self.add(*mobjects[0].submobjects)
        doc.unlink()

    def get_mobjects_from(self, element):
        result = []
        if not isinstance(element, minidom.Element):
            return result
        if element.tagName == &#39;defs&#39;:
            self.update_ref_to_element(element)
        elif element.tagName == &#39;style&#39;:
            pass  # TODO, handle style
        elif element.tagName in [&#39;g&#39;, &#39;svg&#39;, &#39;symbol&#39;]:
            result += it.chain(*[
                self.get_mobjects_from(child)
                for child in element.childNodes
            ])
        elif element.tagName == &#39;path&#39;:
            temp = element.getAttribute(&#39;d&#39;)
            if temp != &#39;&#39;:
                result.append(self.path_string_to_mobject(temp))
        elif element.tagName == &#39;use&#39;:
            result += self.use_to_mobjects(element)
        elif element.tagName == &#39;rect&#39;:
            result.append(self.rect_to_mobject(element))
        elif element.tagName == &#39;circle&#39;:
            result.append(self.circle_to_mobject(element))
        elif element.tagName == &#39;ellipse&#39;:
            result.append(self.ellipse_to_mobject(element))
        elif element.tagName in [&#39;polygon&#39;, &#39;polyline&#39;]:
            result.append(self.polygon_to_mobject(element))
        else:
            pass  # TODO
            # warnings.warn(&#34;Unknown element type: &#34; + element.tagName)
        result = [m for m in result if m is not None]
        self.handle_transforms(element, VGroup(*result))
        if len(result) &gt; 1 and not self.unpack_groups:
            result = [VGroup(*result)]

        return result

    def g_to_mobjects(self, g_element):
        mob = VGroup(*self.get_mobjects_from(g_element))
        self.handle_transforms(g_element, mob)
        return mob.submobjects

    def path_string_to_mobject(self, path_string):
        return VMobjectFromSVGPathstring(path_string)

    def use_to_mobjects(self, use_element):
        # Remove initial &#34;#&#34; character
        ref = use_element.getAttribute(&#34;xlink:href&#34;)[1:]
        if ref not in self.ref_to_element:
            warnings.warn(&#34;%s not recognized&#34; % ref)
            return VGroup()
        return self.get_mobjects_from(
            self.ref_to_element[ref]
        )

    def attribute_to_float(self, attr):
        stripped_attr = &#34;&#34;.join([
            char for char in attr
            if char in string.digits + &#34;.&#34; + &#34;-&#34;
        ])
        return float(stripped_attr)

    def polygon_to_mobject(self, polygon_element):
        # TODO, This seems hacky...
        path_string = polygon_element.getAttribute(&#34;points&#34;)
        for digit in string.digits:
            path_string = path_string.replace(&#34; &#34; + digit, &#34; L&#34; + digit)
        path_string = &#34;M&#34; + path_string
        return self.path_string_to_mobject(path_string)

    # &lt;circle class=&#34;st1&#34; cx=&#34;143.8&#34; cy=&#34;268&#34; r=&#34;22.6&#34;/&gt;

    def circle_to_mobject(self, circle_element):
        x, y, r = [
            self.attribute_to_float(
                circle_element.getAttribute(key)
            )
            if circle_element.hasAttribute(key)
            else 0.0
            for key in (&#34;cx&#34;, &#34;cy&#34;, &#34;r&#34;)
        ]
        return Circle(radius=r).shift(x * RIGHT + y * DOWN)

    def ellipse_to_mobject(self, circle_element):
        x, y, rx, ry = [
            self.attribute_to_float(
                circle_element.getAttribute(key)
            )
            if circle_element.hasAttribute(key)
            else 0.0
            for key in (&#34;cx&#34;, &#34;cy&#34;, &#34;rx&#34;, &#34;ry&#34;)
        ]
        return Circle().scale(rx * RIGHT + ry * UP).shift(x * RIGHT + y * DOWN)

    def rect_to_mobject(self, rect_element):
        fill_color = rect_element.getAttribute(&#34;fill&#34;)
        stroke_color = rect_element.getAttribute(&#34;stroke&#34;)
        stroke_width = rect_element.getAttribute(&#34;stroke-width&#34;)
        corner_radius = rect_element.getAttribute(&#34;rx&#34;)

        # input preprocessing
        if fill_color in [&#34;&#34;, &#34;none&#34;, &#34;#FFF&#34;, &#34;#FFFFFF&#34;] or Color(fill_color) == Color(WHITE):
            opacity = 0
            fill_color = BLACK  # shdn&#39;t be necessary but avoids error msgs
        if fill_color in [&#34;#000&#34;, &#34;#000000&#34;]:
            fill_color = WHITE
        if stroke_color in [&#34;&#34;, &#34;none&#34;, &#34;#FFF&#34;, &#34;#FFFFFF&#34;] or Color(stroke_color) == Color(WHITE):
            stroke_width = 0
            stroke_color = BLACK
        if stroke_color in [&#34;#000&#34;, &#34;#000000&#34;]:
            stroke_color = WHITE
        if stroke_width in [&#34;&#34;, &#34;none&#34;, &#34;0&#34;]:
            stroke_width = 0

        if corner_radius in [&#34;&#34;, &#34;0&#34;, &#34;none&#34;]:
            corner_radius = 0

        corner_radius = float(corner_radius)

        if corner_radius == 0:
            mob = Rectangle(
                width=self.attribute_to_float(
                    rect_element.getAttribute(&#34;width&#34;)
                ),
                height=self.attribute_to_float(
                    rect_element.getAttribute(&#34;height&#34;)
                ),
                stroke_width=stroke_width,
                stroke_color=stroke_color,
                fill_color=fill_color,
                fill_opacity=opacity
            )
        else:
            mob = RoundedRectangle(
                width=self.attribute_to_float(
                    rect_element.getAttribute(&#34;width&#34;)
                ),
                height=self.attribute_to_float(
                    rect_element.getAttribute(&#34;height&#34;)
                ),
                stroke_width=stroke_width,
                stroke_color=stroke_color,
                fill_color=fill_color,
                fill_opacity=opacity,
                corner_radius=corner_radius
            )

        mob.shift(mob.get_center() - mob.get_corner(UP + LEFT))
        return mob

    def handle_transforms(self, element, mobject):
        x, y = 0, 0
        try:
            x = self.attribute_to_float(element.getAttribute(&#39;x&#39;))
            # Flip y
            y = -self.attribute_to_float(element.getAttribute(&#39;y&#39;))
            mobject.shift(x * RIGHT + y * UP)
        except:
            pass

        transform = element.getAttribute(&#39;transform&#39;)

        try:  # transform matrix
            prefix = &#34;matrix(&#34;
            suffix = &#34;)&#34;
            if not transform.startswith(prefix) or not transform.endswith(suffix):
                raise Exception()
            transform = transform[len(prefix):-len(suffix)]
            transform = string_to_numbers(transform)
            transform = np.array(transform).reshape([3, 2])
            x = transform[2][0]
            y = -transform[2][1]
            matrix = np.identity(self.dim)
            matrix[:2, :2] = transform[:2, :]
            matrix[1] *= -1
            matrix[:, 1] *= -1

            for mob in mobject.family_members_with_points():
                mob.points = np.dot(mob.points, matrix)
            mobject.shift(x * RIGHT + y * UP)
        except:
            pass

        try:  # transform scale
            prefix = &#34;scale(&#34;
            suffix = &#34;)&#34;
            if not transform.startswith(prefix) or not transform.endswith(suffix):
                raise Exception()
            transform = transform[len(prefix):-len(suffix)]
            scale_values = string_to_numbers(transform)
            if len(scale_values) == 2:
                scale_x, scale_y = scale_values
                mobject.scale(np.array([scale_x, scale_y, 1]), about_point=ORIGIN)
            elif len(scale_values) == 1:
                scale = scale_values[0]
                mobject.scale(np.array([scale, scale, 1]), about_point=ORIGIN)
        except:
            pass

        try:  # transform translate
            prefix = &#34;translate(&#34;
            suffix = &#34;)&#34;
            if not transform.startswith(prefix) or not transform.endswith(suffix):
                raise Exception()
            transform = transform[len(prefix):-len(suffix)]
            x, y = string_to_numbers(transform)
            mobject.shift(x * RIGHT + y * DOWN)
        except:
            pass
        # TODO, ...

    def flatten(self, input_list):
        output_list = []
        for i in input_list:
            if isinstance(i, list):
                output_list.extend(self.flatten(i))
            else:
                output_list.append(i)
        return output_list

    def get_all_childNodes_have_id(self, element):
        all_childNodes_have_id = []
        if not isinstance(element, minidom.Element):
            return
        if element.hasAttribute(&#39;id&#39;):
            return [element]
        for e in element.childNodes:
            all_childNodes_have_id.append(self.get_all_childNodes_have_id(e))
        return self.flatten([e for e in all_childNodes_have_id if e])

    def update_ref_to_element(self, defs):
        new_refs = dict([(e.getAttribute(&#39;id&#39;), e) for e in self.get_all_childNodes_have_id(defs)])
        self.ref_to_element.update(new_refs)

    def move_into_position(self):
        if self.should_center:
            self.center()
        if self.height is not None:
            self.set_height(self.height)
        if self.width is not None:
            self.set_width(self.width)


class VMobjectFromSVGPathstring(VMobject):
    def __init__(self, path_string, **kwargs):
        digest_locals(self)
        VMobject.__init__(self, **kwargs)

    def get_path_commands(self):
        result = [
            &#34;M&#34;,  # moveto
            &#34;L&#34;,  # lineto
            &#34;H&#34;,  # horizontal lineto
            &#34;V&#34;,  # vertical lineto
            &#34;C&#34;,  # curveto
            &#34;S&#34;,  # smooth curveto
            &#34;Q&#34;,  # quadratic Bezier curve
            &#34;T&#34;,  # smooth quadratic Bezier curveto
            &#34;A&#34;,  # elliptical Arc
            &#34;Z&#34;,  # closepath
        ]
        result += [s.lower() for s in result]
        return result

    def generate_points(self):
        pattern = &#34;[%s]&#34; % (&#34;&#34;.join(self.get_path_commands()))
        pairs = list(zip(
            re.findall(pattern, self.path_string),
            re.split(pattern, self.path_string)[1:]
        ))
        # Which mobject should new points be added to
        self = self
        for command, coord_string in pairs:
            self.handle_command(command, coord_string)
        # people treat y-coordinate differently
        self.rotate(np.pi, RIGHT, about_point=ORIGIN)

    def handle_command(self, command, coord_string):
        isLower = command.islower()
        command = command.upper()
        # new_points are the points that will be added to the curr_points
        # list. This variable may get modified in the conditionals below.
        points = self.points
        new_points = self.string_to_points(coord_string)

        if isLower and len(points) &gt; 0:
            new_points += points[-1]

        if command == &#34;M&#34;:  # moveto
            self.start_new_path(new_points[0])
            if len(new_points) &lt;= 1:
                return

            # Draw relative line-to values.
            points = self.points
            new_points = new_points[1:]
            command = &#34;L&#34;

            for p in new_points:
                if isLower:
                    # Treat everything as relative line-to until empty
                    p[0] += self.points[-1, 0]
                    p[1] += self.points[-1, 1]
                self.add_line_to(p)
            return

        elif command in [&#34;L&#34;, &#34;H&#34;, &#34;V&#34;]:  # lineto
            if command == &#34;H&#34;:
                new_points[0, 1] = points[-1, 1]
            elif command == &#34;V&#34;:
                if isLower:
                    new_points[0, 0] -= points[-1, 0]
                    new_points[0, 0] += points[-1, 1]
                new_points[0, 1] = new_points[0, 0]
                new_points[0, 0] = points[-1, 0]
            self.add_line_to(new_points[0])
            return

        if command == &#34;C&#34;:  # curveto
            pass  # Yay! No action required
        elif command in [&#34;S&#34;, &#34;T&#34;]:  # smooth curveto
            self.add_smooth_curve_to(*new_points)
            # handle1 = points[-1] + (points[-1] - points[-2])
            # new_points = np.append([handle1], new_points, axis=0)
            return
        elif command == &#34;Q&#34;:  # quadratic Bezier curve
            # TODO, this is a suboptimal approximation
            new_points = np.append([new_points[0]], new_points, axis=0)
        elif command == &#34;A&#34;:  # elliptical Arc
            raise Exception(&#34;Not implemented&#34;)
        elif command == &#34;Z&#34;:  # closepath
            return

        # Add first three points
        self.add_cubic_bezier_curve_to(*new_points[0:3])

        # Handle situations where there&#39;s multiple relative control points
        if len(new_points) &gt; 3:
            # Add subsequent offset points relatively.
            for i in range(3, len(new_points), 3):
                if isLower:
                    new_points[i:i + 3] -= points[-1]
                    new_points[i:i + 3] += new_points[i - 1]
                self.add_cubic_bezier_curve_to(*new_points[i:i+3])

    def string_to_points(self, coord_string):
        numbers = string_to_numbers(coord_string)
        if len(numbers) % 2 == 1:
            numbers.append(0)
        num_points = len(numbers) // 2
        result = np.zeros((num_points, self.dim))
        result[:, :2] = np.array(numbers).reshape((num_points, 2))
        return result

    def get_original_path_string(self):
        return self.path_string</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="manimlib.mobject.svg.svg_mobject.string_to_numbers"><code class="name flex">
<span>def <span class="ident">string_to_numbers</span></span>(<span>num_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_to_numbers(num_string):
    num_string = num_string.replace(&#34;-&#34;, &#34;,-&#34;)
    num_string = num_string.replace(&#34;e,-&#34;, &#34;e-&#34;)
    return [
        float(s)
        for s in re.split(&#34;[ ,]&#34;, num_string)
        if s != &#34;&#34;
    ]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject"><code class="flex name class">
<span>class <span class="ident">SVGMobject</span></span>
<span>(</span><span>file_name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SVGMobject(VMobject):
    CONFIG = {
        &#34;should_center&#34;: True,
        &#34;height&#34;: 2,
        &#34;width&#34;: None,
        # Must be filled in in a subclass, or when called
        &#34;file_name&#34;: None,
        &#34;unpack_groups&#34;: True,  # if False, creates a hierarchy of VGroups
        &#34;stroke_width&#34;: DEFAULT_STROKE_WIDTH,
        &#34;fill_opacity&#34;: 1.0,
        # &#34;fill_color&#34; : LIGHT_GREY,
    }

    def __init__(self, file_name=None, **kwargs):
        digest_config(self, kwargs)
        self.file_name = file_name or self.file_name
        self.ensure_valid_file()
        VMobject.__init__(self, **kwargs)
        self.move_into_position()

    def ensure_valid_file(self):
        if self.file_name is None:
            raise Exception(&#34;Must specify file for SVGMobject&#34;)
        possible_paths = [
            os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name),
            os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name + &#34;.svg&#34;),
            os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name + &#34;.xdv&#34;),
            self.file_name,
        ]
        for path in possible_paths:
            if os.path.exists(path):
                self.file_path = path
                return
        raise IOError(&#34;No file matching %s in image directory&#34; %
                      self.file_name)

    def generate_points(self):
        doc = minidom.parse(self.file_path)
        self.ref_to_element = {}
        for svg in doc.getElementsByTagName(&#34;svg&#34;):
            mobjects = self.get_mobjects_from(svg)
            if self.unpack_groups:
                self.add(*mobjects)
            else:
                self.add(*mobjects[0].submobjects)
        doc.unlink()

    def get_mobjects_from(self, element):
        result = []
        if not isinstance(element, minidom.Element):
            return result
        if element.tagName == &#39;defs&#39;:
            self.update_ref_to_element(element)
        elif element.tagName == &#39;style&#39;:
            pass  # TODO, handle style
        elif element.tagName in [&#39;g&#39;, &#39;svg&#39;, &#39;symbol&#39;]:
            result += it.chain(*[
                self.get_mobjects_from(child)
                for child in element.childNodes
            ])
        elif element.tagName == &#39;path&#39;:
            temp = element.getAttribute(&#39;d&#39;)
            if temp != &#39;&#39;:
                result.append(self.path_string_to_mobject(temp))
        elif element.tagName == &#39;use&#39;:
            result += self.use_to_mobjects(element)
        elif element.tagName == &#39;rect&#39;:
            result.append(self.rect_to_mobject(element))
        elif element.tagName == &#39;circle&#39;:
            result.append(self.circle_to_mobject(element))
        elif element.tagName == &#39;ellipse&#39;:
            result.append(self.ellipse_to_mobject(element))
        elif element.tagName in [&#39;polygon&#39;, &#39;polyline&#39;]:
            result.append(self.polygon_to_mobject(element))
        else:
            pass  # TODO
            # warnings.warn(&#34;Unknown element type: &#34; + element.tagName)
        result = [m for m in result if m is not None]
        self.handle_transforms(element, VGroup(*result))
        if len(result) &gt; 1 and not self.unpack_groups:
            result = [VGroup(*result)]

        return result

    def g_to_mobjects(self, g_element):
        mob = VGroup(*self.get_mobjects_from(g_element))
        self.handle_transforms(g_element, mob)
        return mob.submobjects

    def path_string_to_mobject(self, path_string):
        return VMobjectFromSVGPathstring(path_string)

    def use_to_mobjects(self, use_element):
        # Remove initial &#34;#&#34; character
        ref = use_element.getAttribute(&#34;xlink:href&#34;)[1:]
        if ref not in self.ref_to_element:
            warnings.warn(&#34;%s not recognized&#34; % ref)
            return VGroup()
        return self.get_mobjects_from(
            self.ref_to_element[ref]
        )

    def attribute_to_float(self, attr):
        stripped_attr = &#34;&#34;.join([
            char for char in attr
            if char in string.digits + &#34;.&#34; + &#34;-&#34;
        ])
        return float(stripped_attr)

    def polygon_to_mobject(self, polygon_element):
        # TODO, This seems hacky...
        path_string = polygon_element.getAttribute(&#34;points&#34;)
        for digit in string.digits:
            path_string = path_string.replace(&#34; &#34; + digit, &#34; L&#34; + digit)
        path_string = &#34;M&#34; + path_string
        return self.path_string_to_mobject(path_string)

    # &lt;circle class=&#34;st1&#34; cx=&#34;143.8&#34; cy=&#34;268&#34; r=&#34;22.6&#34;/&gt;

    def circle_to_mobject(self, circle_element):
        x, y, r = [
            self.attribute_to_float(
                circle_element.getAttribute(key)
            )
            if circle_element.hasAttribute(key)
            else 0.0
            for key in (&#34;cx&#34;, &#34;cy&#34;, &#34;r&#34;)
        ]
        return Circle(radius=r).shift(x * RIGHT + y * DOWN)

    def ellipse_to_mobject(self, circle_element):
        x, y, rx, ry = [
            self.attribute_to_float(
                circle_element.getAttribute(key)
            )
            if circle_element.hasAttribute(key)
            else 0.0
            for key in (&#34;cx&#34;, &#34;cy&#34;, &#34;rx&#34;, &#34;ry&#34;)
        ]
        return Circle().scale(rx * RIGHT + ry * UP).shift(x * RIGHT + y * DOWN)

    def rect_to_mobject(self, rect_element):
        fill_color = rect_element.getAttribute(&#34;fill&#34;)
        stroke_color = rect_element.getAttribute(&#34;stroke&#34;)
        stroke_width = rect_element.getAttribute(&#34;stroke-width&#34;)
        corner_radius = rect_element.getAttribute(&#34;rx&#34;)

        # input preprocessing
        if fill_color in [&#34;&#34;, &#34;none&#34;, &#34;#FFF&#34;, &#34;#FFFFFF&#34;] or Color(fill_color) == Color(WHITE):
            opacity = 0
            fill_color = BLACK  # shdn&#39;t be necessary but avoids error msgs
        if fill_color in [&#34;#000&#34;, &#34;#000000&#34;]:
            fill_color = WHITE
        if stroke_color in [&#34;&#34;, &#34;none&#34;, &#34;#FFF&#34;, &#34;#FFFFFF&#34;] or Color(stroke_color) == Color(WHITE):
            stroke_width = 0
            stroke_color = BLACK
        if stroke_color in [&#34;#000&#34;, &#34;#000000&#34;]:
            stroke_color = WHITE
        if stroke_width in [&#34;&#34;, &#34;none&#34;, &#34;0&#34;]:
            stroke_width = 0

        if corner_radius in [&#34;&#34;, &#34;0&#34;, &#34;none&#34;]:
            corner_radius = 0

        corner_radius = float(corner_radius)

        if corner_radius == 0:
            mob = Rectangle(
                width=self.attribute_to_float(
                    rect_element.getAttribute(&#34;width&#34;)
                ),
                height=self.attribute_to_float(
                    rect_element.getAttribute(&#34;height&#34;)
                ),
                stroke_width=stroke_width,
                stroke_color=stroke_color,
                fill_color=fill_color,
                fill_opacity=opacity
            )
        else:
            mob = RoundedRectangle(
                width=self.attribute_to_float(
                    rect_element.getAttribute(&#34;width&#34;)
                ),
                height=self.attribute_to_float(
                    rect_element.getAttribute(&#34;height&#34;)
                ),
                stroke_width=stroke_width,
                stroke_color=stroke_color,
                fill_color=fill_color,
                fill_opacity=opacity,
                corner_radius=corner_radius
            )

        mob.shift(mob.get_center() - mob.get_corner(UP + LEFT))
        return mob

    def handle_transforms(self, element, mobject):
        x, y = 0, 0
        try:
            x = self.attribute_to_float(element.getAttribute(&#39;x&#39;))
            # Flip y
            y = -self.attribute_to_float(element.getAttribute(&#39;y&#39;))
            mobject.shift(x * RIGHT + y * UP)
        except:
            pass

        transform = element.getAttribute(&#39;transform&#39;)

        try:  # transform matrix
            prefix = &#34;matrix(&#34;
            suffix = &#34;)&#34;
            if not transform.startswith(prefix) or not transform.endswith(suffix):
                raise Exception()
            transform = transform[len(prefix):-len(suffix)]
            transform = string_to_numbers(transform)
            transform = np.array(transform).reshape([3, 2])
            x = transform[2][0]
            y = -transform[2][1]
            matrix = np.identity(self.dim)
            matrix[:2, :2] = transform[:2, :]
            matrix[1] *= -1
            matrix[:, 1] *= -1

            for mob in mobject.family_members_with_points():
                mob.points = np.dot(mob.points, matrix)
            mobject.shift(x * RIGHT + y * UP)
        except:
            pass

        try:  # transform scale
            prefix = &#34;scale(&#34;
            suffix = &#34;)&#34;
            if not transform.startswith(prefix) or not transform.endswith(suffix):
                raise Exception()
            transform = transform[len(prefix):-len(suffix)]
            scale_values = string_to_numbers(transform)
            if len(scale_values) == 2:
                scale_x, scale_y = scale_values
                mobject.scale(np.array([scale_x, scale_y, 1]), about_point=ORIGIN)
            elif len(scale_values) == 1:
                scale = scale_values[0]
                mobject.scale(np.array([scale, scale, 1]), about_point=ORIGIN)
        except:
            pass

        try:  # transform translate
            prefix = &#34;translate(&#34;
            suffix = &#34;)&#34;
            if not transform.startswith(prefix) or not transform.endswith(suffix):
                raise Exception()
            transform = transform[len(prefix):-len(suffix)]
            x, y = string_to_numbers(transform)
            mobject.shift(x * RIGHT + y * DOWN)
        except:
            pass
        # TODO, ...

    def flatten(self, input_list):
        output_list = []
        for i in input_list:
            if isinstance(i, list):
                output_list.extend(self.flatten(i))
            else:
                output_list.append(i)
        return output_list

    def get_all_childNodes_have_id(self, element):
        all_childNodes_have_id = []
        if not isinstance(element, minidom.Element):
            return
        if element.hasAttribute(&#39;id&#39;):
            return [element]
        for e in element.childNodes:
            all_childNodes_have_id.append(self.get_all_childNodes_have_id(e))
        return self.flatten([e for e in all_childNodes_have_id if e])

    def update_ref_to_element(self, defs):
        new_refs = dict([(e.getAttribute(&#39;id&#39;), e) for e in self.get_all_childNodes_have_id(defs)])
        self.ref_to_element.update(new_refs)

    def move_into_position(self):
        if self.should_center:
            self.center()
        if self.height is not None:
            self.set_height(self.height)
        if self.width is not None:
            self.set_width(self.width)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.for_3b1b_videos.pi_creature.PiCreature" href="../../for_3b1b_videos/pi_creature.html#manimlib.for_3b1b_videos.pi_creature.PiCreature">PiCreature</a></li>
<li><a title="manimlib.mobject.svg.drawings.AoPSLogo" href="drawings.html#manimlib.mobject.svg.drawings.AoPSLogo">AoPSLogo</a></li>
<li><a title="manimlib.mobject.svg.drawings.BitcoinLogo" href="drawings.html#manimlib.mobject.svg.drawings.BitcoinLogo">BitcoinLogo</a></li>
<li><a title="manimlib.mobject.svg.drawings.Bubble" href="drawings.html#manimlib.mobject.svg.drawings.Bubble">Bubble</a></li>
<li><a title="manimlib.mobject.svg.drawings.Car" href="drawings.html#manimlib.mobject.svg.drawings.Car">Car</a></li>
<li><a title="manimlib.mobject.svg.drawings.Guitar" href="drawings.html#manimlib.mobject.svg.drawings.Guitar">Guitar</a></li>
<li><a title="manimlib.mobject.svg.drawings.Headphones" href="drawings.html#manimlib.mobject.svg.drawings.Headphones">Headphones</a></li>
<li><a title="manimlib.mobject.svg.drawings.Lightbulb" href="drawings.html#manimlib.mobject.svg.drawings.Lightbulb">Lightbulb</a></li>
<li><a title="manimlib.mobject.svg.drawings.PartyHat" href="drawings.html#manimlib.mobject.svg.drawings.PartyHat">PartyHat</a></li>
<li><a title="manimlib.mobject.svg.drawings.PatreonLogo" href="drawings.html#manimlib.mobject.svg.drawings.PatreonLogo">PatreonLogo</a></li>
<li><a title="manimlib.mobject.svg.drawings.SuitSymbol" href="drawings.html#manimlib.mobject.svg.drawings.SuitSymbol">SuitSymbol</a></li>
<li><a title="manimlib.mobject.svg.drawings.SunGlasses" href="drawings.html#manimlib.mobject.svg.drawings.SunGlasses">SunGlasses</a></li>
<li><a title="manimlib.mobject.svg.drawings.VectorizedEarth" href="drawings.html#manimlib.mobject.svg.drawings.VectorizedEarth">VectorizedEarth</a></li>
<li><a title="manimlib.mobject.svg.drawings.VideoIcon" href="drawings.html#manimlib.mobject.svg.drawings.VideoIcon">VideoIcon</a></li>
<li><a title="manimlib.mobject.svg.tex_mobject.SingleStringTexMobject" href="tex_mobject.html#manimlib.mobject.svg.tex_mobject.SingleStringTexMobject">SingleStringTexMobject</a></li>
<li><a title="manimlib.mobject.svg.text_mobject.Text" href="text_mobject.html#manimlib.mobject.svg.text_mobject.Text">Text</a></li>
<li><a title="manimlib.once_useful_constructs.light.Lighthouse" href="../../once_useful_constructs/light.html#manimlib.once_useful_constructs.light.Lighthouse">Lighthouse</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.attribute_to_float"><code class="name flex">
<span>def <span class="ident">attribute_to_float</span></span>(<span>self, attr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_to_float(self, attr):
    stripped_attr = &#34;&#34;.join([
        char for char in attr
        if char in string.digits + &#34;.&#34; + &#34;-&#34;
    ])
    return float(stripped_attr)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.circle_to_mobject"><code class="name flex">
<span>def <span class="ident">circle_to_mobject</span></span>(<span>self, circle_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_to_mobject(self, circle_element):
    x, y, r = [
        self.attribute_to_float(
            circle_element.getAttribute(key)
        )
        if circle_element.hasAttribute(key)
        else 0.0
        for key in (&#34;cx&#34;, &#34;cy&#34;, &#34;r&#34;)
    ]
    return Circle(radius=r).shift(x * RIGHT + y * DOWN)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.ellipse_to_mobject"><code class="name flex">
<span>def <span class="ident">ellipse_to_mobject</span></span>(<span>self, circle_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipse_to_mobject(self, circle_element):
    x, y, rx, ry = [
        self.attribute_to_float(
            circle_element.getAttribute(key)
        )
        if circle_element.hasAttribute(key)
        else 0.0
        for key in (&#34;cx&#34;, &#34;cy&#34;, &#34;rx&#34;, &#34;ry&#34;)
    ]
    return Circle().scale(rx * RIGHT + ry * UP).shift(x * RIGHT + y * DOWN)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.ensure_valid_file"><code class="name flex">
<span>def <span class="ident">ensure_valid_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_valid_file(self):
    if self.file_name is None:
        raise Exception(&#34;Must specify file for SVGMobject&#34;)
    possible_paths = [
        os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name),
        os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name + &#34;.svg&#34;),
        os.path.join(os.path.join(&#34;assets&#34;, &#34;svg_images&#34;), self.file_name + &#34;.xdv&#34;),
        self.file_name,
    ]
    for path in possible_paths:
        if os.path.exists(path):
            self.file_path = path
            return
    raise IOError(&#34;No file matching %s in image directory&#34; %
                  self.file_name)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self, input_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(self, input_list):
    output_list = []
    for i in input_list:
        if isinstance(i, list):
            output_list.extend(self.flatten(i))
        else:
            output_list.append(i)
    return output_list</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.g_to_mobjects"><code class="name flex">
<span>def <span class="ident">g_to_mobjects</span></span>(<span>self, g_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g_to_mobjects(self, g_element):
    mob = VGroup(*self.get_mobjects_from(g_element))
    self.handle_transforms(g_element, mob)
    return mob.submobjects</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.generate_points"><code class="name flex">
<span>def <span class="ident">generate_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_points(self):
    doc = minidom.parse(self.file_path)
    self.ref_to_element = {}
    for svg in doc.getElementsByTagName(&#34;svg&#34;):
        mobjects = self.get_mobjects_from(svg)
        if self.unpack_groups:
            self.add(*mobjects)
        else:
            self.add(*mobjects[0].submobjects)
    doc.unlink()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.get_all_childNodes_have_id"><code class="name flex">
<span>def <span class="ident">get_all_childNodes_have_id</span></span>(<span>self, element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_childNodes_have_id(self, element):
    all_childNodes_have_id = []
    if not isinstance(element, minidom.Element):
        return
    if element.hasAttribute(&#39;id&#39;):
        return [element]
    for e in element.childNodes:
        all_childNodes_have_id.append(self.get_all_childNodes_have_id(e))
    return self.flatten([e for e in all_childNodes_have_id if e])</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.get_mobjects_from"><code class="name flex">
<span>def <span class="ident">get_mobjects_from</span></span>(<span>self, element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobjects_from(self, element):
    result = []
    if not isinstance(element, minidom.Element):
        return result
    if element.tagName == &#39;defs&#39;:
        self.update_ref_to_element(element)
    elif element.tagName == &#39;style&#39;:
        pass  # TODO, handle style
    elif element.tagName in [&#39;g&#39;, &#39;svg&#39;, &#39;symbol&#39;]:
        result += it.chain(*[
            self.get_mobjects_from(child)
            for child in element.childNodes
        ])
    elif element.tagName == &#39;path&#39;:
        temp = element.getAttribute(&#39;d&#39;)
        if temp != &#39;&#39;:
            result.append(self.path_string_to_mobject(temp))
    elif element.tagName == &#39;use&#39;:
        result += self.use_to_mobjects(element)
    elif element.tagName == &#39;rect&#39;:
        result.append(self.rect_to_mobject(element))
    elif element.tagName == &#39;circle&#39;:
        result.append(self.circle_to_mobject(element))
    elif element.tagName == &#39;ellipse&#39;:
        result.append(self.ellipse_to_mobject(element))
    elif element.tagName in [&#39;polygon&#39;, &#39;polyline&#39;]:
        result.append(self.polygon_to_mobject(element))
    else:
        pass  # TODO
        # warnings.warn(&#34;Unknown element type: &#34; + element.tagName)
    result = [m for m in result if m is not None]
    self.handle_transforms(element, VGroup(*result))
    if len(result) &gt; 1 and not self.unpack_groups:
        result = [VGroup(*result)]

    return result</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.handle_transforms"><code class="name flex">
<span>def <span class="ident">handle_transforms</span></span>(<span>self, element, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_transforms(self, element, mobject):
    x, y = 0, 0
    try:
        x = self.attribute_to_float(element.getAttribute(&#39;x&#39;))
        # Flip y
        y = -self.attribute_to_float(element.getAttribute(&#39;y&#39;))
        mobject.shift(x * RIGHT + y * UP)
    except:
        pass

    transform = element.getAttribute(&#39;transform&#39;)

    try:  # transform matrix
        prefix = &#34;matrix(&#34;
        suffix = &#34;)&#34;
        if not transform.startswith(prefix) or not transform.endswith(suffix):
            raise Exception()
        transform = transform[len(prefix):-len(suffix)]
        transform = string_to_numbers(transform)
        transform = np.array(transform).reshape([3, 2])
        x = transform[2][0]
        y = -transform[2][1]
        matrix = np.identity(self.dim)
        matrix[:2, :2] = transform[:2, :]
        matrix[1] *= -1
        matrix[:, 1] *= -1

        for mob in mobject.family_members_with_points():
            mob.points = np.dot(mob.points, matrix)
        mobject.shift(x * RIGHT + y * UP)
    except:
        pass

    try:  # transform scale
        prefix = &#34;scale(&#34;
        suffix = &#34;)&#34;
        if not transform.startswith(prefix) or not transform.endswith(suffix):
            raise Exception()
        transform = transform[len(prefix):-len(suffix)]
        scale_values = string_to_numbers(transform)
        if len(scale_values) == 2:
            scale_x, scale_y = scale_values
            mobject.scale(np.array([scale_x, scale_y, 1]), about_point=ORIGIN)
        elif len(scale_values) == 1:
            scale = scale_values[0]
            mobject.scale(np.array([scale, scale, 1]), about_point=ORIGIN)
    except:
        pass

    try:  # transform translate
        prefix = &#34;translate(&#34;
        suffix = &#34;)&#34;
        if not transform.startswith(prefix) or not transform.endswith(suffix):
            raise Exception()
        transform = transform[len(prefix):-len(suffix)]
        x, y = string_to_numbers(transform)
        mobject.shift(x * RIGHT + y * DOWN)
    except:
        pass</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.move_into_position"><code class="name flex">
<span>def <span class="ident">move_into_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_into_position(self):
    if self.should_center:
        self.center()
    if self.height is not None:
        self.set_height(self.height)
    if self.width is not None:
        self.set_width(self.width)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.path_string_to_mobject"><code class="name flex">
<span>def <span class="ident">path_string_to_mobject</span></span>(<span>self, path_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_string_to_mobject(self, path_string):
    return VMobjectFromSVGPathstring(path_string)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.polygon_to_mobject"><code class="name flex">
<span>def <span class="ident">polygon_to_mobject</span></span>(<span>self, polygon_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygon_to_mobject(self, polygon_element):
    # TODO, This seems hacky...
    path_string = polygon_element.getAttribute(&#34;points&#34;)
    for digit in string.digits:
        path_string = path_string.replace(&#34; &#34; + digit, &#34; L&#34; + digit)
    path_string = &#34;M&#34; + path_string
    return self.path_string_to_mobject(path_string)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.rect_to_mobject"><code class="name flex">
<span>def <span class="ident">rect_to_mobject</span></span>(<span>self, rect_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rect_to_mobject(self, rect_element):
    fill_color = rect_element.getAttribute(&#34;fill&#34;)
    stroke_color = rect_element.getAttribute(&#34;stroke&#34;)
    stroke_width = rect_element.getAttribute(&#34;stroke-width&#34;)
    corner_radius = rect_element.getAttribute(&#34;rx&#34;)

    # input preprocessing
    if fill_color in [&#34;&#34;, &#34;none&#34;, &#34;#FFF&#34;, &#34;#FFFFFF&#34;] or Color(fill_color) == Color(WHITE):
        opacity = 0
        fill_color = BLACK  # shdn&#39;t be necessary but avoids error msgs
    if fill_color in [&#34;#000&#34;, &#34;#000000&#34;]:
        fill_color = WHITE
    if stroke_color in [&#34;&#34;, &#34;none&#34;, &#34;#FFF&#34;, &#34;#FFFFFF&#34;] or Color(stroke_color) == Color(WHITE):
        stroke_width = 0
        stroke_color = BLACK
    if stroke_color in [&#34;#000&#34;, &#34;#000000&#34;]:
        stroke_color = WHITE
    if stroke_width in [&#34;&#34;, &#34;none&#34;, &#34;0&#34;]:
        stroke_width = 0

    if corner_radius in [&#34;&#34;, &#34;0&#34;, &#34;none&#34;]:
        corner_radius = 0

    corner_radius = float(corner_radius)

    if corner_radius == 0:
        mob = Rectangle(
            width=self.attribute_to_float(
                rect_element.getAttribute(&#34;width&#34;)
            ),
            height=self.attribute_to_float(
                rect_element.getAttribute(&#34;height&#34;)
            ),
            stroke_width=stroke_width,
            stroke_color=stroke_color,
            fill_color=fill_color,
            fill_opacity=opacity
        )
    else:
        mob = RoundedRectangle(
            width=self.attribute_to_float(
                rect_element.getAttribute(&#34;width&#34;)
            ),
            height=self.attribute_to_float(
                rect_element.getAttribute(&#34;height&#34;)
            ),
            stroke_width=stroke_width,
            stroke_color=stroke_color,
            fill_color=fill_color,
            fill_opacity=opacity,
            corner_radius=corner_radius
        )

    mob.shift(mob.get_center() - mob.get_corner(UP + LEFT))
    return mob</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.update_ref_to_element"><code class="name flex">
<span>def <span class="ident">update_ref_to_element</span></span>(<span>self, defs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ref_to_element(self, defs):
    new_refs = dict([(e.getAttribute(&#39;id&#39;), e) for e in self.get_all_childNodes_have_id(defs)])
    self.ref_to_element.update(new_refs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.SVGMobject.use_to_mobjects"><code class="name flex">
<span>def <span class="ident">use_to_mobjects</span></span>(<span>self, use_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def use_to_mobjects(self, use_element):
    # Remove initial &#34;#&#34; character
    ref = use_element.getAttribute(&#34;xlink:href&#34;)[1:]
    if ref not in self.ref_to_element:
        warnings.warn(&#34;%s not recognized&#34; % ref)
        return VGroup()
    return self.get_mobjects_from(
        self.ref_to_element[ref]
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring"><code class="flex name class">
<span>class <span class="ident">VMobjectFromSVGPathstring</span></span>
<span>(</span><span>path_string, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VMobjectFromSVGPathstring(VMobject):
    def __init__(self, path_string, **kwargs):
        digest_locals(self)
        VMobject.__init__(self, **kwargs)

    def get_path_commands(self):
        result = [
            &#34;M&#34;,  # moveto
            &#34;L&#34;,  # lineto
            &#34;H&#34;,  # horizontal lineto
            &#34;V&#34;,  # vertical lineto
            &#34;C&#34;,  # curveto
            &#34;S&#34;,  # smooth curveto
            &#34;Q&#34;,  # quadratic Bezier curve
            &#34;T&#34;,  # smooth quadratic Bezier curveto
            &#34;A&#34;,  # elliptical Arc
            &#34;Z&#34;,  # closepath
        ]
        result += [s.lower() for s in result]
        return result

    def generate_points(self):
        pattern = &#34;[%s]&#34; % (&#34;&#34;.join(self.get_path_commands()))
        pairs = list(zip(
            re.findall(pattern, self.path_string),
            re.split(pattern, self.path_string)[1:]
        ))
        # Which mobject should new points be added to
        self = self
        for command, coord_string in pairs:
            self.handle_command(command, coord_string)
        # people treat y-coordinate differently
        self.rotate(np.pi, RIGHT, about_point=ORIGIN)

    def handle_command(self, command, coord_string):
        isLower = command.islower()
        command = command.upper()
        # new_points are the points that will be added to the curr_points
        # list. This variable may get modified in the conditionals below.
        points = self.points
        new_points = self.string_to_points(coord_string)

        if isLower and len(points) &gt; 0:
            new_points += points[-1]

        if command == &#34;M&#34;:  # moveto
            self.start_new_path(new_points[0])
            if len(new_points) &lt;= 1:
                return

            # Draw relative line-to values.
            points = self.points
            new_points = new_points[1:]
            command = &#34;L&#34;

            for p in new_points:
                if isLower:
                    # Treat everything as relative line-to until empty
                    p[0] += self.points[-1, 0]
                    p[1] += self.points[-1, 1]
                self.add_line_to(p)
            return

        elif command in [&#34;L&#34;, &#34;H&#34;, &#34;V&#34;]:  # lineto
            if command == &#34;H&#34;:
                new_points[0, 1] = points[-1, 1]
            elif command == &#34;V&#34;:
                if isLower:
                    new_points[0, 0] -= points[-1, 0]
                    new_points[0, 0] += points[-1, 1]
                new_points[0, 1] = new_points[0, 0]
                new_points[0, 0] = points[-1, 0]
            self.add_line_to(new_points[0])
            return

        if command == &#34;C&#34;:  # curveto
            pass  # Yay! No action required
        elif command in [&#34;S&#34;, &#34;T&#34;]:  # smooth curveto
            self.add_smooth_curve_to(*new_points)
            # handle1 = points[-1] + (points[-1] - points[-2])
            # new_points = np.append([handle1], new_points, axis=0)
            return
        elif command == &#34;Q&#34;:  # quadratic Bezier curve
            # TODO, this is a suboptimal approximation
            new_points = np.append([new_points[0]], new_points, axis=0)
        elif command == &#34;A&#34;:  # elliptical Arc
            raise Exception(&#34;Not implemented&#34;)
        elif command == &#34;Z&#34;:  # closepath
            return

        # Add first three points
        self.add_cubic_bezier_curve_to(*new_points[0:3])

        # Handle situations where there&#39;s multiple relative control points
        if len(new_points) &gt; 3:
            # Add subsequent offset points relatively.
            for i in range(3, len(new_points), 3):
                if isLower:
                    new_points[i:i + 3] -= points[-1]
                    new_points[i:i + 3] += new_points[i - 1]
                self.add_cubic_bezier_curve_to(*new_points[i:i+3])

    def string_to_points(self, coord_string):
        numbers = string_to_numbers(coord_string)
        if len(numbers) % 2 == 1:
            numbers.append(0)
        num_points = len(numbers) // 2
        result = np.zeros((num_points, self.dim))
        result[:, :2] = np.array(numbers).reshape((num_points, 2))
        return result

    def get_original_path_string(self):
        return self.path_string</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.svg.tex_mobject.TexSymbol" href="tex_mobject.html#manimlib.mobject.svg.tex_mobject.TexSymbol">TexSymbol</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.generate_points"><code class="name flex">
<span>def <span class="ident">generate_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_points(self):
    pattern = &#34;[%s]&#34; % (&#34;&#34;.join(self.get_path_commands()))
    pairs = list(zip(
        re.findall(pattern, self.path_string),
        re.split(pattern, self.path_string)[1:]
    ))
    # Which mobject should new points be added to
    self = self
    for command, coord_string in pairs:
        self.handle_command(command, coord_string)
    # people treat y-coordinate differently
    self.rotate(np.pi, RIGHT, about_point=ORIGIN)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.get_original_path_string"><code class="name flex">
<span>def <span class="ident">get_original_path_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_original_path_string(self):
    return self.path_string</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.get_path_commands"><code class="name flex">
<span>def <span class="ident">get_path_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_commands(self):
    result = [
        &#34;M&#34;,  # moveto
        &#34;L&#34;,  # lineto
        &#34;H&#34;,  # horizontal lineto
        &#34;V&#34;,  # vertical lineto
        &#34;C&#34;,  # curveto
        &#34;S&#34;,  # smooth curveto
        &#34;Q&#34;,  # quadratic Bezier curve
        &#34;T&#34;,  # smooth quadratic Bezier curveto
        &#34;A&#34;,  # elliptical Arc
        &#34;Z&#34;,  # closepath
    ]
    result += [s.lower() for s in result]
    return result</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.handle_command"><code class="name flex">
<span>def <span class="ident">handle_command</span></span>(<span>self, command, coord_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_command(self, command, coord_string):
    isLower = command.islower()
    command = command.upper()
    # new_points are the points that will be added to the curr_points
    # list. This variable may get modified in the conditionals below.
    points = self.points
    new_points = self.string_to_points(coord_string)

    if isLower and len(points) &gt; 0:
        new_points += points[-1]

    if command == &#34;M&#34;:  # moveto
        self.start_new_path(new_points[0])
        if len(new_points) &lt;= 1:
            return

        # Draw relative line-to values.
        points = self.points
        new_points = new_points[1:]
        command = &#34;L&#34;

        for p in new_points:
            if isLower:
                # Treat everything as relative line-to until empty
                p[0] += self.points[-1, 0]
                p[1] += self.points[-1, 1]
            self.add_line_to(p)
        return

    elif command in [&#34;L&#34;, &#34;H&#34;, &#34;V&#34;]:  # lineto
        if command == &#34;H&#34;:
            new_points[0, 1] = points[-1, 1]
        elif command == &#34;V&#34;:
            if isLower:
                new_points[0, 0] -= points[-1, 0]
                new_points[0, 0] += points[-1, 1]
            new_points[0, 1] = new_points[0, 0]
            new_points[0, 0] = points[-1, 0]
        self.add_line_to(new_points[0])
        return

    if command == &#34;C&#34;:  # curveto
        pass  # Yay! No action required
    elif command in [&#34;S&#34;, &#34;T&#34;]:  # smooth curveto
        self.add_smooth_curve_to(*new_points)
        # handle1 = points[-1] + (points[-1] - points[-2])
        # new_points = np.append([handle1], new_points, axis=0)
        return
    elif command == &#34;Q&#34;:  # quadratic Bezier curve
        # TODO, this is a suboptimal approximation
        new_points = np.append([new_points[0]], new_points, axis=0)
    elif command == &#34;A&#34;:  # elliptical Arc
        raise Exception(&#34;Not implemented&#34;)
    elif command == &#34;Z&#34;:  # closepath
        return

    # Add first three points
    self.add_cubic_bezier_curve_to(*new_points[0:3])

    # Handle situations where there&#39;s multiple relative control points
    if len(new_points) &gt; 3:
        # Add subsequent offset points relatively.
        for i in range(3, len(new_points), 3):
            if isLower:
                new_points[i:i + 3] -= points[-1]
                new_points[i:i + 3] += new_points[i - 1]
            self.add_cubic_bezier_curve_to(*new_points[i:i+3])</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.string_to_points"><code class="name flex">
<span>def <span class="ident">string_to_points</span></span>(<span>self, coord_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_to_points(self, coord_string):
    numbers = string_to_numbers(coord_string)
    if len(numbers) % 2 == 1:
        numbers.append(0)
    num_points = len(numbers) // 2
    result = np.zeros((num_points, self.dim))
    result[:, :2] = np.array(numbers).reshape((num_points, 2))
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="../types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.mobject.svg" href="index.html">manimlib.mobject.svg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="manimlib.mobject.svg.svg_mobject.string_to_numbers" href="#manimlib.mobject.svg.svg_mobject.string_to_numbers">string_to_numbers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject" href="#manimlib.mobject.svg.svg_mobject.SVGMobject">SVGMobject</a></code></h4>
<ul class="">
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.CONFIG" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.attribute_to_float" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.attribute_to_float">attribute_to_float</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.circle_to_mobject" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.circle_to_mobject">circle_to_mobject</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.ellipse_to_mobject" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.ellipse_to_mobject">ellipse_to_mobject</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.ensure_valid_file" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.ensure_valid_file">ensure_valid_file</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.flatten" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.flatten">flatten</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.g_to_mobjects" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.g_to_mobjects">g_to_mobjects</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.generate_points" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.generate_points">generate_points</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_all_childNodes_have_id" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.get_all_childNodes_have_id">get_all_childNodes_have_id</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_mobjects_from" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.get_mobjects_from">get_mobjects_from</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.handle_transforms" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.handle_transforms">handle_transforms</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.move_into_position" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.move_into_position">move_into_position</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.path_string_to_mobject" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.path_string_to_mobject">path_string_to_mobject</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.polygon_to_mobject" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.polygon_to_mobject">polygon_to_mobject</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.rect_to_mobject" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.rect_to_mobject">rect_to_mobject</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.update_ref_to_element" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.update_ref_to_element">update_ref_to_element</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.use_to_mobjects" href="#manimlib.mobject.svg.svg_mobject.SVGMobject.use_to_mobjects">use_to_mobjects</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring" href="#manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring">VMobjectFromSVGPathstring</a></code></h4>
<ul class="">
<li><code><a title="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.generate_points" href="#manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.generate_points">generate_points</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.get_original_path_string" href="#manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.get_original_path_string">get_original_path_string</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.get_path_commands" href="#manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.get_path_commands">get_path_commands</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.handle_command" href="#manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.handle_command">handle_command</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.string_to_points" href="#manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring.string_to_points">string_to_points</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>