<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.mobject.mobject API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.mobject.mobject</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from functools import reduce
import copy
import itertools as it
import operator as op
import os
import random
import sys

from colour import Color
import numpy as np

import manimlib.constants as consts
from manimlib.constants import *
from manimlib.container.container import Container
from manimlib.utils.color import color_gradient
from manimlib.utils.color import interpolate_color
from manimlib.utils.iterables import list_update
from manimlib.utils.iterables import remove_list_redundancies
from manimlib.utils.paths import straight_path
from manimlib.utils.simple_functions import get_parameters
from manimlib.utils.space_ops import angle_of_vector
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import rotation_matrix


# TODO: Explain array_attrs

class Mobject(Container):
    &#34;&#34;&#34;
    Mathematical Object
    &#34;&#34;&#34;
    CONFIG = {
        &#34;color&#34;: WHITE,
        &#34;name&#34;: None,
        &#34;dim&#34;: 3,
        &#34;target&#34;: None,
    }

    def __init__(self, **kwargs):
        Container.__init__(self, **kwargs)
        self.submobjects = []
        self.color = Color(self.color)
        if self.name is None:
            self.name = self.__class__.__name__
        self.updaters = []
        self.updating_suspended = False
        self.reset_points()
        self.generate_points()
        self.init_colors()

    def __str__(self):
        return str(self.name)

    def reset_points(self):
        self.points = np.zeros((0, self.dim))

    def init_colors(self):
        # For subclasses
        pass

    def generate_points(self):
        # Typically implemented in subclass, unless purposefully left blank
        pass

    def add(self, *mobjects):
        if self in mobjects:
            raise Exception(&#34;Mobject cannot contain self&#34;)
        self.submobjects = list_update(self.submobjects, mobjects)
        return self

    def add_to_back(self, *mobjects):
        self.remove(*mobjects)
        self.submobjects = list(mobjects) + self.submobjects
        return self

    def remove(self, *mobjects):
        for mobject in mobjects:
            if mobject in self.submobjects:
                self.submobjects.remove(mobject)
        return self

    def get_array_attrs(self):
        return [&#34;points&#34;]

    def digest_mobject_attrs(self):
        &#34;&#34;&#34;
        Ensures all attributes which are mobjects are included
        in the submobjects list.
        &#34;&#34;&#34;
        mobject_attrs = [x for x in list(self.__dict__.values()) if isinstance(x, Mobject)]
        self.submobjects = list_update(self.submobjects, mobject_attrs)
        return self

    def apply_over_attr_arrays(self, func):
        for attr in self.get_array_attrs():
            setattr(self, attr, func(getattr(self, attr)))
        return self

    # Displaying

    def get_image(self, camera=None):
        if camera is None:
            from manimlib.camera.camera import Camera
            camera = Camera()
        camera.capture_mobject(self)
        return camera.get_image()

    def show(self, camera=None):
        self.get_image(camera=camera).show()

    def save_image(self, name=None):
        self.get_image().save(
            os.path.join(consts.VIDEO_DIR, (name or str(self)) + &#34;.png&#34;)
        )

    def copy(self):
        # TODO, either justify reason for shallow copy, or
        # remove this redundancy everywhere
        # return self.deepcopy()

        copy_mobject = copy.copy(self)
        copy_mobject.points = np.array(self.points)
        copy_mobject.submobjects = [
            submob.copy() for submob in self.submobjects
        ]
        copy_mobject.updaters = list(self.updaters)
        family = self.get_family()
        for attr, value in list(self.__dict__.items()):
            if isinstance(value, Mobject) and value in family and value is not self:
                setattr(copy_mobject, attr, value.copy())
            if isinstance(value, np.ndarray):
                setattr(copy_mobject, attr, np.array(value))
        return copy_mobject

    def deepcopy(self):
        return copy.deepcopy(self)

    def generate_target(self, use_deepcopy=False):
        self.target = None  # Prevent exponential explosion
        if use_deepcopy:
            self.target = self.deepcopy()
        else:
            self.target = self.copy()
        return self.target

    # Updating

    def update(self, dt=0, recursive=True):
        if self.updating_suspended:
            return self
        for updater in self.updaters:
            parameters = get_parameters(updater)
            if &#34;dt&#34; in parameters:
                updater(self, dt)
            else:
                updater(self)
        if recursive:
            for submob in self.submobjects:
                submob.update(dt, recursive)
        return self

    def get_time_based_updaters(self):
        return [
            updater for updater in self.updaters
            if &#34;dt&#34; in get_parameters(updater)
        ]

    def has_time_based_updater(self):
        for updater in self.updaters:
            if &#34;dt&#34; in get_parameters(updater):
                return True
        return False

    def get_updaters(self):
        return self.updaters

    def get_family_updaters(self):
        return list(it.chain(*[
            sm.get_updaters()
            for sm in self.get_family()
        ]))

    def add_updater(self, update_function, index=None, call_updater=True):
        if index is None:
            self.updaters.append(update_function)
        else:
            self.updaters.insert(index, update_function)
        if call_updater:
            self.update(0)
        return self

    def remove_updater(self, update_function):
        while update_function in self.updaters:
            self.updaters.remove(update_function)
        return self

    def clear_updaters(self, recursive=True):
        self.updaters = []
        if recursive:
            for submob in self.submobjects:
                submob.clear_updaters()
        return self

    def match_updaters(self, mobject):
        self.clear_updaters()
        for updater in mobject.get_updaters():
            self.add_updater(updater)
        return self

    def suspend_updating(self, recursive=True):
        self.updating_suspended = True
        if recursive:
            for submob in self.submobjects:
                submob.suspend_updating(recursive)
        return self

    def resume_updating(self, recursive=True):
        self.updating_suspended = False
        if recursive:
            for submob in self.submobjects:
                submob.resume_updating(recursive)
        self.update(dt=0, recursive=recursive)
        return self

    # Transforming operations

    def apply_to_family(self, func):
        for mob in self.family_members_with_points():
            func(mob)

    def shift(self, *vectors):
        total_vector = reduce(op.add, vectors)
        for mob in self.family_members_with_points():
            mob.points = mob.points.astype(&#39;float&#39;)
            mob.points += total_vector
        return self

    def scale(self, scale_factor, **kwargs):
        &#34;&#34;&#34;
        Default behavior is to scale about the center of the mobject.
        The argument about_edge can be a vector, indicating which side of
        the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)
        scales about mob.get_right().

        Otherwise, if about_point is given a value, scaling is done with
        respect to that point.
        &#34;&#34;&#34;
        self.apply_points_function_about_point(
            lambda points: scale_factor * points, **kwargs
        )
        return self

    def rotate_about_origin(self, angle, axis=OUT, axes=[]):
        return self.rotate(angle, axis, about_point=ORIGIN)

    def rotate(self, angle, axis=OUT, **kwargs):
        rot_matrix = rotation_matrix(angle, axis)
        self.apply_points_function_about_point(
            lambda points: np.dot(points, rot_matrix.T),
            **kwargs
        )
        return self

    def flip(self, axis=UP, **kwargs):
        return self.rotate(TAU / 2, axis, **kwargs)

    def stretch(self, factor, dim, **kwargs):
        def func(points):
            points[:, dim] *= factor
            return points
        self.apply_points_function_about_point(func, **kwargs)
        return self

    def apply_function(self, function, **kwargs):
        # Default to applying matrix about the origin, not mobjects center
        if len(kwargs) == 0:
            kwargs[&#34;about_point&#34;] = ORIGIN
        self.apply_points_function_about_point(
            lambda points: np.apply_along_axis(function, 1, points),
            **kwargs
        )
        return self

    def apply_function_to_position(self, function):
        self.move_to(function(self.get_center()))
        return self

    def apply_function_to_submobject_positions(self, function):
        for submob in self.submobjects:
            submob.apply_function_to_position(function)
        return self

    def apply_matrix(self, matrix, **kwargs):
        # Default to applying matrix about the origin, not mobjects center
        if (&#34;about_point&#34; not in kwargs) and (&#34;about_edge&#34; not in kwargs):
            kwargs[&#34;about_point&#34;] = ORIGIN
        full_matrix = np.identity(self.dim)
        matrix = np.array(matrix)
        full_matrix[:matrix.shape[0], :matrix.shape[1]] = matrix
        self.apply_points_function_about_point(
            lambda points: np.dot(points, full_matrix.T),
            **kwargs
        )
        return self

    def apply_complex_function(self, function, **kwargs):
        def R3_func(point):
            x, y, z = point
            xy_complex = function(complex(x, y))
            return [
                xy_complex.real,
                xy_complex.imag,
                z
            ]
        return self.apply_function(R3_func)

    def wag(self, direction=RIGHT, axis=DOWN, wag_factor=1.0):
        for mob in self.family_members_with_points():
            alphas = np.dot(mob.points, np.transpose(axis))
            alphas -= min(alphas)
            alphas /= max(alphas)
            alphas = alphas**wag_factor
            mob.points += np.dot(
                alphas.reshape((len(alphas), 1)),
                np.array(direction).reshape((1, mob.dim))
            )
        return self

    def reverse_points(self):
        for mob in self.family_members_with_points():
            mob.apply_over_attr_arrays(
                lambda arr: np.array(list(reversed(arr)))
            )
        return self

    def repeat(self, count):
        &#34;&#34;&#34;
        This can make transition animations nicer
        &#34;&#34;&#34;
        def repeat_array(array):
            return reduce(
                lambda a1, a2: np.append(a1, a2, axis=0),
                [array] * count
            )
        for mob in self.family_members_with_points():
            mob.apply_over_attr_arrays(repeat_array)
        return self

    # In place operations.
    # Note, much of these are now redundant with default behavior of
    # above methods

    def apply_points_function_about_point(self, func, about_point=None, about_edge=None):
        if about_point is None:
            if about_edge is None:
                about_edge = ORIGIN
            about_point = self.get_critical_point(about_edge)
        for mob in self.family_members_with_points():
            mob.points -= about_point
            mob.points = func(mob.points)
            mob.points += about_point
        return self

    def rotate_in_place(self, angle, axis=OUT):
        # redundant with default behavior of rotate now.
        return self.rotate(angle, axis=axis)

    def scale_in_place(self, scale_factor, **kwargs):
        # Redundant with default behavior of scale now.
        return self.scale(scale_factor, **kwargs)

    def scale_about_point(self, scale_factor, point):
        # Redundant with default behavior of scale now.
        return self.scale(scale_factor, about_point=point)

    def pose_at_angle(self, **kwargs):
        self.rotate(TAU / 14, RIGHT + UP, **kwargs)
        return self

    # Positioning methods

    def center(self):
        self.shift(-self.get_center())
        return self

    def align_on_border(self, direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
        &#34;&#34;&#34;
        Direction just needs to be a vector pointing towards side or
        corner in the 2d plane.
        &#34;&#34;&#34;
        target_point = np.sign(direction) * (FRAME_X_RADIUS, FRAME_Y_RADIUS, 0)
        point_to_align = self.get_critical_point(direction)
        shift_val = target_point - point_to_align - buff * np.array(direction)
        shift_val = shift_val * abs(np.sign(direction))
        self.shift(shift_val)
        return self

    def to_corner(self, corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
        return self.align_on_border(corner, buff)

    def to_edge(self, edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
        return self.align_on_border(edge, buff)

    def next_to(self, mobject_or_point,
                direction=RIGHT,
                buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
                aligned_edge=ORIGIN,
                submobject_to_align=None,
                index_of_submobject_to_align=None,
                coor_mask=np.array([1, 1, 1]),
                ):
        if isinstance(mobject_or_point, Mobject):
            mob = mobject_or_point
            if index_of_submobject_to_align is not None:
                target_aligner = mob[index_of_submobject_to_align]
            else:
                target_aligner = mob
            target_point = target_aligner.get_critical_point(
                aligned_edge + direction
            )
        else:
            target_point = mobject_or_point
        if submobject_to_align is not None:
            aligner = submobject_to_align
        elif index_of_submobject_to_align is not None:
            aligner = self[index_of_submobject_to_align]
        else:
            aligner = self
        point_to_align = aligner.get_critical_point(aligned_edge - direction)
        self.shift((target_point - point_to_align +
                    buff * direction) * coor_mask)
        return self

    def shift_onto_screen(self, **kwargs):
        space_lengths = [FRAME_X_RADIUS, FRAME_Y_RADIUS]
        for vect in UP, DOWN, LEFT, RIGHT:
            dim = np.argmax(np.abs(vect))
            buff = kwargs.get(&#34;buff&#34;, DEFAULT_MOBJECT_TO_EDGE_BUFFER)
            max_val = space_lengths[dim] - buff
            edge_center = self.get_edge_center(vect)
            if np.dot(edge_center, vect) &gt; max_val:
                self.to_edge(vect, **kwargs)
        return self

    def is_off_screen(self):
        if self.get_left()[0] &gt; FRAME_X_RADIUS:
            return True
        if self.get_right()[0] &lt; -FRAME_X_RADIUS:
            return True
        if self.get_bottom()[1] &gt; FRAME_Y_RADIUS:
            return True
        if self.get_top()[1] &lt; -FRAME_Y_RADIUS:
            return True
        return False

    def stretch_about_point(self, factor, dim, point):
        return self.stretch(factor, dim, about_point=point)

    def stretch_in_place(self, factor, dim):
        # Now redundant with stretch
        return self.stretch(factor, dim)

    def rescale_to_fit(self, length, dim, stretch=False, **kwargs):
        old_length = self.length_over_dim(dim)
        if old_length == 0:
            return self
        if stretch:
            self.stretch(length / old_length, dim, **kwargs)
        else:
            self.scale(length / old_length, **kwargs)
        return self

    def stretch_to_fit_width(self, width, **kwargs):
        return self.rescale_to_fit(width, 0, stretch=True, **kwargs)

    def stretch_to_fit_height(self, height, **kwargs):
        return self.rescale_to_fit(height, 1, stretch=True, **kwargs)

    def stretch_to_fit_depth(self, depth, **kwargs):
        return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)

    def set_width(self, width, stretch=False, **kwargs):
        return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)

    def set_height(self, height, stretch=False, **kwargs):
        return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)

    def set_depth(self, depth, stretch=False, **kwargs):
        return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)

    def set_coord(self, value, dim, direction=ORIGIN):
        curr = self.get_coord(dim, direction)
        shift_vect = np.zeros(self.dim)
        shift_vect[dim] = value - curr
        self.shift(shift_vect)
        return self

    def set_x(self, x, direction=ORIGIN):
        return self.set_coord(x, 0, direction)

    def set_y(self, y, direction=ORIGIN):
        return self.set_coord(y, 1, direction)

    def set_z(self, z, direction=ORIGIN):
        return self.set_coord(z, 2, direction)

    def space_out_submobjects(self, factor=1.5, **kwargs):
        self.scale(factor, **kwargs)
        for submob in self.submobjects:
            submob.scale(1. / factor)
        return self

    def move_to(self, point_or_mobject, aligned_edge=ORIGIN,
                coor_mask=np.array([1, 1, 1])):
        if isinstance(point_or_mobject, Mobject):
            target = point_or_mobject.get_critical_point(aligned_edge)
        else:
            target = point_or_mobject
        point_to_align = self.get_critical_point(aligned_edge)
        self.shift((target - point_to_align) * coor_mask)
        return self

    def replace(self, mobject, dim_to_match=0, stretch=False):
        if not mobject.get_num_points() and not mobject.submobjects:
            raise Warning(&#34;Attempting to replace mobject with no points&#34;)
            return self
        if stretch:
            self.stretch_to_fit_width(mobject.get_width())
            self.stretch_to_fit_height(mobject.get_height())
        else:
            self.rescale_to_fit(
                mobject.length_over_dim(dim_to_match),
                dim_to_match,
                stretch=False
            )
        self.shift(mobject.get_center() - self.get_center())
        return self

    def surround(self, mobject,
                 dim_to_match=0,
                 stretch=False,
                 buff=MED_SMALL_BUFF):
        self.replace(mobject, dim_to_match, stretch)
        length = mobject.length_over_dim(dim_to_match)
        self.scale_in_place((length + buff) / length)
        return self

    def put_start_and_end_on(self, start, end):
        curr_start, curr_end = self.get_start_and_end()
        curr_vect = curr_end - curr_start
        if np.all(curr_vect == 0):
            raise Exception(&#34;Cannot position endpoints of closed loop&#34;)
        target_vect = end - start
        self.scale(
            get_norm(target_vect) / get_norm(curr_vect),
            about_point=curr_start,
        )
        self.rotate(
            angle_of_vector(target_vect) -
            angle_of_vector(curr_vect),
            about_point=curr_start
        )
        self.shift(start - curr_start)
        return self

    # Background rectangle
    def add_background_rectangle(self, color=BLACK, opacity=0.75, **kwargs):
        # TODO, this does not behave well when the mobject has points,
        # since it gets displayed on top
        from manimlib.mobject.shape_matchers import BackgroundRectangle
        self.background_rectangle = BackgroundRectangle(
            self, color=color,
            fill_opacity=opacity,
            **kwargs
        )
        self.add_to_back(self.background_rectangle)
        return self

    def add_background_rectangle_to_submobjects(self, **kwargs):
        for submobject in self.submobjects:
            submobject.add_background_rectangle(**kwargs)
        return self

    def add_background_rectangle_to_family_members_with_points(self, **kwargs):
        for mob in self.family_members_with_points():
            mob.add_background_rectangle(**kwargs)
        return self

    # Color functions

    def set_color(self, color=YELLOW_C, family=True):
        &#34;&#34;&#34;
        Condition is function which takes in one arguments, (x, y, z).
        Here it just recurses to submobjects, but in subclasses this
        should be further implemented based on the the inner workings
        of color
        &#34;&#34;&#34;
        if family:
            for submob in self.submobjects:
                submob.set_color(color, family=family)
        self.color = color
        return self

    def set_color_by_gradient(self, *colors):
        self.set_submobject_colors_by_gradient(*colors)
        return self

    def set_colors_by_radial_gradient(self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK):
        self.set_submobject_colors_by_radial_gradient(
            center, radius, inner_color, outer_color)
        return self

    def set_submobject_colors_by_gradient(self, *colors):
        if len(colors) == 0:
            raise Exception(&#34;Need at least one color&#34;)
        elif len(colors) == 1:
            return self.set_color(*colors)

        mobs = self.family_members_with_points()
        new_colors = color_gradient(colors, len(mobs))

        for mob, color in zip(mobs, new_colors):
            mob.set_color(color, family=False)
        return self

    def set_submobject_colors_by_radial_gradient(self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK):
        if center is None:
            center = self.get_center()

        for mob in self.family_members_with_points():
            t = get_norm(mob.get_center() - center) / radius
            t = min(t, 1)
            mob_color = interpolate_color(inner_color, outer_color, t)
            mob.set_color(mob_color, family=False)

        return self

    def to_original_color(self):
        self.set_color(self.color)
        return self

    def fade_to(self, color, alpha, family=True):
        if self.get_num_points() &gt; 0:
            new_color = interpolate_color(
                self.get_color(), color, alpha
            )
            self.set_color(new_color, family=False)
        if family:
            for submob in self.submobjects:
                submob.fade_to(color, alpha)
        return self

    def fade(self, darkness=0.5, family=True):
        if family:
            for submob in self.submobjects:
                submob.fade(darkness, family)
        return self

    def get_color(self):
        return self.color

    ##

    def save_state(self, use_deepcopy=False):
        if hasattr(self, &#34;saved_state&#34;):
            # Prevent exponential growth of data
            self.saved_state = None
        if use_deepcopy:
            self.saved_state = self.deepcopy()
        else:
            self.saved_state = self.copy()
        return self

    def restore(self):
        if not hasattr(self, &#34;saved_state&#34;) or self.save_state is None:
            raise Exception(&#34;Trying to restore without having saved&#34;)
        self.become(self.saved_state)
        return self

    ##

    def reduce_across_dimension(self, points_func, reduce_func, dim):
        points = self.get_all_points()
        if points is None or len(points) == 0:
            # Note, this default means things like empty VGroups
            # will appear to have a center at [0, 0, 0]
            return 0
        values = points_func(points[:, dim])
        return reduce_func(values)

    def nonempty_submobjects(self):
        return [
            submob for submob in self.submobjects
            if len(submob.submobjects) != 0 or len(submob.points) != 0
        ]

    def get_merged_array(self, array_attr):
        result = getattr(self, array_attr)
        for submob in self.submobjects:
            result = np.append(
                result, submob.get_merged_array(array_attr),
                axis=0
            )
            submob.get_merged_array(array_attr)
        return result

    def get_all_points(self):
        return self.get_merged_array(&#34;points&#34;)

    # Getters

    def get_points_defining_boundary(self):
        return self.get_all_points()

    def get_num_points(self):
        return len(self.points)

    def get_extremum_along_dim(self, points=None, dim=0, key=0):
        if points is None:
            points = self.get_points_defining_boundary()
        values = points[:, dim]
        if key &lt; 0:
            return np.min(values)
        elif key == 0:
            return (np.min(values) + np.max(values)) / 2
        else:
            return np.max(values)

    def get_critical_point(self, direction):
        &#34;&#34;&#34;
        Picture a box bounding the mobject.  Such a box has
        9 &#39;critical points&#39;: 4 corners, 4 edge center, the
        center.  This returns one of them.
        &#34;&#34;&#34;
        result = np.zeros(self.dim)
        all_points = self.get_points_defining_boundary()
        if len(all_points) == 0:
            return result
        for dim in range(self.dim):
            result[dim] = self.get_extremum_along_dim(
                all_points, dim=dim, key=direction[dim]
            )
        return result

    # Pseudonyms for more general get_critical_point method

    def get_edge_center(self, direction):
        return self.get_critical_point(direction)

    def get_corner(self, direction):
        return self.get_critical_point(direction)

    def get_center(self):
        return self.get_critical_point(np.zeros(self.dim))

    def get_center_of_mass(self):
        return np.apply_along_axis(np.mean, 0, self.get_all_points())

    def get_boundary_point(self, direction):
        all_points = self.get_points_defining_boundary()
        index = np.argmax(np.dot(all_points, np.array(direction).T))
        return all_points[index]

    def get_top(self):
        return self.get_edge_center(UP)

    def get_bottom(self):
        return self.get_edge_center(DOWN)

    def get_right(self):
        return self.get_edge_center(RIGHT)

    def get_left(self):
        return self.get_edge_center(LEFT)

    def get_zenith(self):
        return self.get_edge_center(OUT)

    def get_nadir(self):
        return self.get_edge_center(IN)

    def length_over_dim(self, dim):
        return (
            self.reduce_across_dimension(np.max, np.max, dim) -
            self.reduce_across_dimension(np.min, np.min, dim)
        )

    def get_width(self):
        return self.length_over_dim(0)

    def get_height(self):
        return self.length_over_dim(1)

    def get_depth(self):
        return self.length_over_dim(2)

    def get_coord(self, dim, direction=ORIGIN):
        &#34;&#34;&#34;
        Meant to generalize get_x, get_y, get_z
        &#34;&#34;&#34;
        return self.get_extremum_along_dim(
            dim=dim, key=direction[dim]
        )

    def get_x(self, direction=ORIGIN):
        return self.get_coord(0, direction)

    def get_y(self, direction=ORIGIN):
        return self.get_coord(1, direction)

    def get_z(self, direction=ORIGIN):
        return self.get_coord(2, direction)

    def get_start(self):
        self.throw_error_if_no_points()
        return np.array(self.points[0])

    def get_end(self):
        self.throw_error_if_no_points()
        return np.array(self.points[-1])

    def get_start_and_end(self):
        return self.get_start(), self.get_end()

    def point_from_proportion(self, alpha):
        raise Exception(&#34;Not implemented&#34;)

    def get_pieces(self, n_pieces):
        template = self.copy()
        template.submobjects = []
        alphas = np.linspace(0, 1, n_pieces + 1)
        return Group(*[
            template.copy().pointwise_become_partial(
                self, a1, a2
            )
            for a1, a2 in zip(alphas[:-1], alphas[1:])
        ])

    def get_z_index_reference_point(self):
        # TODO, better place to define default z_index_group?
        z_index_group = getattr(self, &#34;z_index_group&#34;, self)
        return z_index_group.get_center()

    def has_points(self):
        return len(self.points) &gt; 0

    def has_no_points(self):
        return not self.has_points()

    # Match other mobject properties

    def match_color(self, mobject):
        return self.set_color(mobject.get_color())

    def match_dim_size(self, mobject, dim, **kwargs):
        return self.rescale_to_fit(
            mobject.length_over_dim(dim), dim,
            **kwargs
        )

    def match_width(self, mobject, **kwargs):
        return self.match_dim_size(mobject, 0, **kwargs)

    def match_height(self, mobject, **kwargs):
        return self.match_dim_size(mobject, 1, **kwargs)

    def match_depth(self, mobject, **kwargs):
        return self.match_dim_size(mobject, 2, **kwargs)

    def match_coord(self, mobject, dim, direction=ORIGIN):
        return self.set_coord(
            mobject.get_coord(dim, direction),
            dim=dim,
            direction=direction,
        )

    def match_x(self, mobject, direction=ORIGIN):
        return self.match_coord(mobject, 0, direction)

    def match_y(self, mobject, direction=ORIGIN):
        return self.match_coord(mobject, 1, direction)

    def match_z(self, mobject, direction=ORIGIN):
        return self.match_coord(mobject, 2, direction)

    def align_to(self, mobject_or_point, direction=ORIGIN, alignment_vect=UP):
        &#34;&#34;&#34;
        Examples:
        mob1.align_to(mob2, UP) moves mob1 vertically so that its
        top edge lines ups with mob2&#39;s top edge.

        mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1
        horizontally so that it&#39;s center is directly above/below
        the center of mob2
        &#34;&#34;&#34;
        if isinstance(mobject_or_point, Mobject):
            point = mobject_or_point.get_critical_point(direction)
        else:
            point = mobject_or_point

        for dim in range(self.dim):
            if direction[dim] != 0:
                self.set_coord(point[dim], dim, direction)
        return self

    # Family matters

    def __getitem__(self, value):
        self_list = self.split()
        if isinstance(value, slice):
            GroupClass = self.get_group_class()
            return GroupClass(*self_list.__getitem__(value))
        return self_list.__getitem__(value)

    def __iter__(self):
        return iter(self.split())

    def __len__(self):
        return len(self.split())

    def get_group_class(self):
        return Group

    def split(self):
        result = [self] if len(self.points) &gt; 0 else []
        return result + self.submobjects

    def get_family(self):
        sub_families = list(map(Mobject.get_family, self.submobjects))
        all_mobjects = [self] + list(it.chain(*sub_families))
        return remove_list_redundancies(all_mobjects)

    def family_members_with_points(self):
        return [m for m in self.get_family() if m.get_num_points() &gt; 0]

    def arrange(self, direction=RIGHT, center=True, **kwargs):
        for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
            m2.next_to(m1, direction, **kwargs)
        if center:
            self.center()
        return self

    def arrange_in_grid(self, n_rows=None, n_cols=None, **kwargs):
        submobs = self.submobjects
        if n_rows is None and n_cols is None:
            n_cols = int(np.sqrt(len(submobs)))

        if n_rows is not None:
            v1 = RIGHT
            v2 = DOWN
            n = len(submobs) // n_rows
        elif n_cols is not None:
            v1 = DOWN
            v2 = RIGHT
            n = len(submobs) // n_cols
        Group(*[
            Group(*submobs[i:i + n]).arrange(v1, **kwargs)
            for i in range(0, len(submobs), n)
        ]).arrange(v2, **kwargs)
        return self

    def sort(self, point_to_num_func=lambda p: p[0], submob_func=None):
        if submob_func is None:
            submob_func = lambda m: point_to_num_func(m.get_center())
        self.submobjects.sort(key=submob_func)
        return self

    def shuffle(self, recursive=False):
        if recursive:
            for submob in self.submobjects:
                submob.shuffle(recursive=True)
        random.shuffle(self.submobjects)

    # Just here to keep from breaking old scenes.
    def arrange_submobjects(self, *args, **kwargs):
        return self.arrange(*args, **kwargs)

    def sort_submobjects(self, *args, **kwargs):
        return self.sort(*args, **kwargs)

    def shuffle_submobjects(self, *args, **kwargs):
        return self.shuffle(*args, **kwargs)

    # Alignment
    def align_data(self, mobject):
        self.null_point_align(mobject)
        self.align_submobjects(mobject)
        self.align_points(mobject)
        # Recurse
        for m1, m2 in zip(self.submobjects, mobject.submobjects):
            m1.align_data(m2)

    def get_point_mobject(self, center=None):
        &#34;&#34;&#34;
        The simplest mobject to be transformed to or from self.
        Should by a point of the appropriate type
        &#34;&#34;&#34;
        message = &#34;get_point_mobject not implemented for {}&#34;
        raise Exception(message.format(self.__class__.__name__))

    def align_points(self, mobject):
        count1 = self.get_num_points()
        count2 = mobject.get_num_points()
        if count1 &lt; count2:
            self.align_points_with_larger(mobject)
        elif count2 &lt; count1:
            mobject.align_points_with_larger(self)
        return self

    def align_points_with_larger(self, larger_mobject):
        raise Exception(&#34;Not implemented&#34;)

    def align_submobjects(self, mobject):
        mob1 = self
        mob2 = mobject
        n1 = len(mob1.submobjects)
        n2 = len(mob2.submobjects)
        mob1.add_n_more_submobjects(max(0, n2 - n1))
        mob2.add_n_more_submobjects(max(0, n1 - n2))
        return self

    def null_point_align(self, mobject):
        &#34;&#34;&#34;
        If a mobject with points is being aligned to
        one without, treat both as groups, and push
        the one with points into its own submobjects
        list.
        &#34;&#34;&#34;
        for m1, m2 in (self, mobject), (mobject, self):
            if m1.has_no_points() and m2.has_points():
                m2.push_self_into_submobjects()
        return self

    def push_self_into_submobjects(self):
        copy = self.copy()
        copy.submobjects = []
        self.reset_points()
        self.add(copy)
        return self

    def add_n_more_submobjects(self, n):
        if n == 0:
            return

        curr = len(self.submobjects)
        if curr == 0:
            # If empty, simply add n point mobjects
            self.submobjects = [
                self.get_point_mobject()
                for k in range(n)
            ]
            return

        target = curr + n
        # TODO, factor this out to utils so as to reuse
        # with VMobject.insert_n_curves
        repeat_indices = (np.arange(target) * curr) // target
        split_factors = [
            sum(repeat_indices == i)
            for i in range(curr)
        ]
        new_submobs = []
        for submob, sf in zip(self.submobjects, split_factors):
            new_submobs.append(submob)
            for k in range(1, sf):
                new_submobs.append(
                    submob.copy().fade(1)
                )
        self.submobjects = new_submobs
        return self

    def repeat_submobject(self, submob):
        return submob.copy()

    def interpolate(self, mobject1, mobject2,
                    alpha, path_func=straight_path):
        &#34;&#34;&#34;
        Turns self into an interpolation between mobject1
        and mobject2.
        &#34;&#34;&#34;
        self.points = path_func(
            mobject1.points, mobject2.points, alpha
        )
        self.interpolate_color(mobject1, mobject2, alpha)
        return self

    def interpolate_color(self, mobject1, mobject2, alpha):
        pass  # To implement in subclass

    def become_partial(self, mobject, a, b):
        &#34;&#34;&#34;
        Set points in such a way as to become only
        part of mobject.
        Inputs 0 &lt;= a &lt; b &lt;= 1 determine what portion
        of mobject to become.
        &#34;&#34;&#34;
        pass  # To implement in subclasses

        # TODO, color?

    def pointwise_become_partial(self, mobject, a, b):
        pass  # To implement in subclass

    def become(self, mobject, copy_submobjects=True):
        &#34;&#34;&#34;
        Edit points, colors and submobjects to be idential
        to another mobject
        &#34;&#34;&#34;
        self.align_data(mobject)
        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
            sm1.points = np.array(sm2.points)
            sm1.interpolate_color(sm1, sm2, 1)
        return self

    # Errors
    def throw_error_if_no_points(self):
        if self.has_no_points():
            message = &#34;Cannot call Mobject.{} &#34; +\
                      &#34;for a Mobject with no points&#34;
            caller_name = sys._getframe(1).f_code.co_name
            raise Exception(message.format(caller_name))


class Group(Mobject):
    def __init__(self, *mobjects, **kwargs):
        if not all([isinstance(m, Mobject) for m in mobjects]):
            raise Exception(&#34;All submobjects must be of type Mobject&#34;)
        Mobject.__init__(self, **kwargs)
        self.add(*mobjects)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.mobject.mobject.Group"><code class="flex name class">
<span>class <span class="ident">Group</span></span>
<span>(</span><span>*mobjects, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Group(Mobject):
    def __init__(self, *mobjects, **kwargs):
        if not all([isinstance(m, Mobject) for m in mobjects]):
            raise Exception(&#34;All submobjects must be of type Mobject&#34;)
        Mobject.__init__(self, **kwargs)
        self.add(*mobjects)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.mobject.Mobject" href="#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.mobject.Mobject" href="#manimlib.mobject.mobject.Mobject">Mobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.mobject.Mobject.add" href="../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_on_border" href="#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_to" href="#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.become" href="#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.become_partial" href="#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.digest_mobject_attrs" href="#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_coord" href="#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_critical_point" href="#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_point_mobject" href="#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.interpolate" href="#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.null_point_align" href="#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.remove" href="../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.repeat" href="#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.scale" href="#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_color" href="#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.mobject.mobject.Mobject"><code class="flex name class">
<span>class <span class="ident">Mobject</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mobject(Container):
    &#34;&#34;&#34;
    Mathematical Object
    &#34;&#34;&#34;
    CONFIG = {
        &#34;color&#34;: WHITE,
        &#34;name&#34;: None,
        &#34;dim&#34;: 3,
        &#34;target&#34;: None,
    }

    def __init__(self, **kwargs):
        Container.__init__(self, **kwargs)
        self.submobjects = []
        self.color = Color(self.color)
        if self.name is None:
            self.name = self.__class__.__name__
        self.updaters = []
        self.updating_suspended = False
        self.reset_points()
        self.generate_points()
        self.init_colors()

    def __str__(self):
        return str(self.name)

    def reset_points(self):
        self.points = np.zeros((0, self.dim))

    def init_colors(self):
        # For subclasses
        pass

    def generate_points(self):
        # Typically implemented in subclass, unless purposefully left blank
        pass

    def add(self, *mobjects):
        if self in mobjects:
            raise Exception(&#34;Mobject cannot contain self&#34;)
        self.submobjects = list_update(self.submobjects, mobjects)
        return self

    def add_to_back(self, *mobjects):
        self.remove(*mobjects)
        self.submobjects = list(mobjects) + self.submobjects
        return self

    def remove(self, *mobjects):
        for mobject in mobjects:
            if mobject in self.submobjects:
                self.submobjects.remove(mobject)
        return self

    def get_array_attrs(self):
        return [&#34;points&#34;]

    def digest_mobject_attrs(self):
        &#34;&#34;&#34;
        Ensures all attributes which are mobjects are included
        in the submobjects list.
        &#34;&#34;&#34;
        mobject_attrs = [x for x in list(self.__dict__.values()) if isinstance(x, Mobject)]
        self.submobjects = list_update(self.submobjects, mobject_attrs)
        return self

    def apply_over_attr_arrays(self, func):
        for attr in self.get_array_attrs():
            setattr(self, attr, func(getattr(self, attr)))
        return self

    # Displaying

    def get_image(self, camera=None):
        if camera is None:
            from manimlib.camera.camera import Camera
            camera = Camera()
        camera.capture_mobject(self)
        return camera.get_image()

    def show(self, camera=None):
        self.get_image(camera=camera).show()

    def save_image(self, name=None):
        self.get_image().save(
            os.path.join(consts.VIDEO_DIR, (name or str(self)) + &#34;.png&#34;)
        )

    def copy(self):
        # TODO, either justify reason for shallow copy, or
        # remove this redundancy everywhere
        # return self.deepcopy()

        copy_mobject = copy.copy(self)
        copy_mobject.points = np.array(self.points)
        copy_mobject.submobjects = [
            submob.copy() for submob in self.submobjects
        ]
        copy_mobject.updaters = list(self.updaters)
        family = self.get_family()
        for attr, value in list(self.__dict__.items()):
            if isinstance(value, Mobject) and value in family and value is not self:
                setattr(copy_mobject, attr, value.copy())
            if isinstance(value, np.ndarray):
                setattr(copy_mobject, attr, np.array(value))
        return copy_mobject

    def deepcopy(self):
        return copy.deepcopy(self)

    def generate_target(self, use_deepcopy=False):
        self.target = None  # Prevent exponential explosion
        if use_deepcopy:
            self.target = self.deepcopy()
        else:
            self.target = self.copy()
        return self.target

    # Updating

    def update(self, dt=0, recursive=True):
        if self.updating_suspended:
            return self
        for updater in self.updaters:
            parameters = get_parameters(updater)
            if &#34;dt&#34; in parameters:
                updater(self, dt)
            else:
                updater(self)
        if recursive:
            for submob in self.submobjects:
                submob.update(dt, recursive)
        return self

    def get_time_based_updaters(self):
        return [
            updater for updater in self.updaters
            if &#34;dt&#34; in get_parameters(updater)
        ]

    def has_time_based_updater(self):
        for updater in self.updaters:
            if &#34;dt&#34; in get_parameters(updater):
                return True
        return False

    def get_updaters(self):
        return self.updaters

    def get_family_updaters(self):
        return list(it.chain(*[
            sm.get_updaters()
            for sm in self.get_family()
        ]))

    def add_updater(self, update_function, index=None, call_updater=True):
        if index is None:
            self.updaters.append(update_function)
        else:
            self.updaters.insert(index, update_function)
        if call_updater:
            self.update(0)
        return self

    def remove_updater(self, update_function):
        while update_function in self.updaters:
            self.updaters.remove(update_function)
        return self

    def clear_updaters(self, recursive=True):
        self.updaters = []
        if recursive:
            for submob in self.submobjects:
                submob.clear_updaters()
        return self

    def match_updaters(self, mobject):
        self.clear_updaters()
        for updater in mobject.get_updaters():
            self.add_updater(updater)
        return self

    def suspend_updating(self, recursive=True):
        self.updating_suspended = True
        if recursive:
            for submob in self.submobjects:
                submob.suspend_updating(recursive)
        return self

    def resume_updating(self, recursive=True):
        self.updating_suspended = False
        if recursive:
            for submob in self.submobjects:
                submob.resume_updating(recursive)
        self.update(dt=0, recursive=recursive)
        return self

    # Transforming operations

    def apply_to_family(self, func):
        for mob in self.family_members_with_points():
            func(mob)

    def shift(self, *vectors):
        total_vector = reduce(op.add, vectors)
        for mob in self.family_members_with_points():
            mob.points = mob.points.astype(&#39;float&#39;)
            mob.points += total_vector
        return self

    def scale(self, scale_factor, **kwargs):
        &#34;&#34;&#34;
        Default behavior is to scale about the center of the mobject.
        The argument about_edge can be a vector, indicating which side of
        the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)
        scales about mob.get_right().

        Otherwise, if about_point is given a value, scaling is done with
        respect to that point.
        &#34;&#34;&#34;
        self.apply_points_function_about_point(
            lambda points: scale_factor * points, **kwargs
        )
        return self

    def rotate_about_origin(self, angle, axis=OUT, axes=[]):
        return self.rotate(angle, axis, about_point=ORIGIN)

    def rotate(self, angle, axis=OUT, **kwargs):
        rot_matrix = rotation_matrix(angle, axis)
        self.apply_points_function_about_point(
            lambda points: np.dot(points, rot_matrix.T),
            **kwargs
        )
        return self

    def flip(self, axis=UP, **kwargs):
        return self.rotate(TAU / 2, axis, **kwargs)

    def stretch(self, factor, dim, **kwargs):
        def func(points):
            points[:, dim] *= factor
            return points
        self.apply_points_function_about_point(func, **kwargs)
        return self

    def apply_function(self, function, **kwargs):
        # Default to applying matrix about the origin, not mobjects center
        if len(kwargs) == 0:
            kwargs[&#34;about_point&#34;] = ORIGIN
        self.apply_points_function_about_point(
            lambda points: np.apply_along_axis(function, 1, points),
            **kwargs
        )
        return self

    def apply_function_to_position(self, function):
        self.move_to(function(self.get_center()))
        return self

    def apply_function_to_submobject_positions(self, function):
        for submob in self.submobjects:
            submob.apply_function_to_position(function)
        return self

    def apply_matrix(self, matrix, **kwargs):
        # Default to applying matrix about the origin, not mobjects center
        if (&#34;about_point&#34; not in kwargs) and (&#34;about_edge&#34; not in kwargs):
            kwargs[&#34;about_point&#34;] = ORIGIN
        full_matrix = np.identity(self.dim)
        matrix = np.array(matrix)
        full_matrix[:matrix.shape[0], :matrix.shape[1]] = matrix
        self.apply_points_function_about_point(
            lambda points: np.dot(points, full_matrix.T),
            **kwargs
        )
        return self

    def apply_complex_function(self, function, **kwargs):
        def R3_func(point):
            x, y, z = point
            xy_complex = function(complex(x, y))
            return [
                xy_complex.real,
                xy_complex.imag,
                z
            ]
        return self.apply_function(R3_func)

    def wag(self, direction=RIGHT, axis=DOWN, wag_factor=1.0):
        for mob in self.family_members_with_points():
            alphas = np.dot(mob.points, np.transpose(axis))
            alphas -= min(alphas)
            alphas /= max(alphas)
            alphas = alphas**wag_factor
            mob.points += np.dot(
                alphas.reshape((len(alphas), 1)),
                np.array(direction).reshape((1, mob.dim))
            )
        return self

    def reverse_points(self):
        for mob in self.family_members_with_points():
            mob.apply_over_attr_arrays(
                lambda arr: np.array(list(reversed(arr)))
            )
        return self

    def repeat(self, count):
        &#34;&#34;&#34;
        This can make transition animations nicer
        &#34;&#34;&#34;
        def repeat_array(array):
            return reduce(
                lambda a1, a2: np.append(a1, a2, axis=0),
                [array] * count
            )
        for mob in self.family_members_with_points():
            mob.apply_over_attr_arrays(repeat_array)
        return self

    # In place operations.
    # Note, much of these are now redundant with default behavior of
    # above methods

    def apply_points_function_about_point(self, func, about_point=None, about_edge=None):
        if about_point is None:
            if about_edge is None:
                about_edge = ORIGIN
            about_point = self.get_critical_point(about_edge)
        for mob in self.family_members_with_points():
            mob.points -= about_point
            mob.points = func(mob.points)
            mob.points += about_point
        return self

    def rotate_in_place(self, angle, axis=OUT):
        # redundant with default behavior of rotate now.
        return self.rotate(angle, axis=axis)

    def scale_in_place(self, scale_factor, **kwargs):
        # Redundant with default behavior of scale now.
        return self.scale(scale_factor, **kwargs)

    def scale_about_point(self, scale_factor, point):
        # Redundant with default behavior of scale now.
        return self.scale(scale_factor, about_point=point)

    def pose_at_angle(self, **kwargs):
        self.rotate(TAU / 14, RIGHT + UP, **kwargs)
        return self

    # Positioning methods

    def center(self):
        self.shift(-self.get_center())
        return self

    def align_on_border(self, direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
        &#34;&#34;&#34;
        Direction just needs to be a vector pointing towards side or
        corner in the 2d plane.
        &#34;&#34;&#34;
        target_point = np.sign(direction) * (FRAME_X_RADIUS, FRAME_Y_RADIUS, 0)
        point_to_align = self.get_critical_point(direction)
        shift_val = target_point - point_to_align - buff * np.array(direction)
        shift_val = shift_val * abs(np.sign(direction))
        self.shift(shift_val)
        return self

    def to_corner(self, corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
        return self.align_on_border(corner, buff)

    def to_edge(self, edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
        return self.align_on_border(edge, buff)

    def next_to(self, mobject_or_point,
                direction=RIGHT,
                buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
                aligned_edge=ORIGIN,
                submobject_to_align=None,
                index_of_submobject_to_align=None,
                coor_mask=np.array([1, 1, 1]),
                ):
        if isinstance(mobject_or_point, Mobject):
            mob = mobject_or_point
            if index_of_submobject_to_align is not None:
                target_aligner = mob[index_of_submobject_to_align]
            else:
                target_aligner = mob
            target_point = target_aligner.get_critical_point(
                aligned_edge + direction
            )
        else:
            target_point = mobject_or_point
        if submobject_to_align is not None:
            aligner = submobject_to_align
        elif index_of_submobject_to_align is not None:
            aligner = self[index_of_submobject_to_align]
        else:
            aligner = self
        point_to_align = aligner.get_critical_point(aligned_edge - direction)
        self.shift((target_point - point_to_align +
                    buff * direction) * coor_mask)
        return self

    def shift_onto_screen(self, **kwargs):
        space_lengths = [FRAME_X_RADIUS, FRAME_Y_RADIUS]
        for vect in UP, DOWN, LEFT, RIGHT:
            dim = np.argmax(np.abs(vect))
            buff = kwargs.get(&#34;buff&#34;, DEFAULT_MOBJECT_TO_EDGE_BUFFER)
            max_val = space_lengths[dim] - buff
            edge_center = self.get_edge_center(vect)
            if np.dot(edge_center, vect) &gt; max_val:
                self.to_edge(vect, **kwargs)
        return self

    def is_off_screen(self):
        if self.get_left()[0] &gt; FRAME_X_RADIUS:
            return True
        if self.get_right()[0] &lt; -FRAME_X_RADIUS:
            return True
        if self.get_bottom()[1] &gt; FRAME_Y_RADIUS:
            return True
        if self.get_top()[1] &lt; -FRAME_Y_RADIUS:
            return True
        return False

    def stretch_about_point(self, factor, dim, point):
        return self.stretch(factor, dim, about_point=point)

    def stretch_in_place(self, factor, dim):
        # Now redundant with stretch
        return self.stretch(factor, dim)

    def rescale_to_fit(self, length, dim, stretch=False, **kwargs):
        old_length = self.length_over_dim(dim)
        if old_length == 0:
            return self
        if stretch:
            self.stretch(length / old_length, dim, **kwargs)
        else:
            self.scale(length / old_length, **kwargs)
        return self

    def stretch_to_fit_width(self, width, **kwargs):
        return self.rescale_to_fit(width, 0, stretch=True, **kwargs)

    def stretch_to_fit_height(self, height, **kwargs):
        return self.rescale_to_fit(height, 1, stretch=True, **kwargs)

    def stretch_to_fit_depth(self, depth, **kwargs):
        return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)

    def set_width(self, width, stretch=False, **kwargs):
        return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)

    def set_height(self, height, stretch=False, **kwargs):
        return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)

    def set_depth(self, depth, stretch=False, **kwargs):
        return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)

    def set_coord(self, value, dim, direction=ORIGIN):
        curr = self.get_coord(dim, direction)
        shift_vect = np.zeros(self.dim)
        shift_vect[dim] = value - curr
        self.shift(shift_vect)
        return self

    def set_x(self, x, direction=ORIGIN):
        return self.set_coord(x, 0, direction)

    def set_y(self, y, direction=ORIGIN):
        return self.set_coord(y, 1, direction)

    def set_z(self, z, direction=ORIGIN):
        return self.set_coord(z, 2, direction)

    def space_out_submobjects(self, factor=1.5, **kwargs):
        self.scale(factor, **kwargs)
        for submob in self.submobjects:
            submob.scale(1. / factor)
        return self

    def move_to(self, point_or_mobject, aligned_edge=ORIGIN,
                coor_mask=np.array([1, 1, 1])):
        if isinstance(point_or_mobject, Mobject):
            target = point_or_mobject.get_critical_point(aligned_edge)
        else:
            target = point_or_mobject
        point_to_align = self.get_critical_point(aligned_edge)
        self.shift((target - point_to_align) * coor_mask)
        return self

    def replace(self, mobject, dim_to_match=0, stretch=False):
        if not mobject.get_num_points() and not mobject.submobjects:
            raise Warning(&#34;Attempting to replace mobject with no points&#34;)
            return self
        if stretch:
            self.stretch_to_fit_width(mobject.get_width())
            self.stretch_to_fit_height(mobject.get_height())
        else:
            self.rescale_to_fit(
                mobject.length_over_dim(dim_to_match),
                dim_to_match,
                stretch=False
            )
        self.shift(mobject.get_center() - self.get_center())
        return self

    def surround(self, mobject,
                 dim_to_match=0,
                 stretch=False,
                 buff=MED_SMALL_BUFF):
        self.replace(mobject, dim_to_match, stretch)
        length = mobject.length_over_dim(dim_to_match)
        self.scale_in_place((length + buff) / length)
        return self

    def put_start_and_end_on(self, start, end):
        curr_start, curr_end = self.get_start_and_end()
        curr_vect = curr_end - curr_start
        if np.all(curr_vect == 0):
            raise Exception(&#34;Cannot position endpoints of closed loop&#34;)
        target_vect = end - start
        self.scale(
            get_norm(target_vect) / get_norm(curr_vect),
            about_point=curr_start,
        )
        self.rotate(
            angle_of_vector(target_vect) -
            angle_of_vector(curr_vect),
            about_point=curr_start
        )
        self.shift(start - curr_start)
        return self

    # Background rectangle
    def add_background_rectangle(self, color=BLACK, opacity=0.75, **kwargs):
        # TODO, this does not behave well when the mobject has points,
        # since it gets displayed on top
        from manimlib.mobject.shape_matchers import BackgroundRectangle
        self.background_rectangle = BackgroundRectangle(
            self, color=color,
            fill_opacity=opacity,
            **kwargs
        )
        self.add_to_back(self.background_rectangle)
        return self

    def add_background_rectangle_to_submobjects(self, **kwargs):
        for submobject in self.submobjects:
            submobject.add_background_rectangle(**kwargs)
        return self

    def add_background_rectangle_to_family_members_with_points(self, **kwargs):
        for mob in self.family_members_with_points():
            mob.add_background_rectangle(**kwargs)
        return self

    # Color functions

    def set_color(self, color=YELLOW_C, family=True):
        &#34;&#34;&#34;
        Condition is function which takes in one arguments, (x, y, z).
        Here it just recurses to submobjects, but in subclasses this
        should be further implemented based on the the inner workings
        of color
        &#34;&#34;&#34;
        if family:
            for submob in self.submobjects:
                submob.set_color(color, family=family)
        self.color = color
        return self

    def set_color_by_gradient(self, *colors):
        self.set_submobject_colors_by_gradient(*colors)
        return self

    def set_colors_by_radial_gradient(self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK):
        self.set_submobject_colors_by_radial_gradient(
            center, radius, inner_color, outer_color)
        return self

    def set_submobject_colors_by_gradient(self, *colors):
        if len(colors) == 0:
            raise Exception(&#34;Need at least one color&#34;)
        elif len(colors) == 1:
            return self.set_color(*colors)

        mobs = self.family_members_with_points()
        new_colors = color_gradient(colors, len(mobs))

        for mob, color in zip(mobs, new_colors):
            mob.set_color(color, family=False)
        return self

    def set_submobject_colors_by_radial_gradient(self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK):
        if center is None:
            center = self.get_center()

        for mob in self.family_members_with_points():
            t = get_norm(mob.get_center() - center) / radius
            t = min(t, 1)
            mob_color = interpolate_color(inner_color, outer_color, t)
            mob.set_color(mob_color, family=False)

        return self

    def to_original_color(self):
        self.set_color(self.color)
        return self

    def fade_to(self, color, alpha, family=True):
        if self.get_num_points() &gt; 0:
            new_color = interpolate_color(
                self.get_color(), color, alpha
            )
            self.set_color(new_color, family=False)
        if family:
            for submob in self.submobjects:
                submob.fade_to(color, alpha)
        return self

    def fade(self, darkness=0.5, family=True):
        if family:
            for submob in self.submobjects:
                submob.fade(darkness, family)
        return self

    def get_color(self):
        return self.color

    ##

    def save_state(self, use_deepcopy=False):
        if hasattr(self, &#34;saved_state&#34;):
            # Prevent exponential growth of data
            self.saved_state = None
        if use_deepcopy:
            self.saved_state = self.deepcopy()
        else:
            self.saved_state = self.copy()
        return self

    def restore(self):
        if not hasattr(self, &#34;saved_state&#34;) or self.save_state is None:
            raise Exception(&#34;Trying to restore without having saved&#34;)
        self.become(self.saved_state)
        return self

    ##

    def reduce_across_dimension(self, points_func, reduce_func, dim):
        points = self.get_all_points()
        if points is None or len(points) == 0:
            # Note, this default means things like empty VGroups
            # will appear to have a center at [0, 0, 0]
            return 0
        values = points_func(points[:, dim])
        return reduce_func(values)

    def nonempty_submobjects(self):
        return [
            submob for submob in self.submobjects
            if len(submob.submobjects) != 0 or len(submob.points) != 0
        ]

    def get_merged_array(self, array_attr):
        result = getattr(self, array_attr)
        for submob in self.submobjects:
            result = np.append(
                result, submob.get_merged_array(array_attr),
                axis=0
            )
            submob.get_merged_array(array_attr)
        return result

    def get_all_points(self):
        return self.get_merged_array(&#34;points&#34;)

    # Getters

    def get_points_defining_boundary(self):
        return self.get_all_points()

    def get_num_points(self):
        return len(self.points)

    def get_extremum_along_dim(self, points=None, dim=0, key=0):
        if points is None:
            points = self.get_points_defining_boundary()
        values = points[:, dim]
        if key &lt; 0:
            return np.min(values)
        elif key == 0:
            return (np.min(values) + np.max(values)) / 2
        else:
            return np.max(values)

    def get_critical_point(self, direction):
        &#34;&#34;&#34;
        Picture a box bounding the mobject.  Such a box has
        9 &#39;critical points&#39;: 4 corners, 4 edge center, the
        center.  This returns one of them.
        &#34;&#34;&#34;
        result = np.zeros(self.dim)
        all_points = self.get_points_defining_boundary()
        if len(all_points) == 0:
            return result
        for dim in range(self.dim):
            result[dim] = self.get_extremum_along_dim(
                all_points, dim=dim, key=direction[dim]
            )
        return result

    # Pseudonyms for more general get_critical_point method

    def get_edge_center(self, direction):
        return self.get_critical_point(direction)

    def get_corner(self, direction):
        return self.get_critical_point(direction)

    def get_center(self):
        return self.get_critical_point(np.zeros(self.dim))

    def get_center_of_mass(self):
        return np.apply_along_axis(np.mean, 0, self.get_all_points())

    def get_boundary_point(self, direction):
        all_points = self.get_points_defining_boundary()
        index = np.argmax(np.dot(all_points, np.array(direction).T))
        return all_points[index]

    def get_top(self):
        return self.get_edge_center(UP)

    def get_bottom(self):
        return self.get_edge_center(DOWN)

    def get_right(self):
        return self.get_edge_center(RIGHT)

    def get_left(self):
        return self.get_edge_center(LEFT)

    def get_zenith(self):
        return self.get_edge_center(OUT)

    def get_nadir(self):
        return self.get_edge_center(IN)

    def length_over_dim(self, dim):
        return (
            self.reduce_across_dimension(np.max, np.max, dim) -
            self.reduce_across_dimension(np.min, np.min, dim)
        )

    def get_width(self):
        return self.length_over_dim(0)

    def get_height(self):
        return self.length_over_dim(1)

    def get_depth(self):
        return self.length_over_dim(2)

    def get_coord(self, dim, direction=ORIGIN):
        &#34;&#34;&#34;
        Meant to generalize get_x, get_y, get_z
        &#34;&#34;&#34;
        return self.get_extremum_along_dim(
            dim=dim, key=direction[dim]
        )

    def get_x(self, direction=ORIGIN):
        return self.get_coord(0, direction)

    def get_y(self, direction=ORIGIN):
        return self.get_coord(1, direction)

    def get_z(self, direction=ORIGIN):
        return self.get_coord(2, direction)

    def get_start(self):
        self.throw_error_if_no_points()
        return np.array(self.points[0])

    def get_end(self):
        self.throw_error_if_no_points()
        return np.array(self.points[-1])

    def get_start_and_end(self):
        return self.get_start(), self.get_end()

    def point_from_proportion(self, alpha):
        raise Exception(&#34;Not implemented&#34;)

    def get_pieces(self, n_pieces):
        template = self.copy()
        template.submobjects = []
        alphas = np.linspace(0, 1, n_pieces + 1)
        return Group(*[
            template.copy().pointwise_become_partial(
                self, a1, a2
            )
            for a1, a2 in zip(alphas[:-1], alphas[1:])
        ])

    def get_z_index_reference_point(self):
        # TODO, better place to define default z_index_group?
        z_index_group = getattr(self, &#34;z_index_group&#34;, self)
        return z_index_group.get_center()

    def has_points(self):
        return len(self.points) &gt; 0

    def has_no_points(self):
        return not self.has_points()

    # Match other mobject properties

    def match_color(self, mobject):
        return self.set_color(mobject.get_color())

    def match_dim_size(self, mobject, dim, **kwargs):
        return self.rescale_to_fit(
            mobject.length_over_dim(dim), dim,
            **kwargs
        )

    def match_width(self, mobject, **kwargs):
        return self.match_dim_size(mobject, 0, **kwargs)

    def match_height(self, mobject, **kwargs):
        return self.match_dim_size(mobject, 1, **kwargs)

    def match_depth(self, mobject, **kwargs):
        return self.match_dim_size(mobject, 2, **kwargs)

    def match_coord(self, mobject, dim, direction=ORIGIN):
        return self.set_coord(
            mobject.get_coord(dim, direction),
            dim=dim,
            direction=direction,
        )

    def match_x(self, mobject, direction=ORIGIN):
        return self.match_coord(mobject, 0, direction)

    def match_y(self, mobject, direction=ORIGIN):
        return self.match_coord(mobject, 1, direction)

    def match_z(self, mobject, direction=ORIGIN):
        return self.match_coord(mobject, 2, direction)

    def align_to(self, mobject_or_point, direction=ORIGIN, alignment_vect=UP):
        &#34;&#34;&#34;
        Examples:
        mob1.align_to(mob2, UP) moves mob1 vertically so that its
        top edge lines ups with mob2&#39;s top edge.

        mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1
        horizontally so that it&#39;s center is directly above/below
        the center of mob2
        &#34;&#34;&#34;
        if isinstance(mobject_or_point, Mobject):
            point = mobject_or_point.get_critical_point(direction)
        else:
            point = mobject_or_point

        for dim in range(self.dim):
            if direction[dim] != 0:
                self.set_coord(point[dim], dim, direction)
        return self

    # Family matters

    def __getitem__(self, value):
        self_list = self.split()
        if isinstance(value, slice):
            GroupClass = self.get_group_class()
            return GroupClass(*self_list.__getitem__(value))
        return self_list.__getitem__(value)

    def __iter__(self):
        return iter(self.split())

    def __len__(self):
        return len(self.split())

    def get_group_class(self):
        return Group

    def split(self):
        result = [self] if len(self.points) &gt; 0 else []
        return result + self.submobjects

    def get_family(self):
        sub_families = list(map(Mobject.get_family, self.submobjects))
        all_mobjects = [self] + list(it.chain(*sub_families))
        return remove_list_redundancies(all_mobjects)

    def family_members_with_points(self):
        return [m for m in self.get_family() if m.get_num_points() &gt; 0]

    def arrange(self, direction=RIGHT, center=True, **kwargs):
        for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
            m2.next_to(m1, direction, **kwargs)
        if center:
            self.center()
        return self

    def arrange_in_grid(self, n_rows=None, n_cols=None, **kwargs):
        submobs = self.submobjects
        if n_rows is None and n_cols is None:
            n_cols = int(np.sqrt(len(submobs)))

        if n_rows is not None:
            v1 = RIGHT
            v2 = DOWN
            n = len(submobs) // n_rows
        elif n_cols is not None:
            v1 = DOWN
            v2 = RIGHT
            n = len(submobs) // n_cols
        Group(*[
            Group(*submobs[i:i + n]).arrange(v1, **kwargs)
            for i in range(0, len(submobs), n)
        ]).arrange(v2, **kwargs)
        return self

    def sort(self, point_to_num_func=lambda p: p[0], submob_func=None):
        if submob_func is None:
            submob_func = lambda m: point_to_num_func(m.get_center())
        self.submobjects.sort(key=submob_func)
        return self

    def shuffle(self, recursive=False):
        if recursive:
            for submob in self.submobjects:
                submob.shuffle(recursive=True)
        random.shuffle(self.submobjects)

    # Just here to keep from breaking old scenes.
    def arrange_submobjects(self, *args, **kwargs):
        return self.arrange(*args, **kwargs)

    def sort_submobjects(self, *args, **kwargs):
        return self.sort(*args, **kwargs)

    def shuffle_submobjects(self, *args, **kwargs):
        return self.shuffle(*args, **kwargs)

    # Alignment
    def align_data(self, mobject):
        self.null_point_align(mobject)
        self.align_submobjects(mobject)
        self.align_points(mobject)
        # Recurse
        for m1, m2 in zip(self.submobjects, mobject.submobjects):
            m1.align_data(m2)

    def get_point_mobject(self, center=None):
        &#34;&#34;&#34;
        The simplest mobject to be transformed to or from self.
        Should by a point of the appropriate type
        &#34;&#34;&#34;
        message = &#34;get_point_mobject not implemented for {}&#34;
        raise Exception(message.format(self.__class__.__name__))

    def align_points(self, mobject):
        count1 = self.get_num_points()
        count2 = mobject.get_num_points()
        if count1 &lt; count2:
            self.align_points_with_larger(mobject)
        elif count2 &lt; count1:
            mobject.align_points_with_larger(self)
        return self

    def align_points_with_larger(self, larger_mobject):
        raise Exception(&#34;Not implemented&#34;)

    def align_submobjects(self, mobject):
        mob1 = self
        mob2 = mobject
        n1 = len(mob1.submobjects)
        n2 = len(mob2.submobjects)
        mob1.add_n_more_submobjects(max(0, n2 - n1))
        mob2.add_n_more_submobjects(max(0, n1 - n2))
        return self

    def null_point_align(self, mobject):
        &#34;&#34;&#34;
        If a mobject with points is being aligned to
        one without, treat both as groups, and push
        the one with points into its own submobjects
        list.
        &#34;&#34;&#34;
        for m1, m2 in (self, mobject), (mobject, self):
            if m1.has_no_points() and m2.has_points():
                m2.push_self_into_submobjects()
        return self

    def push_self_into_submobjects(self):
        copy = self.copy()
        copy.submobjects = []
        self.reset_points()
        self.add(copy)
        return self

    def add_n_more_submobjects(self, n):
        if n == 0:
            return

        curr = len(self.submobjects)
        if curr == 0:
            # If empty, simply add n point mobjects
            self.submobjects = [
                self.get_point_mobject()
                for k in range(n)
            ]
            return

        target = curr + n
        # TODO, factor this out to utils so as to reuse
        # with VMobject.insert_n_curves
        repeat_indices = (np.arange(target) * curr) // target
        split_factors = [
            sum(repeat_indices == i)
            for i in range(curr)
        ]
        new_submobs = []
        for submob, sf in zip(self.submobjects, split_factors):
            new_submobs.append(submob)
            for k in range(1, sf):
                new_submobs.append(
                    submob.copy().fade(1)
                )
        self.submobjects = new_submobs
        return self

    def repeat_submobject(self, submob):
        return submob.copy()

    def interpolate(self, mobject1, mobject2,
                    alpha, path_func=straight_path):
        &#34;&#34;&#34;
        Turns self into an interpolation between mobject1
        and mobject2.
        &#34;&#34;&#34;
        self.points = path_func(
            mobject1.points, mobject2.points, alpha
        )
        self.interpolate_color(mobject1, mobject2, alpha)
        return self

    def interpolate_color(self, mobject1, mobject2, alpha):
        pass  # To implement in subclass

    def become_partial(self, mobject, a, b):
        &#34;&#34;&#34;
        Set points in such a way as to become only
        part of mobject.
        Inputs 0 &lt;= a &lt; b &lt;= 1 determine what portion
        of mobject to become.
        &#34;&#34;&#34;
        pass  # To implement in subclasses

        # TODO, color?

    def pointwise_become_partial(self, mobject, a, b):
        pass  # To implement in subclass

    def become(self, mobject, copy_submobjects=True):
        &#34;&#34;&#34;
        Edit points, colors and submobjects to be idential
        to another mobject
        &#34;&#34;&#34;
        self.align_data(mobject)
        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
            sm1.points = np.array(sm2.points)
            sm1.interpolate_color(sm1, sm2, 1)
        return self

    # Errors
    def throw_error_if_no_points(self):
        if self.has_no_points():
            message = &#34;Cannot call Mobject.{} &#34; +\
                      &#34;for a Mobject with no points&#34;
            caller_name = sys._getframe(1).f_code.co_name
            raise Exception(message.format(caller_name))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.mobject.Group" href="#manimlib.mobject.mobject.Group">Group</a></li>
<li><a title="manimlib.mobject.types.image_mobject.AbstractImageMobject" href="types/image_mobject.html#manimlib.mobject.types.image_mobject.AbstractImageMobject">AbstractImageMobject</a></li>
<li><a title="manimlib.mobject.types.point_cloud_mobject.PMobject" href="types/point_cloud_mobject.html#manimlib.mobject.types.point_cloud_mobject.PMobject">PMobject</a></li>
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.value_tracker.ValueTracker" href="value_tracker.html#manimlib.mobject.value_tracker.ValueTracker">ValueTracker</a></li>
<li><a title="manimlib.once_useful_constructs.region.Region" href="../once_useful_constructs/region.html#manimlib.once_useful_constructs.region.Region">Region</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.mobject.mobject.Mobject.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.mobject.mobject.Mobject.add_background_rectangle"><code class="name flex">
<span>def <span class="ident">add_background_rectangle</span></span>(<span>self, color='#000000', opacity=0.75, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_background_rectangle(self, color=BLACK, opacity=0.75, **kwargs):
    # TODO, this does not behave well when the mobject has points,
    # since it gets displayed on top
    from manimlib.mobject.shape_matchers import BackgroundRectangle
    self.background_rectangle = BackgroundRectangle(
        self, color=color,
        fill_opacity=opacity,
        **kwargs
    )
    self.add_to_back(self.background_rectangle)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.add_background_rectangle_to_family_members_with_points"><code class="name flex">
<span>def <span class="ident">add_background_rectangle_to_family_members_with_points</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_background_rectangle_to_family_members_with_points(self, **kwargs):
    for mob in self.family_members_with_points():
        mob.add_background_rectangle(**kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.add_background_rectangle_to_submobjects"><code class="name flex">
<span>def <span class="ident">add_background_rectangle_to_submobjects</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_background_rectangle_to_submobjects(self, **kwargs):
    for submobject in self.submobjects:
        submobject.add_background_rectangle(**kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.add_n_more_submobjects"><code class="name flex">
<span>def <span class="ident">add_n_more_submobjects</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_n_more_submobjects(self, n):
    if n == 0:
        return

    curr = len(self.submobjects)
    if curr == 0:
        # If empty, simply add n point mobjects
        self.submobjects = [
            self.get_point_mobject()
            for k in range(n)
        ]
        return

    target = curr + n
    # TODO, factor this out to utils so as to reuse
    # with VMobject.insert_n_curves
    repeat_indices = (np.arange(target) * curr) // target
    split_factors = [
        sum(repeat_indices == i)
        for i in range(curr)
    ]
    new_submobs = []
    for submob, sf in zip(self.submobjects, split_factors):
        new_submobs.append(submob)
        for k in range(1, sf):
            new_submobs.append(
                submob.copy().fade(1)
            )
    self.submobjects = new_submobs
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.add_to_back"><code class="name flex">
<span>def <span class="ident">add_to_back</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_back(self, *mobjects):
    self.remove(*mobjects)
    self.submobjects = list(mobjects) + self.submobjects
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.add_updater"><code class="name flex">
<span>def <span class="ident">add_updater</span></span>(<span>self, update_function, index=None, call_updater=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_updater(self, update_function, index=None, call_updater=True):
    if index is None:
        self.updaters.append(update_function)
    else:
        self.updaters.insert(index, update_function)
    if call_updater:
        self.update(0)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.align_data"><code class="name flex">
<span>def <span class="ident">align_data</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_data(self, mobject):
    self.null_point_align(mobject)
    self.align_submobjects(mobject)
    self.align_points(mobject)
    # Recurse
    for m1, m2 in zip(self.submobjects, mobject.submobjects):
        m1.align_data(m2)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.align_on_border"><code class="name flex">
<span>def <span class="ident">align_on_border</span></span>(<span>self, direction, buff=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Direction just needs to be a vector pointing towards side or
corner in the 2d plane.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_on_border(self, direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
    &#34;&#34;&#34;
    Direction just needs to be a vector pointing towards side or
    corner in the 2d plane.
    &#34;&#34;&#34;
    target_point = np.sign(direction) * (FRAME_X_RADIUS, FRAME_Y_RADIUS, 0)
    point_to_align = self.get_critical_point(direction)
    shift_val = target_point - point_to_align - buff * np.array(direction)
    shift_val = shift_val * abs(np.sign(direction))
    self.shift(shift_val)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.align_points"><code class="name flex">
<span>def <span class="ident">align_points</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_points(self, mobject):
    count1 = self.get_num_points()
    count2 = mobject.get_num_points()
    if count1 &lt; count2:
        self.align_points_with_larger(mobject)
    elif count2 &lt; count1:
        mobject.align_points_with_larger(self)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.align_points_with_larger"><code class="name flex">
<span>def <span class="ident">align_points_with_larger</span></span>(<span>self, larger_mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_points_with_larger(self, larger_mobject):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.align_submobjects"><code class="name flex">
<span>def <span class="ident">align_submobjects</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_submobjects(self, mobject):
    mob1 = self
    mob2 = mobject
    n1 = len(mob1.submobjects)
    n2 = len(mob2.submobjects)
    mob1.add_n_more_submobjects(max(0, n2 - n1))
    mob2.add_n_more_submobjects(max(0, n1 - n2))
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.align_to"><code class="name flex">
<span>def <span class="ident">align_to</span></span>(<span>self, mobject_or_point, direction=array([0., 0., 0.]), alignment_vect=array([0., 1., 0.]))</span>
</code></dt>
<dd>
<div class="desc"><p>Examples:
mob1.align_to(mob2, UP) moves mob1 vertically so that its
top edge lines ups with mob2's top edge.</p>
<p>mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1
horizontally so that it's center is directly above/below
the center of mob2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_to(self, mobject_or_point, direction=ORIGIN, alignment_vect=UP):
    &#34;&#34;&#34;
    Examples:
    mob1.align_to(mob2, UP) moves mob1 vertically so that its
    top edge lines ups with mob2&#39;s top edge.

    mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1
    horizontally so that it&#39;s center is directly above/below
    the center of mob2
    &#34;&#34;&#34;
    if isinstance(mobject_or_point, Mobject):
        point = mobject_or_point.get_critical_point(direction)
    else:
        point = mobject_or_point

    for dim in range(self.dim):
        if direction[dim] != 0:
            self.set_coord(point[dim], dim, direction)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_complex_function"><code class="name flex">
<span>def <span class="ident">apply_complex_function</span></span>(<span>self, function, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_complex_function(self, function, **kwargs):
    def R3_func(point):
        x, y, z = point
        xy_complex = function(complex(x, y))
        return [
            xy_complex.real,
            xy_complex.imag,
            z
        ]
    return self.apply_function(R3_func)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_function"><code class="name flex">
<span>def <span class="ident">apply_function</span></span>(<span>self, function, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_function(self, function, **kwargs):
    # Default to applying matrix about the origin, not mobjects center
    if len(kwargs) == 0:
        kwargs[&#34;about_point&#34;] = ORIGIN
    self.apply_points_function_about_point(
        lambda points: np.apply_along_axis(function, 1, points),
        **kwargs
    )
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_function_to_position"><code class="name flex">
<span>def <span class="ident">apply_function_to_position</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_function_to_position(self, function):
    self.move_to(function(self.get_center()))
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_function_to_submobject_positions"><code class="name flex">
<span>def <span class="ident">apply_function_to_submobject_positions</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_function_to_submobject_positions(self, function):
    for submob in self.submobjects:
        submob.apply_function_to_position(function)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_matrix"><code class="name flex">
<span>def <span class="ident">apply_matrix</span></span>(<span>self, matrix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_matrix(self, matrix, **kwargs):
    # Default to applying matrix about the origin, not mobjects center
    if (&#34;about_point&#34; not in kwargs) and (&#34;about_edge&#34; not in kwargs):
        kwargs[&#34;about_point&#34;] = ORIGIN
    full_matrix = np.identity(self.dim)
    matrix = np.array(matrix)
    full_matrix[:matrix.shape[0], :matrix.shape[1]] = matrix
    self.apply_points_function_about_point(
        lambda points: np.dot(points, full_matrix.T),
        **kwargs
    )
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_over_attr_arrays"><code class="name flex">
<span>def <span class="ident">apply_over_attr_arrays</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_over_attr_arrays(self, func):
    for attr in self.get_array_attrs():
        setattr(self, attr, func(getattr(self, attr)))
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_points_function_about_point"><code class="name flex">
<span>def <span class="ident">apply_points_function_about_point</span></span>(<span>self, func, about_point=None, about_edge=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_points_function_about_point(self, func, about_point=None, about_edge=None):
    if about_point is None:
        if about_edge is None:
            about_edge = ORIGIN
        about_point = self.get_critical_point(about_edge)
    for mob in self.family_members_with_points():
        mob.points -= about_point
        mob.points = func(mob.points)
        mob.points += about_point
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.apply_to_family"><code class="name flex">
<span>def <span class="ident">apply_to_family</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_to_family(self, func):
    for mob in self.family_members_with_points():
        func(mob)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.arrange"><code class="name flex">
<span>def <span class="ident">arrange</span></span>(<span>self, direction=array([1., 0., 0.]), center=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrange(self, direction=RIGHT, center=True, **kwargs):
    for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
        m2.next_to(m1, direction, **kwargs)
    if center:
        self.center()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.arrange_in_grid"><code class="name flex">
<span>def <span class="ident">arrange_in_grid</span></span>(<span>self, n_rows=None, n_cols=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrange_in_grid(self, n_rows=None, n_cols=None, **kwargs):
    submobs = self.submobjects
    if n_rows is None and n_cols is None:
        n_cols = int(np.sqrt(len(submobs)))

    if n_rows is not None:
        v1 = RIGHT
        v2 = DOWN
        n = len(submobs) // n_rows
    elif n_cols is not None:
        v1 = DOWN
        v2 = RIGHT
        n = len(submobs) // n_cols
    Group(*[
        Group(*submobs[i:i + n]).arrange(v1, **kwargs)
        for i in range(0, len(submobs), n)
    ]).arrange(v2, **kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.arrange_submobjects"><code class="name flex">
<span>def <span class="ident">arrange_submobjects</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrange_submobjects(self, *args, **kwargs):
    return self.arrange(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.become"><code class="name flex">
<span>def <span class="ident">become</span></span>(<span>self, mobject, copy_submobjects=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Edit points, colors and submobjects to be idential
to another mobject</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def become(self, mobject, copy_submobjects=True):
    &#34;&#34;&#34;
    Edit points, colors and submobjects to be idential
    to another mobject
    &#34;&#34;&#34;
    self.align_data(mobject)
    for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
        sm1.points = np.array(sm2.points)
        sm1.interpolate_color(sm1, sm2, 1)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.become_partial"><code class="name flex">
<span>def <span class="ident">become_partial</span></span>(<span>self, mobject, a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Set points in such a way as to become only
part of mobject.
Inputs 0 &lt;= a &lt; b &lt;= 1 determine what portion
of mobject to become.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def become_partial(self, mobject, a, b):
    &#34;&#34;&#34;
    Set points in such a way as to become only
    part of mobject.
    Inputs 0 &lt;= a &lt; b &lt;= 1 determine what portion
    of mobject to become.
    &#34;&#34;&#34;
    pass  # To implement in subclasses</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self):
    self.shift(-self.get_center())
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.clear_updaters"><code class="name flex">
<span>def <span class="ident">clear_updaters</span></span>(<span>self, recursive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_updaters(self, recursive=True):
    self.updaters = []
    if recursive:
        for submob in self.submobjects:
            submob.clear_updaters()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    # TODO, either justify reason for shallow copy, or
    # remove this redundancy everywhere
    # return self.deepcopy()

    copy_mobject = copy.copy(self)
    copy_mobject.points = np.array(self.points)
    copy_mobject.submobjects = [
        submob.copy() for submob in self.submobjects
    ]
    copy_mobject.updaters = list(self.updaters)
    family = self.get_family()
    for attr, value in list(self.__dict__.items()):
        if isinstance(value, Mobject) and value in family and value is not self:
            setattr(copy_mobject, attr, value.copy())
        if isinstance(value, np.ndarray):
            setattr(copy_mobject, attr, np.array(value))
    return copy_mobject</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcopy(self):
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.digest_mobject_attrs"><code class="name flex">
<span>def <span class="ident">digest_mobject_attrs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures all attributes which are mobjects are included
in the submobjects list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digest_mobject_attrs(self):
    &#34;&#34;&#34;
    Ensures all attributes which are mobjects are included
    in the submobjects list.
    &#34;&#34;&#34;
    mobject_attrs = [x for x in list(self.__dict__.values()) if isinstance(x, Mobject)]
    self.submobjects = list_update(self.submobjects, mobject_attrs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.fade"><code class="name flex">
<span>def <span class="ident">fade</span></span>(<span>self, darkness=0.5, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fade(self, darkness=0.5, family=True):
    if family:
        for submob in self.submobjects:
            submob.fade(darkness, family)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.fade_to"><code class="name flex">
<span>def <span class="ident">fade_to</span></span>(<span>self, color, alpha, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fade_to(self, color, alpha, family=True):
    if self.get_num_points() &gt; 0:
        new_color = interpolate_color(
            self.get_color(), color, alpha
        )
        self.set_color(new_color, family=False)
    if family:
        for submob in self.submobjects:
            submob.fade_to(color, alpha)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.family_members_with_points"><code class="name flex">
<span>def <span class="ident">family_members_with_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def family_members_with_points(self):
    return [m for m in self.get_family() if m.get_num_points() &gt; 0]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>self, axis=array([0., 1., 0.]), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(self, axis=UP, **kwargs):
    return self.rotate(TAU / 2, axis, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.generate_points"><code class="name flex">
<span>def <span class="ident">generate_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_points(self):
    # Typically implemented in subclass, unless purposefully left blank
    pass</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.generate_target"><code class="name flex">
<span>def <span class="ident">generate_target</span></span>(<span>self, use_deepcopy=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_target(self, use_deepcopy=False):
    self.target = None  # Prevent exponential explosion
    if use_deepcopy:
        self.target = self.deepcopy()
    else:
        self.target = self.copy()
    return self.target</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_all_points"><code class="name flex">
<span>def <span class="ident">get_all_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_points(self):
    return self.get_merged_array(&#34;points&#34;)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_array_attrs"><code class="name flex">
<span>def <span class="ident">get_array_attrs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_array_attrs(self):
    return [&#34;points&#34;]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_bottom"><code class="name flex">
<span>def <span class="ident">get_bottom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bottom(self):
    return self.get_edge_center(DOWN)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_boundary_point"><code class="name flex">
<span>def <span class="ident">get_boundary_point</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boundary_point(self, direction):
    all_points = self.get_points_defining_boundary()
    index = np.argmax(np.dot(all_points, np.array(direction).T))
    return all_points[index]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_center"><code class="name flex">
<span>def <span class="ident">get_center</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_center(self):
    return self.get_critical_point(np.zeros(self.dim))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_center_of_mass"><code class="name flex">
<span>def <span class="ident">get_center_of_mass</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_center_of_mass(self):
    return np.apply_along_axis(np.mean, 0, self.get_all_points())</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_color"><code class="name flex">
<span>def <span class="ident">get_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_color(self):
    return self.color</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_coord"><code class="name flex">
<span>def <span class="ident">get_coord</span></span>(<span>self, dim, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"><p>Meant to generalize get_x, get_y, get_z</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord(self, dim, direction=ORIGIN):
    &#34;&#34;&#34;
    Meant to generalize get_x, get_y, get_z
    &#34;&#34;&#34;
    return self.get_extremum_along_dim(
        dim=dim, key=direction[dim]
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_corner"><code class="name flex">
<span>def <span class="ident">get_corner</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_corner(self, direction):
    return self.get_critical_point(direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_critical_point"><code class="name flex">
<span>def <span class="ident">get_critical_point</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Picture a box bounding the mobject.
Such a box has
9 'critical points': 4 corners, 4 edge center, the
center.
This returns one of them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_critical_point(self, direction):
    &#34;&#34;&#34;
    Picture a box bounding the mobject.  Such a box has
    9 &#39;critical points&#39;: 4 corners, 4 edge center, the
    center.  This returns one of them.
    &#34;&#34;&#34;
    result = np.zeros(self.dim)
    all_points = self.get_points_defining_boundary()
    if len(all_points) == 0:
        return result
    for dim in range(self.dim):
        result[dim] = self.get_extremum_along_dim(
            all_points, dim=dim, key=direction[dim]
        )
    return result</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_depth"><code class="name flex">
<span>def <span class="ident">get_depth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_depth(self):
    return self.length_over_dim(2)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_edge_center"><code class="name flex">
<span>def <span class="ident">get_edge_center</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_center(self, direction):
    return self.get_critical_point(direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_end"><code class="name flex">
<span>def <span class="ident">get_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end(self):
    self.throw_error_if_no_points()
    return np.array(self.points[-1])</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_extremum_along_dim"><code class="name flex">
<span>def <span class="ident">get_extremum_along_dim</span></span>(<span>self, points=None, dim=0, key=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extremum_along_dim(self, points=None, dim=0, key=0):
    if points is None:
        points = self.get_points_defining_boundary()
    values = points[:, dim]
    if key &lt; 0:
        return np.min(values)
    elif key == 0:
        return (np.min(values) + np.max(values)) / 2
    else:
        return np.max(values)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_family"><code class="name flex">
<span>def <span class="ident">get_family</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_family(self):
    sub_families = list(map(Mobject.get_family, self.submobjects))
    all_mobjects = [self] + list(it.chain(*sub_families))
    return remove_list_redundancies(all_mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_family_updaters"><code class="name flex">
<span>def <span class="ident">get_family_updaters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_family_updaters(self):
    return list(it.chain(*[
        sm.get_updaters()
        for sm in self.get_family()
    ]))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_group_class"><code class="name flex">
<span>def <span class="ident">get_group_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group_class(self):
    return Group</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_height"><code class="name flex">
<span>def <span class="ident">get_height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_height(self):
    return self.length_over_dim(1)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>self, camera=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image(self, camera=None):
    if camera is None:
        from manimlib.camera.camera import Camera
        camera = Camera()
    camera.capture_mobject(self)
    return camera.get_image()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_left"><code class="name flex">
<span>def <span class="ident">get_left</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_left(self):
    return self.get_edge_center(LEFT)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_merged_array"><code class="name flex">
<span>def <span class="ident">get_merged_array</span></span>(<span>self, array_attr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_merged_array(self, array_attr):
    result = getattr(self, array_attr)
    for submob in self.submobjects:
        result = np.append(
            result, submob.get_merged_array(array_attr),
            axis=0
        )
        submob.get_merged_array(array_attr)
    return result</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_nadir"><code class="name flex">
<span>def <span class="ident">get_nadir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nadir(self):
    return self.get_edge_center(IN)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_num_points"><code class="name flex">
<span>def <span class="ident">get_num_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_points(self):
    return len(self.points)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_pieces"><code class="name flex">
<span>def <span class="ident">get_pieces</span></span>(<span>self, n_pieces)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pieces(self, n_pieces):
    template = self.copy()
    template.submobjects = []
    alphas = np.linspace(0, 1, n_pieces + 1)
    return Group(*[
        template.copy().pointwise_become_partial(
            self, a1, a2
        )
        for a1, a2 in zip(alphas[:-1], alphas[1:])
    ])</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_point_mobject"><code class="name flex">
<span>def <span class="ident">get_point_mobject</span></span>(<span>self, center=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The simplest mobject to be transformed to or from self.
Should by a point of the appropriate type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_point_mobject(self, center=None):
    &#34;&#34;&#34;
    The simplest mobject to be transformed to or from self.
    Should by a point of the appropriate type
    &#34;&#34;&#34;
    message = &#34;get_point_mobject not implemented for {}&#34;
    raise Exception(message.format(self.__class__.__name__))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_points_defining_boundary"><code class="name flex">
<span>def <span class="ident">get_points_defining_boundary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points_defining_boundary(self):
    return self.get_all_points()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_right"><code class="name flex">
<span>def <span class="ident">get_right</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_right(self):
    return self.get_edge_center(RIGHT)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_start"><code class="name flex">
<span>def <span class="ident">get_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start(self):
    self.throw_error_if_no_points()
    return np.array(self.points[0])</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_start_and_end"><code class="name flex">
<span>def <span class="ident">get_start_and_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_and_end(self):
    return self.get_start(), self.get_end()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_time_based_updaters"><code class="name flex">
<span>def <span class="ident">get_time_based_updaters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_based_updaters(self):
    return [
        updater for updater in self.updaters
        if &#34;dt&#34; in get_parameters(updater)
    ]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_top"><code class="name flex">
<span>def <span class="ident">get_top</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_top(self):
    return self.get_edge_center(UP)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_updaters"><code class="name flex">
<span>def <span class="ident">get_updaters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_updaters(self):
    return self.updaters</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_width"><code class="name flex">
<span>def <span class="ident">get_width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width(self):
    return self.length_over_dim(0)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_x"><code class="name flex">
<span>def <span class="ident">get_x</span></span>(<span>self, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x(self, direction=ORIGIN):
    return self.get_coord(0, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self, direction=ORIGIN):
    return self.get_coord(1, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_z"><code class="name flex">
<span>def <span class="ident">get_z</span></span>(<span>self, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_z(self, direction=ORIGIN):
    return self.get_coord(2, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_z_index_reference_point"><code class="name flex">
<span>def <span class="ident">get_z_index_reference_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_z_index_reference_point(self):
    # TODO, better place to define default z_index_group?
    z_index_group = getattr(self, &#34;z_index_group&#34;, self)
    return z_index_group.get_center()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.get_zenith"><code class="name flex">
<span>def <span class="ident">get_zenith</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_zenith(self):
    return self.get_edge_center(OUT)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.has_no_points"><code class="name flex">
<span>def <span class="ident">has_no_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_no_points(self):
    return not self.has_points()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.has_points"><code class="name flex">
<span>def <span class="ident">has_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_points(self):
    return len(self.points) &gt; 0</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.has_time_based_updater"><code class="name flex">
<span>def <span class="ident">has_time_based_updater</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_time_based_updater(self):
    for updater in self.updaters:
        if &#34;dt&#34; in get_parameters(updater):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.init_colors"><code class="name flex">
<span>def <span class="ident">init_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_colors(self):
    # For subclasses
    pass</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, mobject1, mobject2, alpha, path_func=&lt;function straight_path&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns self into an interpolation between mobject1
and mobject2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, mobject1, mobject2,
                alpha, path_func=straight_path):
    &#34;&#34;&#34;
    Turns self into an interpolation between mobject1
    and mobject2.
    &#34;&#34;&#34;
    self.points = path_func(
        mobject1.points, mobject2.points, alpha
    )
    self.interpolate_color(mobject1, mobject2, alpha)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.interpolate_color"><code class="name flex">
<span>def <span class="ident">interpolate_color</span></span>(<span>self, mobject1, mobject2, alpha)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_color(self, mobject1, mobject2, alpha):
    pass  # To implement in subclass</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.is_off_screen"><code class="name flex">
<span>def <span class="ident">is_off_screen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_off_screen(self):
    if self.get_left()[0] &gt; FRAME_X_RADIUS:
        return True
    if self.get_right()[0] &lt; -FRAME_X_RADIUS:
        return True
    if self.get_bottom()[1] &gt; FRAME_Y_RADIUS:
        return True
    if self.get_top()[1] &lt; -FRAME_Y_RADIUS:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.length_over_dim"><code class="name flex">
<span>def <span class="ident">length_over_dim</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length_over_dim(self, dim):
    return (
        self.reduce_across_dimension(np.max, np.max, dim) -
        self.reduce_across_dimension(np.min, np.min, dim)
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_color"><code class="name flex">
<span>def <span class="ident">match_color</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_color(self, mobject):
    return self.set_color(mobject.get_color())</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_coord"><code class="name flex">
<span>def <span class="ident">match_coord</span></span>(<span>self, mobject, dim, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_coord(self, mobject, dim, direction=ORIGIN):
    return self.set_coord(
        mobject.get_coord(dim, direction),
        dim=dim,
        direction=direction,
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_depth"><code class="name flex">
<span>def <span class="ident">match_depth</span></span>(<span>self, mobject, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_depth(self, mobject, **kwargs):
    return self.match_dim_size(mobject, 2, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_dim_size"><code class="name flex">
<span>def <span class="ident">match_dim_size</span></span>(<span>self, mobject, dim, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_dim_size(self, mobject, dim, **kwargs):
    return self.rescale_to_fit(
        mobject.length_over_dim(dim), dim,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_height"><code class="name flex">
<span>def <span class="ident">match_height</span></span>(<span>self, mobject, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_height(self, mobject, **kwargs):
    return self.match_dim_size(mobject, 1, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_updaters"><code class="name flex">
<span>def <span class="ident">match_updaters</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_updaters(self, mobject):
    self.clear_updaters()
    for updater in mobject.get_updaters():
        self.add_updater(updater)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_width"><code class="name flex">
<span>def <span class="ident">match_width</span></span>(<span>self, mobject, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_width(self, mobject, **kwargs):
    return self.match_dim_size(mobject, 0, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_x"><code class="name flex">
<span>def <span class="ident">match_x</span></span>(<span>self, mobject, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_x(self, mobject, direction=ORIGIN):
    return self.match_coord(mobject, 0, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_y"><code class="name flex">
<span>def <span class="ident">match_y</span></span>(<span>self, mobject, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_y(self, mobject, direction=ORIGIN):
    return self.match_coord(mobject, 1, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.match_z"><code class="name flex">
<span>def <span class="ident">match_z</span></span>(<span>self, mobject, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_z(self, mobject, direction=ORIGIN):
    return self.match_coord(mobject, 2, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>self, point_or_mobject, aligned_edge=array([0., 0., 0.]), coor_mask=array([1, 1, 1]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to(self, point_or_mobject, aligned_edge=ORIGIN,
            coor_mask=np.array([1, 1, 1])):
    if isinstance(point_or_mobject, Mobject):
        target = point_or_mobject.get_critical_point(aligned_edge)
    else:
        target = point_or_mobject
    point_to_align = self.get_critical_point(aligned_edge)
    self.shift((target - point_to_align) * coor_mask)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.next_to"><code class="name flex">
<span>def <span class="ident">next_to</span></span>(<span>self, mobject_or_point, direction=array([1., 0., 0.]), buff=0.25, aligned_edge=array([0., 0., 0.]), submobject_to_align=None, index_of_submobject_to_align=None, coor_mask=array([1, 1, 1]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_to(self, mobject_or_point,
            direction=RIGHT,
            buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
            aligned_edge=ORIGIN,
            submobject_to_align=None,
            index_of_submobject_to_align=None,
            coor_mask=np.array([1, 1, 1]),
            ):
    if isinstance(mobject_or_point, Mobject):
        mob = mobject_or_point
        if index_of_submobject_to_align is not None:
            target_aligner = mob[index_of_submobject_to_align]
        else:
            target_aligner = mob
        target_point = target_aligner.get_critical_point(
            aligned_edge + direction
        )
    else:
        target_point = mobject_or_point
    if submobject_to_align is not None:
        aligner = submobject_to_align
    elif index_of_submobject_to_align is not None:
        aligner = self[index_of_submobject_to_align]
    else:
        aligner = self
    point_to_align = aligner.get_critical_point(aligned_edge - direction)
    self.shift((target_point - point_to_align +
                buff * direction) * coor_mask)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.nonempty_submobjects"><code class="name flex">
<span>def <span class="ident">nonempty_submobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nonempty_submobjects(self):
    return [
        submob for submob in self.submobjects
        if len(submob.submobjects) != 0 or len(submob.points) != 0
    ]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.null_point_align"><code class="name flex">
<span>def <span class="ident">null_point_align</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"><p>If a mobject with points is being aligned to
one without, treat both as groups, and push
the one with points into its own submobjects
list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def null_point_align(self, mobject):
    &#34;&#34;&#34;
    If a mobject with points is being aligned to
    one without, treat both as groups, and push
    the one with points into its own submobjects
    list.
    &#34;&#34;&#34;
    for m1, m2 in (self, mobject), (mobject, self):
        if m1.has_no_points() and m2.has_points():
            m2.push_self_into_submobjects()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.point_from_proportion"><code class="name flex">
<span>def <span class="ident">point_from_proportion</span></span>(<span>self, alpha)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_from_proportion(self, alpha):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.pointwise_become_partial"><code class="name flex">
<span>def <span class="ident">pointwise_become_partial</span></span>(<span>self, mobject, a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pointwise_become_partial(self, mobject, a, b):
    pass  # To implement in subclass</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.pose_at_angle"><code class="name flex">
<span>def <span class="ident">pose_at_angle</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pose_at_angle(self, **kwargs):
    self.rotate(TAU / 14, RIGHT + UP, **kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.push_self_into_submobjects"><code class="name flex">
<span>def <span class="ident">push_self_into_submobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_self_into_submobjects(self):
    copy = self.copy()
    copy.submobjects = []
    self.reset_points()
    self.add(copy)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.put_start_and_end_on"><code class="name flex">
<span>def <span class="ident">put_start_and_end_on</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_start_and_end_on(self, start, end):
    curr_start, curr_end = self.get_start_and_end()
    curr_vect = curr_end - curr_start
    if np.all(curr_vect == 0):
        raise Exception(&#34;Cannot position endpoints of closed loop&#34;)
    target_vect = end - start
    self.scale(
        get_norm(target_vect) / get_norm(curr_vect),
        about_point=curr_start,
    )
    self.rotate(
        angle_of_vector(target_vect) -
        angle_of_vector(curr_vect),
        about_point=curr_start
    )
    self.shift(start - curr_start)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.reduce_across_dimension"><code class="name flex">
<span>def <span class="ident">reduce_across_dimension</span></span>(<span>self, points_func, reduce_func, dim)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_across_dimension(self, points_func, reduce_func, dim):
    points = self.get_all_points()
    if points is None or len(points) == 0:
        # Note, this default means things like empty VGroups
        # will appear to have a center at [0, 0, 0]
        return 0
    values = points_func(points[:, dim])
    return reduce_func(values)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.remove_updater"><code class="name flex">
<span>def <span class="ident">remove_updater</span></span>(<span>self, update_function)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_updater(self, update_function):
    while update_function in self.updaters:
        self.updaters.remove(update_function)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>self, count)</span>
</code></dt>
<dd>
<div class="desc"><p>This can make transition animations nicer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(self, count):
    &#34;&#34;&#34;
    This can make transition animations nicer
    &#34;&#34;&#34;
    def repeat_array(array):
        return reduce(
            lambda a1, a2: np.append(a1, a2, axis=0),
            [array] * count
        )
    for mob in self.family_members_with_points():
        mob.apply_over_attr_arrays(repeat_array)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.repeat_submobject"><code class="name flex">
<span>def <span class="ident">repeat_submobject</span></span>(<span>self, submob)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat_submobject(self, submob):
    return submob.copy()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, mobject, dim_to_match=0, stretch=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, mobject, dim_to_match=0, stretch=False):
    if not mobject.get_num_points() and not mobject.submobjects:
        raise Warning(&#34;Attempting to replace mobject with no points&#34;)
        return self
    if stretch:
        self.stretch_to_fit_width(mobject.get_width())
        self.stretch_to_fit_height(mobject.get_height())
    else:
        self.rescale_to_fit(
            mobject.length_over_dim(dim_to_match),
            dim_to_match,
            stretch=False
        )
    self.shift(mobject.get_center() - self.get_center())
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.rescale_to_fit"><code class="name flex">
<span>def <span class="ident">rescale_to_fit</span></span>(<span>self, length, dim, stretch=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rescale_to_fit(self, length, dim, stretch=False, **kwargs):
    old_length = self.length_over_dim(dim)
    if old_length == 0:
        return self
    if stretch:
        self.stretch(length / old_length, dim, **kwargs)
    else:
        self.scale(length / old_length, **kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.reset_points"><code class="name flex">
<span>def <span class="ident">reset_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_points(self):
    self.points = np.zeros((0, self.dim))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.restore"><code class="name flex">
<span>def <span class="ident">restore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore(self):
    if not hasattr(self, &#34;saved_state&#34;) or self.save_state is None:
        raise Exception(&#34;Trying to restore without having saved&#34;)
    self.become(self.saved_state)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.resume_updating"><code class="name flex">
<span>def <span class="ident">resume_updating</span></span>(<span>self, recursive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resume_updating(self, recursive=True):
    self.updating_suspended = False
    if recursive:
        for submob in self.submobjects:
            submob.resume_updating(recursive)
    self.update(dt=0, recursive=recursive)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.reverse_points"><code class="name flex">
<span>def <span class="ident">reverse_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_points(self):
    for mob in self.family_members_with_points():
        mob.apply_over_attr_arrays(
            lambda arr: np.array(list(reversed(arr)))
        )
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle, axis=array([0., 0., 1.]), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, angle, axis=OUT, **kwargs):
    rot_matrix = rotation_matrix(angle, axis)
    self.apply_points_function_about_point(
        lambda points: np.dot(points, rot_matrix.T),
        **kwargs
    )
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.rotate_about_origin"><code class="name flex">
<span>def <span class="ident">rotate_about_origin</span></span>(<span>self, angle, axis=array([0., 0., 1.]), axes=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_about_origin(self, angle, axis=OUT, axes=[]):
    return self.rotate(angle, axis, about_point=ORIGIN)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.rotate_in_place"><code class="name flex">
<span>def <span class="ident">rotate_in_place</span></span>(<span>self, angle, axis=array([0., 0., 1.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_in_place(self, angle, axis=OUT):
    # redundant with default behavior of rotate now.
    return self.rotate(angle, axis=axis)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.save_image"><code class="name flex">
<span>def <span class="ident">save_image</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_image(self, name=None):
    self.get_image().save(
        os.path.join(consts.VIDEO_DIR, (name or str(self)) + &#34;.png&#34;)
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.save_state"><code class="name flex">
<span>def <span class="ident">save_state</span></span>(<span>self, use_deepcopy=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_state(self, use_deepcopy=False):
    if hasattr(self, &#34;saved_state&#34;):
        # Prevent exponential growth of data
        self.saved_state = None
    if use_deepcopy:
        self.saved_state = self.deepcopy()
    else:
        self.saved_state = self.copy()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, scale_factor, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Default behavior is to scale about the center of the mobject.
The argument about_edge can be a vector, indicating which side of
the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)
scales about mob.get_right().</p>
<p>Otherwise, if about_point is given a value, scaling is done with
respect to that point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, scale_factor, **kwargs):
    &#34;&#34;&#34;
    Default behavior is to scale about the center of the mobject.
    The argument about_edge can be a vector, indicating which side of
    the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)
    scales about mob.get_right().

    Otherwise, if about_point is given a value, scaling is done with
    respect to that point.
    &#34;&#34;&#34;
    self.apply_points_function_about_point(
        lambda points: scale_factor * points, **kwargs
    )
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.scale_about_point"><code class="name flex">
<span>def <span class="ident">scale_about_point</span></span>(<span>self, scale_factor, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_about_point(self, scale_factor, point):
    # Redundant with default behavior of scale now.
    return self.scale(scale_factor, about_point=point)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.scale_in_place"><code class="name flex">
<span>def <span class="ident">scale_in_place</span></span>(<span>self, scale_factor, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_in_place(self, scale_factor, **kwargs):
    # Redundant with default behavior of scale now.
    return self.scale(scale_factor, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_color"><code class="name flex">
<span>def <span class="ident">set_color</span></span>(<span>self, color='#FFFF00', family=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Condition is function which takes in one arguments, (x, y, z).
Here it just recurses to submobjects, but in subclasses this
should be further implemented based on the the inner workings
of color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_color(self, color=YELLOW_C, family=True):
    &#34;&#34;&#34;
    Condition is function which takes in one arguments, (x, y, z).
    Here it just recurses to submobjects, but in subclasses this
    should be further implemented based on the the inner workings
    of color
    &#34;&#34;&#34;
    if family:
        for submob in self.submobjects:
            submob.set_color(color, family=family)
    self.color = color
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_color_by_gradient"><code class="name flex">
<span>def <span class="ident">set_color_by_gradient</span></span>(<span>self, *colors)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_color_by_gradient(self, *colors):
    self.set_submobject_colors_by_gradient(*colors)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_colors_by_radial_gradient"><code class="name flex">
<span>def <span class="ident">set_colors_by_radial_gradient</span></span>(<span>self, center=None, radius=1, inner_color='#FFFFFF', outer_color='#000000')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_colors_by_radial_gradient(self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK):
    self.set_submobject_colors_by_radial_gradient(
        center, radius, inner_color, outer_color)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_coord"><code class="name flex">
<span>def <span class="ident">set_coord</span></span>(<span>self, value, dim, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_coord(self, value, dim, direction=ORIGIN):
    curr = self.get_coord(dim, direction)
    shift_vect = np.zeros(self.dim)
    shift_vect[dim] = value - curr
    self.shift(shift_vect)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_depth"><code class="name flex">
<span>def <span class="ident">set_depth</span></span>(<span>self, depth, stretch=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_depth(self, depth, stretch=False, **kwargs):
    return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_height"><code class="name flex">
<span>def <span class="ident">set_height</span></span>(<span>self, height, stretch=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_height(self, height, stretch=False, **kwargs):
    return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_submobject_colors_by_gradient"><code class="name flex">
<span>def <span class="ident">set_submobject_colors_by_gradient</span></span>(<span>self, *colors)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_submobject_colors_by_gradient(self, *colors):
    if len(colors) == 0:
        raise Exception(&#34;Need at least one color&#34;)
    elif len(colors) == 1:
        return self.set_color(*colors)

    mobs = self.family_members_with_points()
    new_colors = color_gradient(colors, len(mobs))

    for mob, color in zip(mobs, new_colors):
        mob.set_color(color, family=False)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_submobject_colors_by_radial_gradient"><code class="name flex">
<span>def <span class="ident">set_submobject_colors_by_radial_gradient</span></span>(<span>self, center=None, radius=1, inner_color='#FFFFFF', outer_color='#000000')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_submobject_colors_by_radial_gradient(self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK):
    if center is None:
        center = self.get_center()

    for mob in self.family_members_with_points():
        t = get_norm(mob.get_center() - center) / radius
        t = min(t, 1)
        mob_color = interpolate_color(inner_color, outer_color, t)
        mob.set_color(mob_color, family=False)

    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_width"><code class="name flex">
<span>def <span class="ident">set_width</span></span>(<span>self, width, stretch=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_width(self, width, stretch=False, **kwargs):
    return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_x"><code class="name flex">
<span>def <span class="ident">set_x</span></span>(<span>self, x, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x(self, x, direction=ORIGIN):
    return self.set_coord(x, 0, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_y"><code class="name flex">
<span>def <span class="ident">set_y</span></span>(<span>self, y, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_y(self, y, direction=ORIGIN):
    return self.set_coord(y, 1, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.set_z"><code class="name flex">
<span>def <span class="ident">set_z</span></span>(<span>self, z, direction=array([0., 0., 0.]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_z(self, z, direction=ORIGIN):
    return self.set_coord(z, 2, direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>self, *vectors)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift(self, *vectors):
    total_vector = reduce(op.add, vectors)
    for mob in self.family_members_with_points():
        mob.points = mob.points.astype(&#39;float&#39;)
        mob.points += total_vector
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.shift_onto_screen"><code class="name flex">
<span>def <span class="ident">shift_onto_screen</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift_onto_screen(self, **kwargs):
    space_lengths = [FRAME_X_RADIUS, FRAME_Y_RADIUS]
    for vect in UP, DOWN, LEFT, RIGHT:
        dim = np.argmax(np.abs(vect))
        buff = kwargs.get(&#34;buff&#34;, DEFAULT_MOBJECT_TO_EDGE_BUFFER)
        max_val = space_lengths[dim] - buff
        edge_center = self.get_edge_center(vect)
        if np.dot(edge_center, vect) &gt; max_val:
            self.to_edge(vect, **kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, camera=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, camera=None):
    self.get_image(camera=camera).show()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.shuffle"><code class="name flex">
<span>def <span class="ident">shuffle</span></span>(<span>self, recursive=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle(self, recursive=False):
    if recursive:
        for submob in self.submobjects:
            submob.shuffle(recursive=True)
    random.shuffle(self.submobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.shuffle_submobjects"><code class="name flex">
<span>def <span class="ident">shuffle_submobjects</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle_submobjects(self, *args, **kwargs):
    return self.shuffle(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, point_to_num_func=&lt;function Mobject.&lt;lambda&gt;&gt;, submob_func=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, point_to_num_func=lambda p: p[0], submob_func=None):
    if submob_func is None:
        submob_func = lambda m: point_to_num_func(m.get_center())
    self.submobjects.sort(key=submob_func)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.sort_submobjects"><code class="name flex">
<span>def <span class="ident">sort_submobjects</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_submobjects(self, *args, **kwargs):
    return self.sort(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.space_out_submobjects"><code class="name flex">
<span>def <span class="ident">space_out_submobjects</span></span>(<span>self, factor=1.5, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def space_out_submobjects(self, factor=1.5, **kwargs):
    self.scale(factor, **kwargs)
    for submob in self.submobjects:
        submob.scale(1. / factor)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self):
    result = [self] if len(self.points) &gt; 0 else []
    return result + self.submobjects</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.stretch"><code class="name flex">
<span>def <span class="ident">stretch</span></span>(<span>self, factor, dim, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stretch(self, factor, dim, **kwargs):
    def func(points):
        points[:, dim] *= factor
        return points
    self.apply_points_function_about_point(func, **kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.stretch_about_point"><code class="name flex">
<span>def <span class="ident">stretch_about_point</span></span>(<span>self, factor, dim, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stretch_about_point(self, factor, dim, point):
    return self.stretch(factor, dim, about_point=point)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.stretch_in_place"><code class="name flex">
<span>def <span class="ident">stretch_in_place</span></span>(<span>self, factor, dim)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stretch_in_place(self, factor, dim):
    # Now redundant with stretch
    return self.stretch(factor, dim)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.stretch_to_fit_depth"><code class="name flex">
<span>def <span class="ident">stretch_to_fit_depth</span></span>(<span>self, depth, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stretch_to_fit_depth(self, depth, **kwargs):
    return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.stretch_to_fit_height"><code class="name flex">
<span>def <span class="ident">stretch_to_fit_height</span></span>(<span>self, height, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stretch_to_fit_height(self, height, **kwargs):
    return self.rescale_to_fit(height, 1, stretch=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.stretch_to_fit_width"><code class="name flex">
<span>def <span class="ident">stretch_to_fit_width</span></span>(<span>self, width, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stretch_to_fit_width(self, width, **kwargs):
    return self.rescale_to_fit(width, 0, stretch=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.surround"><code class="name flex">
<span>def <span class="ident">surround</span></span>(<span>self, mobject, dim_to_match=0, stretch=False, buff=0.25)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surround(self, mobject,
             dim_to_match=0,
             stretch=False,
             buff=MED_SMALL_BUFF):
    self.replace(mobject, dim_to_match, stretch)
    length = mobject.length_over_dim(dim_to_match)
    self.scale_in_place((length + buff) / length)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.suspend_updating"><code class="name flex">
<span>def <span class="ident">suspend_updating</span></span>(<span>self, recursive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suspend_updating(self, recursive=True):
    self.updating_suspended = True
    if recursive:
        for submob in self.submobjects:
            submob.suspend_updating(recursive)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.throw_error_if_no_points"><code class="name flex">
<span>def <span class="ident">throw_error_if_no_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def throw_error_if_no_points(self):
    if self.has_no_points():
        message = &#34;Cannot call Mobject.{} &#34; +\
                  &#34;for a Mobject with no points&#34;
        caller_name = sys._getframe(1).f_code.co_name
        raise Exception(message.format(caller_name))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.to_corner"><code class="name flex">
<span>def <span class="ident">to_corner</span></span>(<span>self, corner=array([-1., -1.,
0.]), buff=0.5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_corner(self, corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
    return self.align_on_border(corner, buff)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.to_edge"><code class="name flex">
<span>def <span class="ident">to_edge</span></span>(<span>self, edge=array([-1.,
0.,
0.]), buff=0.5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_edge(self, edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
    return self.align_on_border(edge, buff)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.to_original_color"><code class="name flex">
<span>def <span class="ident">to_original_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_original_color(self):
    self.set_color(self.color)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, dt=0, recursive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, dt=0, recursive=True):
    if self.updating_suspended:
        return self
    for updater in self.updaters:
        parameters = get_parameters(updater)
        if &#34;dt&#34; in parameters:
            updater(self, dt)
        else:
            updater(self)
    if recursive:
        for submob in self.submobjects:
            submob.update(dt, recursive)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.mobject.Mobject.wag"><code class="name flex">
<span>def <span class="ident">wag</span></span>(<span>self, direction=array([1., 0., 0.]), axis=array([ 0., -1.,
0.]), wag_factor=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wag(self, direction=RIGHT, axis=DOWN, wag_factor=1.0):
    for mob in self.family_members_with_points():
        alphas = np.dot(mob.points, np.transpose(axis))
        alphas -= min(alphas)
        alphas /= max(alphas)
        alphas = alphas**wag_factor
        mob.points += np.dot(
            alphas.reshape((len(alphas), 1)),
            np.array(direction).reshape((1, mob.dim))
        )
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.container.container.Container.add" href="../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.container.container.Container.remove" href="../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.mobject" href="index.html">manimlib.mobject</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.mobject.mobject.Group" href="#manimlib.mobject.mobject.Group">Group</a></code></h4>
</li>
<li>
<h4><code><a title="manimlib.mobject.mobject.Mobject" href="#manimlib.mobject.mobject.Mobject">Mobject</a></code></h4>
<ul class="">
<li><code><a title="manimlib.mobject.mobject.Mobject.CONFIG" href="#manimlib.mobject.mobject.Mobject.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.add_background_rectangle" href="#manimlib.mobject.mobject.Mobject.add_background_rectangle">add_background_rectangle</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.add_background_rectangle_to_family_members_with_points" href="#manimlib.mobject.mobject.Mobject.add_background_rectangle_to_family_members_with_points">add_background_rectangle_to_family_members_with_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.add_background_rectangle_to_submobjects" href="#manimlib.mobject.mobject.Mobject.add_background_rectangle_to_submobjects">add_background_rectangle_to_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.add_n_more_submobjects" href="#manimlib.mobject.mobject.Mobject.add_n_more_submobjects">add_n_more_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.add_to_back" href="#manimlib.mobject.mobject.Mobject.add_to_back">add_to_back</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.add_updater" href="#manimlib.mobject.mobject.Mobject.add_updater">add_updater</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_data" href="#manimlib.mobject.mobject.Mobject.align_data">align_data</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_on_border" href="#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_points" href="#manimlib.mobject.mobject.Mobject.align_points">align_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_points_with_larger" href="#manimlib.mobject.mobject.Mobject.align_points_with_larger">align_points_with_larger</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_submobjects" href="#manimlib.mobject.mobject.Mobject.align_submobjects">align_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_to" href="#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_complex_function" href="#manimlib.mobject.mobject.Mobject.apply_complex_function">apply_complex_function</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_function" href="#manimlib.mobject.mobject.Mobject.apply_function">apply_function</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_function_to_position" href="#manimlib.mobject.mobject.Mobject.apply_function_to_position">apply_function_to_position</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_function_to_submobject_positions" href="#manimlib.mobject.mobject.Mobject.apply_function_to_submobject_positions">apply_function_to_submobject_positions</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_matrix" href="#manimlib.mobject.mobject.Mobject.apply_matrix">apply_matrix</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_over_attr_arrays" href="#manimlib.mobject.mobject.Mobject.apply_over_attr_arrays">apply_over_attr_arrays</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_points_function_about_point" href="#manimlib.mobject.mobject.Mobject.apply_points_function_about_point">apply_points_function_about_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.apply_to_family" href="#manimlib.mobject.mobject.Mobject.apply_to_family">apply_to_family</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.arrange" href="#manimlib.mobject.mobject.Mobject.arrange">arrange</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.arrange_in_grid" href="#manimlib.mobject.mobject.Mobject.arrange_in_grid">arrange_in_grid</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.arrange_submobjects" href="#manimlib.mobject.mobject.Mobject.arrange_submobjects">arrange_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.become" href="#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.become_partial" href="#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.center" href="#manimlib.mobject.mobject.Mobject.center">center</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.clear_updaters" href="#manimlib.mobject.mobject.Mobject.clear_updaters">clear_updaters</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.copy" href="#manimlib.mobject.mobject.Mobject.copy">copy</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.deepcopy" href="#manimlib.mobject.mobject.Mobject.deepcopy">deepcopy</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.digest_mobject_attrs" href="#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.fade" href="#manimlib.mobject.mobject.Mobject.fade">fade</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.fade_to" href="#manimlib.mobject.mobject.Mobject.fade_to">fade_to</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.family_members_with_points" href="#manimlib.mobject.mobject.Mobject.family_members_with_points">family_members_with_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.flip" href="#manimlib.mobject.mobject.Mobject.flip">flip</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.generate_points" href="#manimlib.mobject.mobject.Mobject.generate_points">generate_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.generate_target" href="#manimlib.mobject.mobject.Mobject.generate_target">generate_target</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_all_points" href="#manimlib.mobject.mobject.Mobject.get_all_points">get_all_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_array_attrs" href="#manimlib.mobject.mobject.Mobject.get_array_attrs">get_array_attrs</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_bottom" href="#manimlib.mobject.mobject.Mobject.get_bottom">get_bottom</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_boundary_point" href="#manimlib.mobject.mobject.Mobject.get_boundary_point">get_boundary_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_center" href="#manimlib.mobject.mobject.Mobject.get_center">get_center</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_center_of_mass" href="#manimlib.mobject.mobject.Mobject.get_center_of_mass">get_center_of_mass</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_color" href="#manimlib.mobject.mobject.Mobject.get_color">get_color</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_coord" href="#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_corner" href="#manimlib.mobject.mobject.Mobject.get_corner">get_corner</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_critical_point" href="#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_depth" href="#manimlib.mobject.mobject.Mobject.get_depth">get_depth</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_edge_center" href="#manimlib.mobject.mobject.Mobject.get_edge_center">get_edge_center</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_end" href="#manimlib.mobject.mobject.Mobject.get_end">get_end</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_extremum_along_dim" href="#manimlib.mobject.mobject.Mobject.get_extremum_along_dim">get_extremum_along_dim</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_family" href="#manimlib.mobject.mobject.Mobject.get_family">get_family</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_family_updaters" href="#manimlib.mobject.mobject.Mobject.get_family_updaters">get_family_updaters</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_group_class" href="#manimlib.mobject.mobject.Mobject.get_group_class">get_group_class</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_height" href="#manimlib.mobject.mobject.Mobject.get_height">get_height</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_image" href="#manimlib.mobject.mobject.Mobject.get_image">get_image</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_left" href="#manimlib.mobject.mobject.Mobject.get_left">get_left</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_merged_array" href="#manimlib.mobject.mobject.Mobject.get_merged_array">get_merged_array</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_nadir" href="#manimlib.mobject.mobject.Mobject.get_nadir">get_nadir</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_num_points" href="#manimlib.mobject.mobject.Mobject.get_num_points">get_num_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_pieces" href="#manimlib.mobject.mobject.Mobject.get_pieces">get_pieces</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_point_mobject" href="#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_points_defining_boundary" href="#manimlib.mobject.mobject.Mobject.get_points_defining_boundary">get_points_defining_boundary</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_right" href="#manimlib.mobject.mobject.Mobject.get_right">get_right</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_start" href="#manimlib.mobject.mobject.Mobject.get_start">get_start</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_start_and_end" href="#manimlib.mobject.mobject.Mobject.get_start_and_end">get_start_and_end</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_time_based_updaters" href="#manimlib.mobject.mobject.Mobject.get_time_based_updaters">get_time_based_updaters</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_top" href="#manimlib.mobject.mobject.Mobject.get_top">get_top</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_updaters" href="#manimlib.mobject.mobject.Mobject.get_updaters">get_updaters</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_width" href="#manimlib.mobject.mobject.Mobject.get_width">get_width</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_x" href="#manimlib.mobject.mobject.Mobject.get_x">get_x</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_y" href="#manimlib.mobject.mobject.Mobject.get_y">get_y</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_z" href="#manimlib.mobject.mobject.Mobject.get_z">get_z</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_z_index_reference_point" href="#manimlib.mobject.mobject.Mobject.get_z_index_reference_point">get_z_index_reference_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_zenith" href="#manimlib.mobject.mobject.Mobject.get_zenith">get_zenith</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.has_no_points" href="#manimlib.mobject.mobject.Mobject.has_no_points">has_no_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.has_points" href="#manimlib.mobject.mobject.Mobject.has_points">has_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.has_time_based_updater" href="#manimlib.mobject.mobject.Mobject.has_time_based_updater">has_time_based_updater</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.init_colors" href="#manimlib.mobject.mobject.Mobject.init_colors">init_colors</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.interpolate" href="#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.interpolate_color" href="#manimlib.mobject.mobject.Mobject.interpolate_color">interpolate_color</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.is_off_screen" href="#manimlib.mobject.mobject.Mobject.is_off_screen">is_off_screen</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.length_over_dim" href="#manimlib.mobject.mobject.Mobject.length_over_dim">length_over_dim</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_color" href="#manimlib.mobject.mobject.Mobject.match_color">match_color</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_coord" href="#manimlib.mobject.mobject.Mobject.match_coord">match_coord</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_depth" href="#manimlib.mobject.mobject.Mobject.match_depth">match_depth</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_dim_size" href="#manimlib.mobject.mobject.Mobject.match_dim_size">match_dim_size</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_height" href="#manimlib.mobject.mobject.Mobject.match_height">match_height</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_updaters" href="#manimlib.mobject.mobject.Mobject.match_updaters">match_updaters</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_width" href="#manimlib.mobject.mobject.Mobject.match_width">match_width</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_x" href="#manimlib.mobject.mobject.Mobject.match_x">match_x</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_y" href="#manimlib.mobject.mobject.Mobject.match_y">match_y</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.match_z" href="#manimlib.mobject.mobject.Mobject.match_z">match_z</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.move_to" href="#manimlib.mobject.mobject.Mobject.move_to">move_to</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.next_to" href="#manimlib.mobject.mobject.Mobject.next_to">next_to</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.nonempty_submobjects" href="#manimlib.mobject.mobject.Mobject.nonempty_submobjects">nonempty_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.null_point_align" href="#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.point_from_proportion" href="#manimlib.mobject.mobject.Mobject.point_from_proportion">point_from_proportion</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.pointwise_become_partial" href="#manimlib.mobject.mobject.Mobject.pointwise_become_partial">pointwise_become_partial</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.pose_at_angle" href="#manimlib.mobject.mobject.Mobject.pose_at_angle">pose_at_angle</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.push_self_into_submobjects" href="#manimlib.mobject.mobject.Mobject.push_self_into_submobjects">push_self_into_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.put_start_and_end_on" href="#manimlib.mobject.mobject.Mobject.put_start_and_end_on">put_start_and_end_on</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.reduce_across_dimension" href="#manimlib.mobject.mobject.Mobject.reduce_across_dimension">reduce_across_dimension</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.remove_updater" href="#manimlib.mobject.mobject.Mobject.remove_updater">remove_updater</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.repeat" href="#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.repeat_submobject" href="#manimlib.mobject.mobject.Mobject.repeat_submobject">repeat_submobject</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.replace" href="#manimlib.mobject.mobject.Mobject.replace">replace</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.rescale_to_fit" href="#manimlib.mobject.mobject.Mobject.rescale_to_fit">rescale_to_fit</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.reset_points" href="#manimlib.mobject.mobject.Mobject.reset_points">reset_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.restore" href="#manimlib.mobject.mobject.Mobject.restore">restore</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.resume_updating" href="#manimlib.mobject.mobject.Mobject.resume_updating">resume_updating</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.reverse_points" href="#manimlib.mobject.mobject.Mobject.reverse_points">reverse_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.rotate" href="#manimlib.mobject.mobject.Mobject.rotate">rotate</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.rotate_about_origin" href="#manimlib.mobject.mobject.Mobject.rotate_about_origin">rotate_about_origin</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.rotate_in_place" href="#manimlib.mobject.mobject.Mobject.rotate_in_place">rotate_in_place</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.save_image" href="#manimlib.mobject.mobject.Mobject.save_image">save_image</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.save_state" href="#manimlib.mobject.mobject.Mobject.save_state">save_state</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.scale" href="#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.scale_about_point" href="#manimlib.mobject.mobject.Mobject.scale_about_point">scale_about_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.scale_in_place" href="#manimlib.mobject.mobject.Mobject.scale_in_place">scale_in_place</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_color" href="#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_color_by_gradient" href="#manimlib.mobject.mobject.Mobject.set_color_by_gradient">set_color_by_gradient</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_colors_by_radial_gradient" href="#manimlib.mobject.mobject.Mobject.set_colors_by_radial_gradient">set_colors_by_radial_gradient</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_coord" href="#manimlib.mobject.mobject.Mobject.set_coord">set_coord</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_depth" href="#manimlib.mobject.mobject.Mobject.set_depth">set_depth</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_height" href="#manimlib.mobject.mobject.Mobject.set_height">set_height</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_submobject_colors_by_gradient" href="#manimlib.mobject.mobject.Mobject.set_submobject_colors_by_gradient">set_submobject_colors_by_gradient</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_submobject_colors_by_radial_gradient" href="#manimlib.mobject.mobject.Mobject.set_submobject_colors_by_radial_gradient">set_submobject_colors_by_radial_gradient</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_width" href="#manimlib.mobject.mobject.Mobject.set_width">set_width</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_x" href="#manimlib.mobject.mobject.Mobject.set_x">set_x</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_y" href="#manimlib.mobject.mobject.Mobject.set_y">set_y</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_z" href="#manimlib.mobject.mobject.Mobject.set_z">set_z</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.shift" href="#manimlib.mobject.mobject.Mobject.shift">shift</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.shift_onto_screen" href="#manimlib.mobject.mobject.Mobject.shift_onto_screen">shift_onto_screen</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.show" href="#manimlib.mobject.mobject.Mobject.show">show</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.shuffle" href="#manimlib.mobject.mobject.Mobject.shuffle">shuffle</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.shuffle_submobjects" href="#manimlib.mobject.mobject.Mobject.shuffle_submobjects">shuffle_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.sort" href="#manimlib.mobject.mobject.Mobject.sort">sort</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.sort_submobjects" href="#manimlib.mobject.mobject.Mobject.sort_submobjects">sort_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.space_out_submobjects" href="#manimlib.mobject.mobject.Mobject.space_out_submobjects">space_out_submobjects</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.split" href="#manimlib.mobject.mobject.Mobject.split">split</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.stretch" href="#manimlib.mobject.mobject.Mobject.stretch">stretch</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.stretch_about_point" href="#manimlib.mobject.mobject.Mobject.stretch_about_point">stretch_about_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.stretch_in_place" href="#manimlib.mobject.mobject.Mobject.stretch_in_place">stretch_in_place</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.stretch_to_fit_depth" href="#manimlib.mobject.mobject.Mobject.stretch_to_fit_depth">stretch_to_fit_depth</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.stretch_to_fit_height" href="#manimlib.mobject.mobject.Mobject.stretch_to_fit_height">stretch_to_fit_height</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.stretch_to_fit_width" href="#manimlib.mobject.mobject.Mobject.stretch_to_fit_width">stretch_to_fit_width</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.surround" href="#manimlib.mobject.mobject.Mobject.surround">surround</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.suspend_updating" href="#manimlib.mobject.mobject.Mobject.suspend_updating">suspend_updating</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.throw_error_if_no_points" href="#manimlib.mobject.mobject.Mobject.throw_error_if_no_points">throw_error_if_no_points</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.to_corner" href="#manimlib.mobject.mobject.Mobject.to_corner">to_corner</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.to_edge" href="#manimlib.mobject.mobject.Mobject.to_edge">to_edge</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.to_original_color" href="#manimlib.mobject.mobject.Mobject.to_original_color">to_original_color</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.update" href="#manimlib.mobject.mobject.Mobject.update">update</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.wag" href="#manimlib.mobject.mobject.Mobject.wag">wag</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>