<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.mobject.types.vectorized_mobject API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.mobject.types.vectorized_mobject</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools as it
import sys

from colour import Color

from manimlib.constants import *
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.three_d_utils import get_3d_vmob_gradient_start_and_end_points
from manimlib.utils.bezier import bezier
from manimlib.utils.bezier import get_smooth_handle_points
from manimlib.utils.bezier import interpolate
from manimlib.utils.bezier import integer_interpolate
from manimlib.utils.bezier import partial_bezier_points
from manimlib.utils.color import color_to_rgba
from manimlib.utils.iterables import make_even
from manimlib.utils.iterables import stretch_array_to_length
from manimlib.utils.iterables import tuplify
from manimlib.utils.simple_functions import clip_in_place
from manimlib.utils.space_ops import rotate_vector
from manimlib.utils.space_ops import get_norm

# TODO
# - Change cubic curve groups to have 4 points instead of 3
# - Change sub_path idea accordingly
# - No more mark_paths_closed, instead have the camera test
#   if last point in close to first point
# - Think about length of self.points.  Always 0 or 1 mod 4?
#   That&#39;s kind of weird.


class VMobject(Mobject):
    CONFIG = {
        &#34;fill_color&#34;: None,
        &#34;fill_opacity&#34;: 0.0,
        &#34;stroke_color&#34;: None,
        &#34;stroke_opacity&#34;: 1.0,
        &#34;stroke_width&#34;: DEFAULT_STROKE_WIDTH,
        # The purpose of background stroke is to have
        # something that won&#39;t overlap the fill, e.g.
        # For text against some textured background
        &#34;background_stroke_color&#34;: &#34;0e0e0e&#34;,
        &#34;background_stroke_opacity&#34;: 1.0,
        &#34;background_stroke_width&#34;: 0,
        # When a color c is set, there will be a second color
        # computed based on interpolating c to WHITE by with
        # sheen_factor, and the display will gradient to this
        # secondary color in the direction of sheen_direction.
        &#34;sheen_factor&#34;: 0.0,
        &#34;sheen_direction&#34;: UL,
        # Indicates that it will not be displayed, but
        # that it should count in parent mobject&#39;s path
        &#34;close_new_points&#34;: False,
        &#34;pre_function_handle_to_anchor_scale_factor&#34;: 0.01,
        &#34;make_smooth_after_applying_functions&#34;: False,
        &#34;background_image_file&#34;: None,
        &#34;shade_in_3d&#34;: False,
        # This is within a pixel
        # TODO, do we care about accounting for
        # varying zoom levels?
        &#34;tolerance_for_point_equality&#34;: 1e-6,
        &#34;n_points_per_cubic_curve&#34;: 4,
    }

    def get_group_class(self):
        return VGroup

    # Colors
    def init_colors(self):
        self.set_fill(
            color=self.fill_color or self.color,
            opacity=self.fill_opacity,
        )
        self.set_stroke(
            color=self.stroke_color or self.color,
            width=self.stroke_width,
            opacity=self.stroke_opacity,
        )
        self.set_background_stroke(
            color=self.background_stroke_color,
            width=self.background_stroke_width,
            opacity=self.background_stroke_opacity,
        )
        self.set_sheen(
            factor=self.sheen_factor,
            direction=self.sheen_direction,
        )
        return self

    def generate_rgbas_array(self, color, opacity):
        &#34;&#34;&#34;
        First arg can be either a color, or a tuple/list of colors.
        Likewise, opacity can either be a float, or a tuple of floats.
        If self.sheen_factor is not zero, and only
        one color was passed in, a second slightly light color
        will automatically be added for the gradient
        &#34;&#34;&#34;
        colors = list(tuplify(color))
        opacities = list(tuplify(opacity))
        rgbas = np.array([
            color_to_rgba(c, o)
            for c, o in zip(*make_even(colors, opacities))
        ])

        sheen_factor = self.get_sheen_factor()
        if sheen_factor != 0 and len(rgbas) == 1:
            light_rgbas = np.array(rgbas)
            light_rgbas[:, :3] += sheen_factor
            clip_in_place(light_rgbas, 0, 1)
            rgbas = np.append(rgbas, light_rgbas, axis=0)
        return rgbas

    def update_rgbas_array(self, array_name, color=None, opacity=None):
        passed_color = color if (color is not None) else BLACK
        passed_opacity = opacity if (opacity is not None) else 0
        rgbas = self.generate_rgbas_array(passed_color, passed_opacity)
        if not hasattr(self, array_name):
            setattr(self, array_name, rgbas)
            return self
        # Match up current rgbas array with the newly calculated
        # one. 99% of the time they&#39;ll be the same.
        curr_rgbas = getattr(self, array_name)
        if len(curr_rgbas) &lt; len(rgbas):
            curr_rgbas = stretch_array_to_length(
                curr_rgbas, len(rgbas)
            )
            setattr(self, array_name, curr_rgbas)
        elif len(rgbas) &lt; len(curr_rgbas):
            rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))
        # Only update rgb if color was not None, and only
        # update alpha channel if opacity was passed in
        if color is not None:
            curr_rgbas[:, :3] = rgbas[:, :3]
        if opacity is not None:
            curr_rgbas[:, 3] = rgbas[:, 3]
        return self

    def set_fill(self, color=None, opacity=None, family=True):
        if family:
            for submobject in self.submobjects:
                submobject.set_fill(color, opacity, family)
        self.update_rgbas_array(&#34;fill_rgbas&#34;, color, opacity)
        return self

    def set_stroke(self, color=None, width=None, opacity=None,
                   background=False, family=True):
        if family:
            for submobject in self.submobjects:
                submobject.set_stroke(
                    color, width, opacity, background, family
                )
        if background:
            array_name = &#34;background_stroke_rgbas&#34;
            width_name = &#34;background_stroke_width&#34;
        else:
            array_name = &#34;stroke_rgbas&#34;
            width_name = &#34;stroke_width&#34;
        self.update_rgbas_array(array_name, color, opacity)
        if width is not None:
            setattr(self, width_name, width)
        return self

    def set_background_stroke(self, **kwargs):
        kwargs[&#34;background&#34;] = True
        self.set_stroke(**kwargs)
        return self

    def set_style(self,
                  fill_color=None,
                  fill_opacity=None,
                  stroke_color=None,
                  stroke_width=None,
                  stroke_opacity=None,
                  background_stroke_color=None,
                  background_stroke_width=None,
                  background_stroke_opacity=None,
                  sheen_factor=None,
                  sheen_direction=None,
                  background_image_file=None,
                  family=True):
        self.set_fill(
            color=fill_color,
            opacity=fill_opacity,
            family=family
        )
        self.set_stroke(
            color=stroke_color,
            width=stroke_width,
            opacity=stroke_opacity,
            family=family,
        )
        self.set_background_stroke(
            color=background_stroke_color,
            width=background_stroke_width,
            opacity=background_stroke_opacity,
            family=family,
        )
        if sheen_factor:
            self.set_sheen(
                factor=sheen_factor,
                direction=sheen_direction,
                family=family,
            )
        if background_image_file:
            self.color_using_background_image(background_image_file)
        return self

    def get_style(self):
        return {
            &#34;fill_color&#34;: self.get_fill_colors(),
            &#34;fill_opacity&#34;: self.get_fill_opacities(),
            &#34;stroke_color&#34;: self.get_stroke_colors(),
            &#34;stroke_width&#34;: self.get_stroke_width(),
            &#34;stroke_opacity&#34;: self.get_stroke_opacity(),
            &#34;background_stroke_color&#34;: self.get_stroke_colors(background=True),
            &#34;background_stroke_width&#34;: self.get_stroke_width(background=True),
            &#34;background_stroke_opacity&#34;: self.get_stroke_opacity(background=True),
            &#34;sheen_factor&#34;: self.get_sheen_factor(),
            &#34;sheen_direction&#34;: self.get_sheen_direction(),
            &#34;background_image_file&#34;: self.get_background_image_file(),
        }

    def match_style(self, vmobject, family=True):
        self.set_style(**vmobject.get_style(), family=False)

        if family:
            # Does its best to match up submobject lists, and
            # match styles accordingly
            submobs1, submobs2 = self.submobjects, vmobject.submobjects
            if len(submobs1) == 0:
                return self
            elif len(submobs2) == 0:
                submobs2 = [vmobject]
            for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
                sm1.match_style(sm2)
        return self

    def set_color(self, color, family=True):
        self.set_fill(color, family=family)
        self.set_stroke(color, family=family)
        return self

    def set_opacity(self, opacity, family=True):
        self.set_fill(opacity=opacity, family=family)
        self.set_stroke(opacity=opacity, family=family)
        self.set_stroke(opacity=opacity, family=family, background=True)
        return self

    def fade(self, darkness=0.5, family=True):
        factor = 1.0 - darkness
        self.set_fill(
            opacity=factor * self.get_fill_opacity(),
            family=False,
        )
        self.set_stroke(
            opacity=factor * self.get_stroke_opacity(),
            family=False,
        )
        self.set_background_stroke(
            opacity=factor * self.get_stroke_opacity(
                background=True
            ),
            family=False,
        )
        super().fade(darkness, family)
        return self

    def get_fill_rgbas(self):
        try:
            return self.fill_rgbas
        except AttributeError:
            return np.zeros((1, 4))

    def get_fill_color(self):
        &#34;&#34;&#34;
        If there are multiple colors (for gradient)
        this returns the first one
        &#34;&#34;&#34;
        return self.get_fill_colors()[0]

    def get_fill_opacity(self):
        &#34;&#34;&#34;
        If there are multiple opacities, this returns the
        first
        &#34;&#34;&#34;
        return self.get_fill_opacities()[0]

    def get_fill_colors(self):
        return [
            Color(rgb=rgba[:3])
            for rgba in self.get_fill_rgbas()
        ]

    def get_fill_opacities(self):
        return self.get_fill_rgbas()[:, 3]

    def get_stroke_rgbas(self, background=False):
        try:
            if background:
                rgbas = self.background_stroke_rgbas
            else:
                rgbas = self.stroke_rgbas
            return rgbas
        except AttributeError:
            return np.zeros((1, 4))

    def get_stroke_color(self, background=False):
        return self.get_stroke_colors(background)[0]

    def get_stroke_width(self, background=False):
        if background:
            width = self.background_stroke_width
        else:
            width = self.stroke_width
        return max(0, width)

    def get_stroke_opacity(self, background=False):
        return self.get_stroke_opacities(background)[0]

    def get_stroke_colors(self, background=False):
        return [
            Color(rgb=rgba[:3])
            for rgba in self.get_stroke_rgbas(background)
        ]

    def get_stroke_opacities(self, background=False):
        return self.get_stroke_rgbas(background)[:, 3]

    def get_color(self):
        if np.all(self.get_fill_opacities() == 0):
            return self.get_stroke_color()
        return self.get_fill_color()

    def set_sheen_direction(self, direction, family=True):
        direction = np.array(direction)
        if family:
            for submob in self.get_family():
                submob.sheen_direction = direction
        else:
            self.sheen_direction = direction
        return self

    def set_sheen(self, factor, direction=None, family=True):
        if family:
            for submob in self.submobjects:
                submob.set_sheen(factor, direction, family)
        self.sheen_factor = factor
        if direction is not None:
            # family set to false because recursion will
            # already be handled above
            self.set_sheen_direction(direction, family=False)
        # Reset color to put sheen_factor into effect
        if factor != 0:
            self.set_stroke(self.get_stroke_color(), family=family)
            self.set_fill(self.get_fill_color(), family=family)
        return self

    def get_sheen_direction(self):
        return np.array(self.sheen_direction)

    def get_sheen_factor(self):
        return self.sheen_factor

    def get_gradient_start_and_end_points(self):
        if self.shade_in_3d:
            return get_3d_vmob_gradient_start_and_end_points(self)
        else:
            direction = self.get_sheen_direction()
            c = self.get_center()
            bases = np.array([
                self.get_edge_center(vect) - c
                for vect in [RIGHT, UP, OUT]
            ]).transpose()
            offset = np.dot(bases, direction)
            return (c - offset, c + offset)

    def color_using_background_image(self, background_image_file):
        self.background_image_file = background_image_file
        self.set_color(WHITE)
        for submob in self.submobjects:
            submob.color_using_background_image(background_image_file)
        return self

    def get_background_image_file(self):
        return self.background_image_file

    def match_background_image_file(self, vmobject):
        self.color_using_background_image(vmobject.get_background_image_file())
        return self

    def set_shade_in_3d(self, value=True, z_index_as_group=False):
        for submob in self.get_family():
            submob.shade_in_3d = value
            if z_index_as_group:
                submob.z_index_group = self
        return self

    # Points
    def set_points(self, points):
        self.points = np.array(points)
        return self

    def get_points(self):
        return np.array(self.points)

    def set_anchors_and_handles(self, anchors1, handles1, handles2, anchors2):
        assert(len(anchors1) == len(handles1) == len(handles2) == len(anchors2))
        nppcc = self.n_points_per_cubic_curve  # 4
        total_len = nppcc * len(anchors1)
        self.points = np.zeros((total_len, self.dim))
        arrays = [anchors1, handles1, handles2, anchors2]
        for index, array in enumerate(arrays):
            self.points[index::nppcc] = array
        return self

    def clear_points(self):
        self.points = np.zeros((0, self.dim))

    def append_points(self, new_points):
        # TODO, check that number new points is a multiple of 4?
        # or else that if len(self.points) % 4 == 1, then
        # len(new_points) % 4 == 3?
        self.points = np.append(self.points, new_points, axis=0)
        return self

    def start_new_path(self, point):
        # TODO, make sure that len(self.points) % 4 == 0?
        self.append_points([point])
        return self

    def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):
        # TODO, check the len(self.points) % 4 == 0?
        self.append_points([anchor1, handle1, handle2, anchor2])

    def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):
        &#34;&#34;&#34;
        Add cubic bezier curve to the path.
        &#34;&#34;&#34;
        self.throw_error_if_no_points()
        new_points = [handle1, handle2, anchor]
        if self.has_new_path_started():
            self.append_points(new_points)
        else:
            self.append_points([self.get_last_point()] + new_points)

    def add_line_to(self, point):
        nppcc = self.n_points_per_cubic_curve
        self.add_cubic_bezier_curve_to(*[
            interpolate(self.get_last_point(), point, a)
            for a in np.linspace(0, 1, nppcc)[1:]
        ])
        return self

    def add_smooth_curve_to(self, *points):
        &#34;&#34;&#34;
        If two points are passed in, the first is intepretted
        as a handle, the second as an anchor
        &#34;&#34;&#34;
        if len(points) == 1:
            handle2 = None
            new_anchor = points[0]
        elif len(points) == 2:
            handle2, new_anchor = points
        else:
            name = sys._getframe(0).f_code.co_name
            raise Exception(&#34;Only call {} with 1 or 2 points&#34;.format(name))

        if self.has_new_path_started():
            self.add_line_to(new_anchor)
        else:
            self.throw_error_if_no_points()
            last_h2, last_a2 = self.points[-2:]
            last_tangent = (last_a2 - last_h2)
            handle1 = last_a2 + last_tangent
            if handle2 is None:
                to_anchor_vect = new_anchor - last_a2
                new_tangent = rotate_vector(
                    last_tangent, PI, axis=to_anchor_vect
                )
                handle2 = new_anchor - new_tangent
            self.append_points([
                last_a2, handle1, handle2, new_anchor
            ])
        return self

    def has_new_path_started(self):
        nppcc = self.n_points_per_cubic_curve  # 4
        return len(self.points) % nppcc == 1

    def get_last_point(self):
        return self.points[-1]

    def is_closed(self):
        return self.consider_points_equals(
            self.points[0], self.points[-1]
        )

    def add_points_as_corners(self, points):
        for point in points:
            self.add_line_to(point)
        return points

    def set_points_as_corners(self, points):
        nppcc = self.n_points_per_cubic_curve
        points = np.array(points)
        self.set_anchors_and_handles(*[
            interpolate(points[:-1], points[1:], a)
            for a in np.linspace(0, 1, nppcc)
        ])
        return self

    def set_points_smoothly(self, points):
        self.set_points_as_corners(points)
        self.make_smooth()
        return self

    def change_anchor_mode(self, mode):
        assert(mode in [&#34;jagged&#34;, &#34;smooth&#34;])
        nppcc = self.n_points_per_cubic_curve
        for submob in self.family_members_with_points():
            subpaths = submob.get_subpaths()
            submob.clear_points()
            for subpath in subpaths:
                anchors = np.append(
                    subpath[::nppcc],
                    subpath[-1:],
                    0
                )
                if mode == &#34;smooth&#34;:
                    h1, h2 = get_smooth_handle_points(anchors)
                elif mode == &#34;jagged&#34;:
                    a1 = anchors[:-1]
                    a2 = anchors[1:]
                    h1 = interpolate(a1, a2, 1.0 / 3)
                    h2 = interpolate(a1, a2, 2.0 / 3)
                new_subpath = np.array(subpath)
                new_subpath[1::nppcc] = h1
                new_subpath[2::nppcc] = h2
                submob.append_points(new_subpath)
        return self

    def make_smooth(self):
        return self.change_anchor_mode(&#34;smooth&#34;)

    def make_jagged(self):
        return self.change_anchor_mode(&#34;jagged&#34;)

    def add_subpath(self, points):
        assert(len(points) % 4 == 0)
        self.points = np.append(self.points, points, axis=0)
        return self

    def append_vectorized_mobject(self, vectorized_mobject):
        new_points = list(vectorized_mobject.points)

        if self.has_new_path_started():
            # Remove last point, which is starting
            # a new path
            self.points = self.points[:-1]
        self.append_points(new_points)

    def apply_function(self, function):
        factor = self.pre_function_handle_to_anchor_scale_factor
        self.scale_handle_to_anchor_distances(factor)
        Mobject.apply_function(self, function)
        self.scale_handle_to_anchor_distances(1. / factor)
        if self.make_smooth_after_applying_functions:
            self.make_smooth()
        return self

    def scale_handle_to_anchor_distances(self, factor):
        &#34;&#34;&#34;
        If the distance between a given handle point H and its associated
        anchor point A is d, then it changes H to be a distances factor*d
        away from A, but so that the line from A to H doesn&#39;t change.
        This is mostly useful in the context of applying a (differentiable)
        function, to preserve tangency properties.  One would pull all the
        handles closer to their anchors, apply the function then push them out
        again.
        &#34;&#34;&#34;
        for submob in self.family_members_with_points():
            if len(submob.points) &lt; self.n_points_per_cubic_curve:
                continue
            a1, h1, h2, a2 = submob.get_anchors_and_handles()
            a1_to_h1 = h1 - a1
            a2_to_h2 = h2 - a2
            new_h1 = a1 + factor * a1_to_h1
            new_h2 = a2 + factor * a2_to_h2
            submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)
        return self

    #
    def consider_points_equals(self, p0, p1):
        return np.allclose(
            p0, p1,
            atol=self.tolerance_for_point_equality
        )

    def consider_points_equals_2d(self, p0, p1):
        &#34;&#34;&#34;
        Determine if two points are close enough to be considered equal.

        This uses the algorithm from np.isclose(), but expanded here for the
        2D point case. NumPy is overkill for such a small question.
        &#34;&#34;&#34;
        rtol = 1.e-5  # default from np.isclose()
        atol = self.tolerance_for_point_equality
        if abs(p0[0] - p1[0]) &gt; atol + rtol * abs(p1[0]):
            return False
        if abs(p0[1] - p1[1]) &gt; atol + rtol * abs(p1[1]):
            return False
        return True

    # Information about line
    def get_cubic_bezier_tuples_from_points(self, points):
        return np.array(list(self.gen_cubic_bezier_tuples_from_points(points)))

    def gen_cubic_bezier_tuples_from_points(self, points):
        &#34;&#34;&#34;
        Get a generator for the cubic bezier tuples of this object.

        Generator to not materialize a list or np.array needlessly.
        &#34;&#34;&#34;
        nppcc = VMobject.CONFIG[&#34;n_points_per_cubic_curve&#34;]
        remainder = len(points) % nppcc
        points = points[:len(points) - remainder]
        return (
            points[i:i + nppcc]
            for i in range(0, len(points), nppcc)
        )

    def get_cubic_bezier_tuples(self):
        return self.get_cubic_bezier_tuples_from_points(
            self.get_points()
        )

    def _gen_subpaths_from_points(self, points, filter_func):
        nppcc = self.n_points_per_cubic_curve
        split_indices = filter(filter_func, range(nppcc, len(points), nppcc))
        split_indices = [0] + list(split_indices) + [len(points)]
        return (
            points[i1:i2]
            for i1, i2 in zip(split_indices, split_indices[1:])
            if (i2 - i1) &gt;= nppcc
        )

    def get_subpaths_from_points(self, points):
        return list(
            self._gen_subpaths_from_points(
                points,
                lambda n: not self.consider_points_equals(
                    points[n - 1], points[n]
                ))
        )

    def gen_subpaths_from_points_2d(self, points):
        return self._gen_subpaths_from_points(
                points,
                lambda n: not self.consider_points_equals_2d(
                    points[n - 1], points[n]
                ))

    def get_subpaths(self):
        return self.get_subpaths_from_points(self.get_points())

    def get_nth_curve_points(self, n):
        assert(n &lt; self.get_num_curves())
        nppcc = self.n_points_per_cubic_curve
        return self.points[nppcc * n:nppcc * (n + 1)]

    def get_nth_curve_function(self, n):
        return bezier(self.get_nth_curve_points(n))

    def get_num_curves(self):
        nppcc = self.n_points_per_cubic_curve
        return len(self.points) // nppcc

    def point_from_proportion(self, alpha):
        num_cubics = self.get_num_curves()
        n, residue = integer_interpolate(0, num_cubics, alpha)
        curve = self.get_nth_curve_function(n)
        return curve(residue)

    def get_anchors_and_handles(self):
        &#34;&#34;&#34;
        returns anchors1, handles1, handles2, anchors2,
        where (anchors1[i], handles1[i], handles2[i], anchors2[i])
        will be four points defining a cubic bezier curve
        for any i in range(0, len(anchors1))
        &#34;&#34;&#34;
        nppcc = self.n_points_per_cubic_curve
        return [
            self.points[i::nppcc]
            for i in range(nppcc)
        ]

    def get_start_anchors(self):
        return self.points[0::self.n_points_per_cubic_curve]

    def get_end_anchors(self):
        nppcc = self.n_points_per_cubic_curve
        return self.points[nppcc - 1::nppcc]

    def get_anchors(self):
        if self.points.shape[0] == 1:
            return self.points
        return np.array(list(it.chain(*zip(
            self.get_start_anchors(),
            self.get_end_anchors(),
        ))))

    def get_points_defining_boundary(self):
        return np.array(list(it.chain(*[
            sm.get_anchors()
            for sm in self.get_family()
        ])))

    def get_arc_length(self, n_sample_points=None):
        if n_sample_points is None:
            n_sample_points = 4 * self.get_num_curves() + 1
        points = np.array([
            self.point_from_proportion(a)
            for a in np.linspace(0, 1, n_sample_points)
        ])
        diffs = points[1:] - points[:-1]
        norms = np.apply_along_axis(get_norm, 1, diffs)
        return np.sum(norms)

    # Alignment
    def align_points(self, vmobject):
        self.align_rgbas(vmobject)
        if self.get_num_points() == vmobject.get_num_points():
            return

        for mob in self, vmobject:
            # If there are no points, add one to
            # whereever the &#34;center&#34; is
            if mob.has_no_points():
                mob.start_new_path(mob.get_center())
            # If there&#39;s only one point, turn it into
            # a null curve
            if mob.has_new_path_started():
                mob.add_line_to(mob.get_last_point())

        # Figure out what the subpaths are, and align
        subpaths1 = self.get_subpaths()
        subpaths2 = vmobject.get_subpaths()
        n_subpaths = max(len(subpaths1), len(subpaths2))
        # Start building new ones
        new_path1 = np.zeros((0, self.dim))
        new_path2 = np.zeros((0, self.dim))

        nppcc = self.n_points_per_cubic_curve

        def get_nth_subpath(path_list, n):
            if n &gt;= len(path_list):
                # Create a null path at the very end
                return [path_list[-1][-1]] * nppcc
            return path_list[n]

        for n in range(n_subpaths):
            sp1 = get_nth_subpath(subpaths1, n)
            sp2 = get_nth_subpath(subpaths2, n)
            diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)
            diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)
            sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
            sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
            new_path1 = np.append(new_path1, sp1, axis=0)
            new_path2 = np.append(new_path2, sp2, axis=0)
        self.set_points(new_path1)
        vmobject.set_points(new_path2)
        return self

    def insert_n_curves(self, n):
        new_path_point = None
        if self.has_new_path_started():
            new_path_point = self.get_last_point()

        new_points = self.insert_n_curves_to_point_list(
            n, self.get_points()
        )
        self.set_points(new_points)

        if new_path_point is not None:
            self.append_points([new_path_point])
        return self

    def insert_n_curves_to_point_list(self, n, points):
        if len(points) == 1:
            nppcc = self.n_points_per_cubic_curve
            return np.repeat(points, nppcc * n, 0)
        bezier_quads = self.get_cubic_bezier_tuples_from_points(points)
        curr_num = len(bezier_quads)
        target_num = curr_num + n
        # This is an array with values ranging from 0
        # up to curr_num,  with repeats such that
        # it&#39;s total length is target_num.  For example,
        # with curr_num = 10, target_num = 15, this would
        # be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]
        repeat_indices = (np.arange(target_num) * curr_num) // target_num

        # If the nth term of this list is k, it means
        # that the nth curve of our path should be split
        # into k pieces.  In the above example, this would
        # be [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]
        split_factors = [
            sum(repeat_indices == i)
            for i in range(curr_num)
        ]
        new_points = np.zeros((0, self.dim))
        for quad, sf in zip(bezier_quads, split_factors):
            # What was once a single cubic curve defined
            # by &#34;quad&#34; will now be broken into sf
            # smaller cubic curves
            alphas = np.linspace(0, 1, sf + 1)
            for a1, a2 in zip(alphas, alphas[1:]):
                new_points = np.append(
                    new_points,
                    partial_bezier_points(quad, a1, a2),
                    axis=0
                )
        return new_points

    def align_rgbas(self, vmobject):
        attrs = [&#34;fill_rgbas&#34;, &#34;stroke_rgbas&#34;, &#34;background_stroke_rgbas&#34;]
        for attr in attrs:
            a1 = getattr(self, attr)
            a2 = getattr(vmobject, attr)
            if len(a1) &gt; len(a2):
                new_a2 = stretch_array_to_length(a2, len(a1))
                setattr(vmobject, attr, new_a2)
            elif len(a2) &gt; len(a1):
                new_a1 = stretch_array_to_length(a1, len(a2))
                setattr(self, attr, new_a1)
        return self

    def get_point_mobject(self, center=None):
        if center is None:
            center = self.get_center()
        point = VectorizedPoint(center)
        point.match_style(self)
        return point

    def interpolate_color(self, mobject1, mobject2, alpha):
        attrs = [
            &#34;fill_rgbas&#34;,
            &#34;stroke_rgbas&#34;,
            &#34;background_stroke_rgbas&#34;,
            &#34;stroke_width&#34;,
            &#34;background_stroke_width&#34;,
            &#34;sheen_direction&#34;,
            &#34;sheen_factor&#34;,
        ]
        for attr in attrs:
            setattr(self, attr, interpolate(
                getattr(mobject1, attr),
                getattr(mobject2, attr),
                alpha
            ))
            if alpha == 1.0:
                setattr(self, attr, getattr(mobject2, attr))

    def pointwise_become_partial(self, vmobject, a, b):
        assert(isinstance(vmobject, VMobject))
        # Partial curve includes three portions:
        # - A middle section, which matches the curve exactly
        # - A start, which is some ending portion of an inner cubic
        # - An end, which is the starting portion of a later inner cubic
        if a &lt;= 0 and b &gt;= 1:
            self.set_points(vmobject.points)
            return self
        bezier_quads = vmobject.get_cubic_bezier_tuples()
        num_cubics = len(bezier_quads)

        lower_index, lower_residue = integer_interpolate(0, num_cubics, a)
        upper_index, upper_residue = integer_interpolate(0, num_cubics, b)

        self.clear_points()
        if num_cubics == 0:
            return self
        if lower_index == upper_index:
            self.append_points(partial_bezier_points(
                bezier_quads[lower_index],
                lower_residue, upper_residue
            ))
        else:
            self.append_points(partial_bezier_points(
                bezier_quads[lower_index], lower_residue, 1
            ))
            for quad in bezier_quads[lower_index + 1:upper_index]:
                self.append_points(quad)
            self.append_points(partial_bezier_points(
                bezier_quads[upper_index], 0, upper_residue
            ))
        return self

    def get_subcurve(self, a, b):
        vmob = self.copy()
        vmob.pointwise_become_partial(self, a, b)
        return vmob


class VGroup(VMobject):
    def __init__(self, *vmobjects, **kwargs):
        if not all([isinstance(m, VMobject) for m in vmobjects]):
            raise Exception(&#34;All submobjects must be of type VMobject&#34;)
        VMobject.__init__(self, **kwargs)
        self.add(*vmobjects)


class VectorizedPoint(VMobject):
    CONFIG = {
        &#34;color&#34;: BLACK,
        &#34;fill_opacity&#34;: 0,
        &#34;stroke_width&#34;: 0,
        &#34;artificial_width&#34;: 0.01,
        &#34;artificial_height&#34;: 0.01,
    }

    def __init__(self, location=ORIGIN, **kwargs):
        VMobject.__init__(self, **kwargs)
        self.set_points(np.array([location]))

    def get_width(self):
        return self.artificial_width

    def get_height(self):
        return self.artificial_height

    def get_location(self):
        return np.array(self.points[0])

    def set_location(self, new_loc):
        self.set_points(np.array([new_loc]))


class CurvesAsSubmobjects(VGroup):
    def __init__(self, vmobject, **kwargs):
        VGroup.__init__(self, **kwargs)
        tuples = vmobject.get_cubic_bezier_tuples()
        for tup in tuples:
            part = VMobject()
            part.set_points(tup)
            part.match_style(vmobject)
            self.add(part)


class DashedVMobject(VMobject):
    CONFIG = {
        &#34;num_dashes&#34;: 15,
        &#34;positive_space_ratio&#34;: 0.5,
        &#34;color&#34;: WHITE
    }

    def __init__(self, vmobject, **kwargs):
        VMobject.__init__(self, **kwargs)
        num_dashes = self.num_dashes
        ps_ratio = self.positive_space_ratio
        if num_dashes &gt; 0:
            # End points of the unit interval for division
            alphas = np.linspace(0, 1, num_dashes + 1)

            # This determines the length of each &#34;dash&#34;
            full_d_alpha = (1.0 / num_dashes)
            partial_d_alpha = full_d_alpha * ps_ratio

            # Rescale so that the last point of vmobject will
            # be the end of the last dash
            alphas /= (1 - full_d_alpha + partial_d_alpha)

            self.add(*[
                vmobject.get_subcurve(alpha, alpha + partial_d_alpha)
                for alpha in alphas[:-1]
            ])
        # Family is already taken care of by get_subcurve
        # implementation
        self.match_style(vmobject, family=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.mobject.types.vectorized_mobject.CurvesAsSubmobjects"><code class="flex name class">
<span>class <span class="ident">CurvesAsSubmobjects</span></span>
<span>(</span><span>vmobject, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurvesAsSubmobjects(VGroup):
    def __init__(self, vmobject, **kwargs):
        VGroup.__init__(self, **kwargs)
        tuples = vmobject.get_cubic_bezier_tuples()
        for tup in tuples:
            part = VMobject()
            part.set_points(tup)
            part.match_style(vmobject)
            self.add(part)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VGroup" href="#manimlib.mobject.types.vectorized_mobject.VGroup">VGroup</a></li>
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VGroup" href="#manimlib.mobject.types.vectorized_mobject.VGroup">VGroup</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.add" href="../../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.add_cubic_bezier_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.add_smooth_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.align_on_border" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.align_to" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.become" href="../mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.become_partial" href="../mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.consider_points_equals_2d" href="#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.digest_mobject_attrs" href="../mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.gen_cubic_bezier_tuples_from_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.generate_rgbas_array" href="#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.get_anchors_and_handles" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.get_coord" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.get_critical_point" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.get_fill_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.get_fill_opacity" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.get_point_mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.interpolate" href="../mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.null_point_align" href="../mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.remove" href="../../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.repeat" href="../mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.scale" href="../mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.scale_handle_to_anchor_distances" href="#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup.set_color" href="../mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.DashedVMobject"><code class="flex name class">
<span>class <span class="ident">DashedVMobject</span></span>
<span>(</span><span>vmobject, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DashedVMobject(VMobject):
    CONFIG = {
        &#34;num_dashes&#34;: 15,
        &#34;positive_space_ratio&#34;: 0.5,
        &#34;color&#34;: WHITE
    }

    def __init__(self, vmobject, **kwargs):
        VMobject.__init__(self, **kwargs)
        num_dashes = self.num_dashes
        ps_ratio = self.positive_space_ratio
        if num_dashes &gt; 0:
            # End points of the unit interval for division
            alphas = np.linspace(0, 1, num_dashes + 1)

            # This determines the length of each &#34;dash&#34;
            full_d_alpha = (1.0 / num_dashes)
            partial_d_alpha = full_d_alpha * ps_ratio

            # Rescale so that the last point of vmobject will
            # be the end of the last dash
            alphas /= (1 - full_d_alpha + partial_d_alpha)

            self.add(*[
                vmobject.get_subcurve(alpha, alpha + partial_d_alpha)
                for alpha in alphas[:-1]
            ])
        # Family is already taken care of by get_subcurve
        # implementation
        self.match_style(vmobject, family=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.mobject.types.vectorized_mobject.DashedVMobject.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VGroup"><code class="flex name class">
<span>class <span class="ident">VGroup</span></span>
<span>(</span><span>*vmobjects, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VGroup(VMobject):
    def __init__(self, *vmobjects, **kwargs):
        if not all([isinstance(m, VMobject) for m in vmobjects]):
            raise Exception(&#34;All submobjects must be of type VMobject&#34;)
        VMobject.__init__(self, **kwargs)
        self.add(*vmobjects)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.camera.moving_camera.CameraFrame" href="../../camera/moving_camera.html#manimlib.camera.moving_camera.CameraFrame">CameraFrame</a></li>
<li><a title="manimlib.for_3b1b_videos.pi_class.PiCreatureClass" href="../../for_3b1b_videos/pi_class.html#manimlib.for_3b1b_videos.pi_class.PiCreatureClass">PiCreatureClass</a></li>
<li><a title="manimlib.mobject.changing.AnimatedBoundary" href="../changing.html#manimlib.mobject.changing.AnimatedBoundary">AnimatedBoundary</a></li>
<li><a title="manimlib.mobject.coordinate_systems.Axes" href="../coordinate_systems.html#manimlib.mobject.coordinate_systems.Axes">Axes</a></li>
<li><a title="manimlib.mobject.probability.BarChart" href="../probability.html#manimlib.mobject.probability.BarChart">BarChart</a></li>
<li><a title="manimlib.mobject.shape_matchers.Cross" href="../shape_matchers.html#manimlib.mobject.shape_matchers.Cross">Cross</a></li>
<li><a title="manimlib.mobject.svg.code_mobject.Code" href="../svg/code_mobject.html#manimlib.mobject.svg.code_mobject.Code">Code</a></li>
<li><a title="manimlib.mobject.svg.drawings.Clock" href="../svg/drawings.html#manimlib.mobject.svg.drawings.Clock">Clock</a></li>
<li><a title="manimlib.mobject.svg.drawings.DeckOfCards" href="../svg/drawings.html#manimlib.mobject.svg.drawings.DeckOfCards">DeckOfCards</a></li>
<li><a title="manimlib.mobject.svg.drawings.Laptop" href="../svg/drawings.html#manimlib.mobject.svg.drawings.Laptop">Laptop</a></li>
<li><a title="manimlib.mobject.svg.drawings.PlayingCard" href="../svg/drawings.html#manimlib.mobject.svg.drawings.PlayingCard">PlayingCard</a></li>
<li><a title="manimlib.mobject.svg.drawings.VideoSeries" href="../svg/drawings.html#manimlib.mobject.svg.drawings.VideoSeries">VideoSeries</a></li>
<li><a title="manimlib.mobject.svg.text_mobject.Paragraph" href="../svg/text_mobject.html#manimlib.mobject.svg.text_mobject.Paragraph">Paragraph</a></li>
<li><a title="manimlib.mobject.three_dimensions.Cube" href="../three_dimensions.html#manimlib.mobject.three_dimensions.Cube">Cube</a></li>
<li><a title="manimlib.mobject.three_dimensions.ParametricSurface" href="../three_dimensions.html#manimlib.mobject.three_dimensions.ParametricSurface">ParametricSurface</a></li>
<li><a title="manimlib.mobject.types.vectorized_mobject.CurvesAsSubmobjects" href="#manimlib.mobject.types.vectorized_mobject.CurvesAsSubmobjects">CurvesAsSubmobjects</a></li>
<li><a title="manimlib.mobject.vector_field.AnimatedStreamLines" href="../vector_field.html#manimlib.mobject.vector_field.AnimatedStreamLines">AnimatedStreamLines</a></li>
<li><a title="manimlib.mobject.vector_field.StreamLines" href="../vector_field.html#manimlib.mobject.vector_field.StreamLines">StreamLines</a></li>
<li><a title="manimlib.mobject.vector_field.VectorField" href="../vector_field.html#manimlib.mobject.vector_field.VectorField">VectorField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject"><code class="flex name class">
<span>class <span class="ident">VMobject</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VMobject(Mobject):
    CONFIG = {
        &#34;fill_color&#34;: None,
        &#34;fill_opacity&#34;: 0.0,
        &#34;stroke_color&#34;: None,
        &#34;stroke_opacity&#34;: 1.0,
        &#34;stroke_width&#34;: DEFAULT_STROKE_WIDTH,
        # The purpose of background stroke is to have
        # something that won&#39;t overlap the fill, e.g.
        # For text against some textured background
        &#34;background_stroke_color&#34;: &#34;0e0e0e&#34;,
        &#34;background_stroke_opacity&#34;: 1.0,
        &#34;background_stroke_width&#34;: 0,
        # When a color c is set, there will be a second color
        # computed based on interpolating c to WHITE by with
        # sheen_factor, and the display will gradient to this
        # secondary color in the direction of sheen_direction.
        &#34;sheen_factor&#34;: 0.0,
        &#34;sheen_direction&#34;: UL,
        # Indicates that it will not be displayed, but
        # that it should count in parent mobject&#39;s path
        &#34;close_new_points&#34;: False,
        &#34;pre_function_handle_to_anchor_scale_factor&#34;: 0.01,
        &#34;make_smooth_after_applying_functions&#34;: False,
        &#34;background_image_file&#34;: None,
        &#34;shade_in_3d&#34;: False,
        # This is within a pixel
        # TODO, do we care about accounting for
        # varying zoom levels?
        &#34;tolerance_for_point_equality&#34;: 1e-6,
        &#34;n_points_per_cubic_curve&#34;: 4,
    }

    def get_group_class(self):
        return VGroup

    # Colors
    def init_colors(self):
        self.set_fill(
            color=self.fill_color or self.color,
            opacity=self.fill_opacity,
        )
        self.set_stroke(
            color=self.stroke_color or self.color,
            width=self.stroke_width,
            opacity=self.stroke_opacity,
        )
        self.set_background_stroke(
            color=self.background_stroke_color,
            width=self.background_stroke_width,
            opacity=self.background_stroke_opacity,
        )
        self.set_sheen(
            factor=self.sheen_factor,
            direction=self.sheen_direction,
        )
        return self

    def generate_rgbas_array(self, color, opacity):
        &#34;&#34;&#34;
        First arg can be either a color, or a tuple/list of colors.
        Likewise, opacity can either be a float, or a tuple of floats.
        If self.sheen_factor is not zero, and only
        one color was passed in, a second slightly light color
        will automatically be added for the gradient
        &#34;&#34;&#34;
        colors = list(tuplify(color))
        opacities = list(tuplify(opacity))
        rgbas = np.array([
            color_to_rgba(c, o)
            for c, o in zip(*make_even(colors, opacities))
        ])

        sheen_factor = self.get_sheen_factor()
        if sheen_factor != 0 and len(rgbas) == 1:
            light_rgbas = np.array(rgbas)
            light_rgbas[:, :3] += sheen_factor
            clip_in_place(light_rgbas, 0, 1)
            rgbas = np.append(rgbas, light_rgbas, axis=0)
        return rgbas

    def update_rgbas_array(self, array_name, color=None, opacity=None):
        passed_color = color if (color is not None) else BLACK
        passed_opacity = opacity if (opacity is not None) else 0
        rgbas = self.generate_rgbas_array(passed_color, passed_opacity)
        if not hasattr(self, array_name):
            setattr(self, array_name, rgbas)
            return self
        # Match up current rgbas array with the newly calculated
        # one. 99% of the time they&#39;ll be the same.
        curr_rgbas = getattr(self, array_name)
        if len(curr_rgbas) &lt; len(rgbas):
            curr_rgbas = stretch_array_to_length(
                curr_rgbas, len(rgbas)
            )
            setattr(self, array_name, curr_rgbas)
        elif len(rgbas) &lt; len(curr_rgbas):
            rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))
        # Only update rgb if color was not None, and only
        # update alpha channel if opacity was passed in
        if color is not None:
            curr_rgbas[:, :3] = rgbas[:, :3]
        if opacity is not None:
            curr_rgbas[:, 3] = rgbas[:, 3]
        return self

    def set_fill(self, color=None, opacity=None, family=True):
        if family:
            for submobject in self.submobjects:
                submobject.set_fill(color, opacity, family)
        self.update_rgbas_array(&#34;fill_rgbas&#34;, color, opacity)
        return self

    def set_stroke(self, color=None, width=None, opacity=None,
                   background=False, family=True):
        if family:
            for submobject in self.submobjects:
                submobject.set_stroke(
                    color, width, opacity, background, family
                )
        if background:
            array_name = &#34;background_stroke_rgbas&#34;
            width_name = &#34;background_stroke_width&#34;
        else:
            array_name = &#34;stroke_rgbas&#34;
            width_name = &#34;stroke_width&#34;
        self.update_rgbas_array(array_name, color, opacity)
        if width is not None:
            setattr(self, width_name, width)
        return self

    def set_background_stroke(self, **kwargs):
        kwargs[&#34;background&#34;] = True
        self.set_stroke(**kwargs)
        return self

    def set_style(self,
                  fill_color=None,
                  fill_opacity=None,
                  stroke_color=None,
                  stroke_width=None,
                  stroke_opacity=None,
                  background_stroke_color=None,
                  background_stroke_width=None,
                  background_stroke_opacity=None,
                  sheen_factor=None,
                  sheen_direction=None,
                  background_image_file=None,
                  family=True):
        self.set_fill(
            color=fill_color,
            opacity=fill_opacity,
            family=family
        )
        self.set_stroke(
            color=stroke_color,
            width=stroke_width,
            opacity=stroke_opacity,
            family=family,
        )
        self.set_background_stroke(
            color=background_stroke_color,
            width=background_stroke_width,
            opacity=background_stroke_opacity,
            family=family,
        )
        if sheen_factor:
            self.set_sheen(
                factor=sheen_factor,
                direction=sheen_direction,
                family=family,
            )
        if background_image_file:
            self.color_using_background_image(background_image_file)
        return self

    def get_style(self):
        return {
            &#34;fill_color&#34;: self.get_fill_colors(),
            &#34;fill_opacity&#34;: self.get_fill_opacities(),
            &#34;stroke_color&#34;: self.get_stroke_colors(),
            &#34;stroke_width&#34;: self.get_stroke_width(),
            &#34;stroke_opacity&#34;: self.get_stroke_opacity(),
            &#34;background_stroke_color&#34;: self.get_stroke_colors(background=True),
            &#34;background_stroke_width&#34;: self.get_stroke_width(background=True),
            &#34;background_stroke_opacity&#34;: self.get_stroke_opacity(background=True),
            &#34;sheen_factor&#34;: self.get_sheen_factor(),
            &#34;sheen_direction&#34;: self.get_sheen_direction(),
            &#34;background_image_file&#34;: self.get_background_image_file(),
        }

    def match_style(self, vmobject, family=True):
        self.set_style(**vmobject.get_style(), family=False)

        if family:
            # Does its best to match up submobject lists, and
            # match styles accordingly
            submobs1, submobs2 = self.submobjects, vmobject.submobjects
            if len(submobs1) == 0:
                return self
            elif len(submobs2) == 0:
                submobs2 = [vmobject]
            for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
                sm1.match_style(sm2)
        return self

    def set_color(self, color, family=True):
        self.set_fill(color, family=family)
        self.set_stroke(color, family=family)
        return self

    def set_opacity(self, opacity, family=True):
        self.set_fill(opacity=opacity, family=family)
        self.set_stroke(opacity=opacity, family=family)
        self.set_stroke(opacity=opacity, family=family, background=True)
        return self

    def fade(self, darkness=0.5, family=True):
        factor = 1.0 - darkness
        self.set_fill(
            opacity=factor * self.get_fill_opacity(),
            family=False,
        )
        self.set_stroke(
            opacity=factor * self.get_stroke_opacity(),
            family=False,
        )
        self.set_background_stroke(
            opacity=factor * self.get_stroke_opacity(
                background=True
            ),
            family=False,
        )
        super().fade(darkness, family)
        return self

    def get_fill_rgbas(self):
        try:
            return self.fill_rgbas
        except AttributeError:
            return np.zeros((1, 4))

    def get_fill_color(self):
        &#34;&#34;&#34;
        If there are multiple colors (for gradient)
        this returns the first one
        &#34;&#34;&#34;
        return self.get_fill_colors()[0]

    def get_fill_opacity(self):
        &#34;&#34;&#34;
        If there are multiple opacities, this returns the
        first
        &#34;&#34;&#34;
        return self.get_fill_opacities()[0]

    def get_fill_colors(self):
        return [
            Color(rgb=rgba[:3])
            for rgba in self.get_fill_rgbas()
        ]

    def get_fill_opacities(self):
        return self.get_fill_rgbas()[:, 3]

    def get_stroke_rgbas(self, background=False):
        try:
            if background:
                rgbas = self.background_stroke_rgbas
            else:
                rgbas = self.stroke_rgbas
            return rgbas
        except AttributeError:
            return np.zeros((1, 4))

    def get_stroke_color(self, background=False):
        return self.get_stroke_colors(background)[0]

    def get_stroke_width(self, background=False):
        if background:
            width = self.background_stroke_width
        else:
            width = self.stroke_width
        return max(0, width)

    def get_stroke_opacity(self, background=False):
        return self.get_stroke_opacities(background)[0]

    def get_stroke_colors(self, background=False):
        return [
            Color(rgb=rgba[:3])
            for rgba in self.get_stroke_rgbas(background)
        ]

    def get_stroke_opacities(self, background=False):
        return self.get_stroke_rgbas(background)[:, 3]

    def get_color(self):
        if np.all(self.get_fill_opacities() == 0):
            return self.get_stroke_color()
        return self.get_fill_color()

    def set_sheen_direction(self, direction, family=True):
        direction = np.array(direction)
        if family:
            for submob in self.get_family():
                submob.sheen_direction = direction
        else:
            self.sheen_direction = direction
        return self

    def set_sheen(self, factor, direction=None, family=True):
        if family:
            for submob in self.submobjects:
                submob.set_sheen(factor, direction, family)
        self.sheen_factor = factor
        if direction is not None:
            # family set to false because recursion will
            # already be handled above
            self.set_sheen_direction(direction, family=False)
        # Reset color to put sheen_factor into effect
        if factor != 0:
            self.set_stroke(self.get_stroke_color(), family=family)
            self.set_fill(self.get_fill_color(), family=family)
        return self

    def get_sheen_direction(self):
        return np.array(self.sheen_direction)

    def get_sheen_factor(self):
        return self.sheen_factor

    def get_gradient_start_and_end_points(self):
        if self.shade_in_3d:
            return get_3d_vmob_gradient_start_and_end_points(self)
        else:
            direction = self.get_sheen_direction()
            c = self.get_center()
            bases = np.array([
                self.get_edge_center(vect) - c
                for vect in [RIGHT, UP, OUT]
            ]).transpose()
            offset = np.dot(bases, direction)
            return (c - offset, c + offset)

    def color_using_background_image(self, background_image_file):
        self.background_image_file = background_image_file
        self.set_color(WHITE)
        for submob in self.submobjects:
            submob.color_using_background_image(background_image_file)
        return self

    def get_background_image_file(self):
        return self.background_image_file

    def match_background_image_file(self, vmobject):
        self.color_using_background_image(vmobject.get_background_image_file())
        return self

    def set_shade_in_3d(self, value=True, z_index_as_group=False):
        for submob in self.get_family():
            submob.shade_in_3d = value
            if z_index_as_group:
                submob.z_index_group = self
        return self

    # Points
    def set_points(self, points):
        self.points = np.array(points)
        return self

    def get_points(self):
        return np.array(self.points)

    def set_anchors_and_handles(self, anchors1, handles1, handles2, anchors2):
        assert(len(anchors1) == len(handles1) == len(handles2) == len(anchors2))
        nppcc = self.n_points_per_cubic_curve  # 4
        total_len = nppcc * len(anchors1)
        self.points = np.zeros((total_len, self.dim))
        arrays = [anchors1, handles1, handles2, anchors2]
        for index, array in enumerate(arrays):
            self.points[index::nppcc] = array
        return self

    def clear_points(self):
        self.points = np.zeros((0, self.dim))

    def append_points(self, new_points):
        # TODO, check that number new points is a multiple of 4?
        # or else that if len(self.points) % 4 == 1, then
        # len(new_points) % 4 == 3?
        self.points = np.append(self.points, new_points, axis=0)
        return self

    def start_new_path(self, point):
        # TODO, make sure that len(self.points) % 4 == 0?
        self.append_points([point])
        return self

    def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):
        # TODO, check the len(self.points) % 4 == 0?
        self.append_points([anchor1, handle1, handle2, anchor2])

    def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):
        &#34;&#34;&#34;
        Add cubic bezier curve to the path.
        &#34;&#34;&#34;
        self.throw_error_if_no_points()
        new_points = [handle1, handle2, anchor]
        if self.has_new_path_started():
            self.append_points(new_points)
        else:
            self.append_points([self.get_last_point()] + new_points)

    def add_line_to(self, point):
        nppcc = self.n_points_per_cubic_curve
        self.add_cubic_bezier_curve_to(*[
            interpolate(self.get_last_point(), point, a)
            for a in np.linspace(0, 1, nppcc)[1:]
        ])
        return self

    def add_smooth_curve_to(self, *points):
        &#34;&#34;&#34;
        If two points are passed in, the first is intepretted
        as a handle, the second as an anchor
        &#34;&#34;&#34;
        if len(points) == 1:
            handle2 = None
            new_anchor = points[0]
        elif len(points) == 2:
            handle2, new_anchor = points
        else:
            name = sys._getframe(0).f_code.co_name
            raise Exception(&#34;Only call {} with 1 or 2 points&#34;.format(name))

        if self.has_new_path_started():
            self.add_line_to(new_anchor)
        else:
            self.throw_error_if_no_points()
            last_h2, last_a2 = self.points[-2:]
            last_tangent = (last_a2 - last_h2)
            handle1 = last_a2 + last_tangent
            if handle2 is None:
                to_anchor_vect = new_anchor - last_a2
                new_tangent = rotate_vector(
                    last_tangent, PI, axis=to_anchor_vect
                )
                handle2 = new_anchor - new_tangent
            self.append_points([
                last_a2, handle1, handle2, new_anchor
            ])
        return self

    def has_new_path_started(self):
        nppcc = self.n_points_per_cubic_curve  # 4
        return len(self.points) % nppcc == 1

    def get_last_point(self):
        return self.points[-1]

    def is_closed(self):
        return self.consider_points_equals(
            self.points[0], self.points[-1]
        )

    def add_points_as_corners(self, points):
        for point in points:
            self.add_line_to(point)
        return points

    def set_points_as_corners(self, points):
        nppcc = self.n_points_per_cubic_curve
        points = np.array(points)
        self.set_anchors_and_handles(*[
            interpolate(points[:-1], points[1:], a)
            for a in np.linspace(0, 1, nppcc)
        ])
        return self

    def set_points_smoothly(self, points):
        self.set_points_as_corners(points)
        self.make_smooth()
        return self

    def change_anchor_mode(self, mode):
        assert(mode in [&#34;jagged&#34;, &#34;smooth&#34;])
        nppcc = self.n_points_per_cubic_curve
        for submob in self.family_members_with_points():
            subpaths = submob.get_subpaths()
            submob.clear_points()
            for subpath in subpaths:
                anchors = np.append(
                    subpath[::nppcc],
                    subpath[-1:],
                    0
                )
                if mode == &#34;smooth&#34;:
                    h1, h2 = get_smooth_handle_points(anchors)
                elif mode == &#34;jagged&#34;:
                    a1 = anchors[:-1]
                    a2 = anchors[1:]
                    h1 = interpolate(a1, a2, 1.0 / 3)
                    h2 = interpolate(a1, a2, 2.0 / 3)
                new_subpath = np.array(subpath)
                new_subpath[1::nppcc] = h1
                new_subpath[2::nppcc] = h2
                submob.append_points(new_subpath)
        return self

    def make_smooth(self):
        return self.change_anchor_mode(&#34;smooth&#34;)

    def make_jagged(self):
        return self.change_anchor_mode(&#34;jagged&#34;)

    def add_subpath(self, points):
        assert(len(points) % 4 == 0)
        self.points = np.append(self.points, points, axis=0)
        return self

    def append_vectorized_mobject(self, vectorized_mobject):
        new_points = list(vectorized_mobject.points)

        if self.has_new_path_started():
            # Remove last point, which is starting
            # a new path
            self.points = self.points[:-1]
        self.append_points(new_points)

    def apply_function(self, function):
        factor = self.pre_function_handle_to_anchor_scale_factor
        self.scale_handle_to_anchor_distances(factor)
        Mobject.apply_function(self, function)
        self.scale_handle_to_anchor_distances(1. / factor)
        if self.make_smooth_after_applying_functions:
            self.make_smooth()
        return self

    def scale_handle_to_anchor_distances(self, factor):
        &#34;&#34;&#34;
        If the distance between a given handle point H and its associated
        anchor point A is d, then it changes H to be a distances factor*d
        away from A, but so that the line from A to H doesn&#39;t change.
        This is mostly useful in the context of applying a (differentiable)
        function, to preserve tangency properties.  One would pull all the
        handles closer to their anchors, apply the function then push them out
        again.
        &#34;&#34;&#34;
        for submob in self.family_members_with_points():
            if len(submob.points) &lt; self.n_points_per_cubic_curve:
                continue
            a1, h1, h2, a2 = submob.get_anchors_and_handles()
            a1_to_h1 = h1 - a1
            a2_to_h2 = h2 - a2
            new_h1 = a1 + factor * a1_to_h1
            new_h2 = a2 + factor * a2_to_h2
            submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)
        return self

    #
    def consider_points_equals(self, p0, p1):
        return np.allclose(
            p0, p1,
            atol=self.tolerance_for_point_equality
        )

    def consider_points_equals_2d(self, p0, p1):
        &#34;&#34;&#34;
        Determine if two points are close enough to be considered equal.

        This uses the algorithm from np.isclose(), but expanded here for the
        2D point case. NumPy is overkill for such a small question.
        &#34;&#34;&#34;
        rtol = 1.e-5  # default from np.isclose()
        atol = self.tolerance_for_point_equality
        if abs(p0[0] - p1[0]) &gt; atol + rtol * abs(p1[0]):
            return False
        if abs(p0[1] - p1[1]) &gt; atol + rtol * abs(p1[1]):
            return False
        return True

    # Information about line
    def get_cubic_bezier_tuples_from_points(self, points):
        return np.array(list(self.gen_cubic_bezier_tuples_from_points(points)))

    def gen_cubic_bezier_tuples_from_points(self, points):
        &#34;&#34;&#34;
        Get a generator for the cubic bezier tuples of this object.

        Generator to not materialize a list or np.array needlessly.
        &#34;&#34;&#34;
        nppcc = VMobject.CONFIG[&#34;n_points_per_cubic_curve&#34;]
        remainder = len(points) % nppcc
        points = points[:len(points) - remainder]
        return (
            points[i:i + nppcc]
            for i in range(0, len(points), nppcc)
        )

    def get_cubic_bezier_tuples(self):
        return self.get_cubic_bezier_tuples_from_points(
            self.get_points()
        )

    def _gen_subpaths_from_points(self, points, filter_func):
        nppcc = self.n_points_per_cubic_curve
        split_indices = filter(filter_func, range(nppcc, len(points), nppcc))
        split_indices = [0] + list(split_indices) + [len(points)]
        return (
            points[i1:i2]
            for i1, i2 in zip(split_indices, split_indices[1:])
            if (i2 - i1) &gt;= nppcc
        )

    def get_subpaths_from_points(self, points):
        return list(
            self._gen_subpaths_from_points(
                points,
                lambda n: not self.consider_points_equals(
                    points[n - 1], points[n]
                ))
        )

    def gen_subpaths_from_points_2d(self, points):
        return self._gen_subpaths_from_points(
                points,
                lambda n: not self.consider_points_equals_2d(
                    points[n - 1], points[n]
                ))

    def get_subpaths(self):
        return self.get_subpaths_from_points(self.get_points())

    def get_nth_curve_points(self, n):
        assert(n &lt; self.get_num_curves())
        nppcc = self.n_points_per_cubic_curve
        return self.points[nppcc * n:nppcc * (n + 1)]

    def get_nth_curve_function(self, n):
        return bezier(self.get_nth_curve_points(n))

    def get_num_curves(self):
        nppcc = self.n_points_per_cubic_curve
        return len(self.points) // nppcc

    def point_from_proportion(self, alpha):
        num_cubics = self.get_num_curves()
        n, residue = integer_interpolate(0, num_cubics, alpha)
        curve = self.get_nth_curve_function(n)
        return curve(residue)

    def get_anchors_and_handles(self):
        &#34;&#34;&#34;
        returns anchors1, handles1, handles2, anchors2,
        where (anchors1[i], handles1[i], handles2[i], anchors2[i])
        will be four points defining a cubic bezier curve
        for any i in range(0, len(anchors1))
        &#34;&#34;&#34;
        nppcc = self.n_points_per_cubic_curve
        return [
            self.points[i::nppcc]
            for i in range(nppcc)
        ]

    def get_start_anchors(self):
        return self.points[0::self.n_points_per_cubic_curve]

    def get_end_anchors(self):
        nppcc = self.n_points_per_cubic_curve
        return self.points[nppcc - 1::nppcc]

    def get_anchors(self):
        if self.points.shape[0] == 1:
            return self.points
        return np.array(list(it.chain(*zip(
            self.get_start_anchors(),
            self.get_end_anchors(),
        ))))

    def get_points_defining_boundary(self):
        return np.array(list(it.chain(*[
            sm.get_anchors()
            for sm in self.get_family()
        ])))

    def get_arc_length(self, n_sample_points=None):
        if n_sample_points is None:
            n_sample_points = 4 * self.get_num_curves() + 1
        points = np.array([
            self.point_from_proportion(a)
            for a in np.linspace(0, 1, n_sample_points)
        ])
        diffs = points[1:] - points[:-1]
        norms = np.apply_along_axis(get_norm, 1, diffs)
        return np.sum(norms)

    # Alignment
    def align_points(self, vmobject):
        self.align_rgbas(vmobject)
        if self.get_num_points() == vmobject.get_num_points():
            return

        for mob in self, vmobject:
            # If there are no points, add one to
            # whereever the &#34;center&#34; is
            if mob.has_no_points():
                mob.start_new_path(mob.get_center())
            # If there&#39;s only one point, turn it into
            # a null curve
            if mob.has_new_path_started():
                mob.add_line_to(mob.get_last_point())

        # Figure out what the subpaths are, and align
        subpaths1 = self.get_subpaths()
        subpaths2 = vmobject.get_subpaths()
        n_subpaths = max(len(subpaths1), len(subpaths2))
        # Start building new ones
        new_path1 = np.zeros((0, self.dim))
        new_path2 = np.zeros((0, self.dim))

        nppcc = self.n_points_per_cubic_curve

        def get_nth_subpath(path_list, n):
            if n &gt;= len(path_list):
                # Create a null path at the very end
                return [path_list[-1][-1]] * nppcc
            return path_list[n]

        for n in range(n_subpaths):
            sp1 = get_nth_subpath(subpaths1, n)
            sp2 = get_nth_subpath(subpaths2, n)
            diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)
            diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)
            sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
            sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
            new_path1 = np.append(new_path1, sp1, axis=0)
            new_path2 = np.append(new_path2, sp2, axis=0)
        self.set_points(new_path1)
        vmobject.set_points(new_path2)
        return self

    def insert_n_curves(self, n):
        new_path_point = None
        if self.has_new_path_started():
            new_path_point = self.get_last_point()

        new_points = self.insert_n_curves_to_point_list(
            n, self.get_points()
        )
        self.set_points(new_points)

        if new_path_point is not None:
            self.append_points([new_path_point])
        return self

    def insert_n_curves_to_point_list(self, n, points):
        if len(points) == 1:
            nppcc = self.n_points_per_cubic_curve
            return np.repeat(points, nppcc * n, 0)
        bezier_quads = self.get_cubic_bezier_tuples_from_points(points)
        curr_num = len(bezier_quads)
        target_num = curr_num + n
        # This is an array with values ranging from 0
        # up to curr_num,  with repeats such that
        # it&#39;s total length is target_num.  For example,
        # with curr_num = 10, target_num = 15, this would
        # be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]
        repeat_indices = (np.arange(target_num) * curr_num) // target_num

        # If the nth term of this list is k, it means
        # that the nth curve of our path should be split
        # into k pieces.  In the above example, this would
        # be [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]
        split_factors = [
            sum(repeat_indices == i)
            for i in range(curr_num)
        ]
        new_points = np.zeros((0, self.dim))
        for quad, sf in zip(bezier_quads, split_factors):
            # What was once a single cubic curve defined
            # by &#34;quad&#34; will now be broken into sf
            # smaller cubic curves
            alphas = np.linspace(0, 1, sf + 1)
            for a1, a2 in zip(alphas, alphas[1:]):
                new_points = np.append(
                    new_points,
                    partial_bezier_points(quad, a1, a2),
                    axis=0
                )
        return new_points

    def align_rgbas(self, vmobject):
        attrs = [&#34;fill_rgbas&#34;, &#34;stroke_rgbas&#34;, &#34;background_stroke_rgbas&#34;]
        for attr in attrs:
            a1 = getattr(self, attr)
            a2 = getattr(vmobject, attr)
            if len(a1) &gt; len(a2):
                new_a2 = stretch_array_to_length(a2, len(a1))
                setattr(vmobject, attr, new_a2)
            elif len(a2) &gt; len(a1):
                new_a1 = stretch_array_to_length(a1, len(a2))
                setattr(self, attr, new_a1)
        return self

    def get_point_mobject(self, center=None):
        if center is None:
            center = self.get_center()
        point = VectorizedPoint(center)
        point.match_style(self)
        return point

    def interpolate_color(self, mobject1, mobject2, alpha):
        attrs = [
            &#34;fill_rgbas&#34;,
            &#34;stroke_rgbas&#34;,
            &#34;background_stroke_rgbas&#34;,
            &#34;stroke_width&#34;,
            &#34;background_stroke_width&#34;,
            &#34;sheen_direction&#34;,
            &#34;sheen_factor&#34;,
        ]
        for attr in attrs:
            setattr(self, attr, interpolate(
                getattr(mobject1, attr),
                getattr(mobject2, attr),
                alpha
            ))
            if alpha == 1.0:
                setattr(self, attr, getattr(mobject2, attr))

    def pointwise_become_partial(self, vmobject, a, b):
        assert(isinstance(vmobject, VMobject))
        # Partial curve includes three portions:
        # - A middle section, which matches the curve exactly
        # - A start, which is some ending portion of an inner cubic
        # - An end, which is the starting portion of a later inner cubic
        if a &lt;= 0 and b &gt;= 1:
            self.set_points(vmobject.points)
            return self
        bezier_quads = vmobject.get_cubic_bezier_tuples()
        num_cubics = len(bezier_quads)

        lower_index, lower_residue = integer_interpolate(0, num_cubics, a)
        upper_index, upper_residue = integer_interpolate(0, num_cubics, b)

        self.clear_points()
        if num_cubics == 0:
            return self
        if lower_index == upper_index:
            self.append_points(partial_bezier_points(
                bezier_quads[lower_index],
                lower_residue, upper_residue
            ))
        else:
            self.append_points(partial_bezier_points(
                bezier_quads[lower_index], lower_residue, 1
            ))
            for quad in bezier_quads[lower_index + 1:upper_index]:
                self.append_points(quad)
            self.append_points(partial_bezier_points(
                bezier_quads[upper_index], 0, upper_residue
            ))
        return self

    def get_subcurve(self, a, b):
        vmob = self.copy()
        vmob.pointwise_become_partial(self, a, b)
        return vmob</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.for_3b1b_videos.pi_creature.Eyes" href="../../for_3b1b_videos/pi_creature.html#manimlib.for_3b1b_videos.pi_creature.Eyes">Eyes</a></li>
<li><a title="manimlib.mobject.changing.TracedPath" href="../changing.html#manimlib.mobject.changing.TracedPath">TracedPath</a></li>
<li><a title="manimlib.mobject.functions.ParametricFunction" href="../functions.html#manimlib.mobject.functions.ParametricFunction">ParametricFunction</a></li>
<li><a title="manimlib.mobject.geometry.CubicBezier" href="../geometry.html#manimlib.mobject.geometry.CubicBezier">CubicBezier</a></li>
<li><a title="manimlib.mobject.geometry.Elbow" href="../geometry.html#manimlib.mobject.geometry.Elbow">Elbow</a></li>
<li><a title="manimlib.mobject.geometry.Polygon" href="../geometry.html#manimlib.mobject.geometry.Polygon">Polygon</a></li>
<li><a title="manimlib.mobject.geometry.TipableVMobject" href="../geometry.html#manimlib.mobject.geometry.TipableVMobject">TipableVMobject</a></li>
<li><a title="manimlib.mobject.matrix.Matrix" href="../matrix.html#manimlib.mobject.matrix.Matrix">Matrix</a></li>
<li><a title="manimlib.mobject.numbers.DecimalNumber" href="../numbers.html#manimlib.mobject.numbers.DecimalNumber">DecimalNumber</a></li>
<li><a title="manimlib.mobject.svg.brace.BraceLabel" href="../svg/brace.html#manimlib.mobject.svg.brace.BraceLabel">BraceLabel</a></li>
<li><a title="manimlib.mobject.svg.drawings.Logo" href="../svg/drawings.html#manimlib.mobject.svg.drawings.Logo">Logo</a></li>
<li><a title="manimlib.mobject.svg.drawings.Speedometer" href="../svg/drawings.html#manimlib.mobject.svg.drawings.Speedometer">Speedometer</a></li>
<li><a title="manimlib.mobject.svg.svg_mobject.SVGMobject" href="../svg/svg_mobject.html#manimlib.mobject.svg.svg_mobject.SVGMobject">SVGMobject</a></li>
<li><a title="manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring" href="../svg/svg_mobject.html#manimlib.mobject.svg.svg_mobject.VMobjectFromSVGPathstring">VMobjectFromSVGPathstring</a></li>
<li><a title="manimlib.mobject.three_dimensions.ThreeDVMobject" href="../three_dimensions.html#manimlib.mobject.three_dimensions.ThreeDVMobject">ThreeDVMobject</a></li>
<li><a title="manimlib.mobject.types.vectorized_mobject.DashedVMobject" href="#manimlib.mobject.types.vectorized_mobject.DashedVMobject">DashedVMobject</a></li>
<li><a title="manimlib.mobject.types.vectorized_mobject.VGroup" href="#manimlib.mobject.types.vectorized_mobject.VGroup">VGroup</a></li>
<li><a title="manimlib.mobject.types.vectorized_mobject.VectorizedPoint" href="#manimlib.mobject.types.vectorized_mobject.VectorizedPoint">VectorizedPoint</a></li>
<li><a title="manimlib.once_useful_constructs.combinatorics.GeneralizedPascalsTriangle" href="../../once_useful_constructs/combinatorics.html#manimlib.once_useful_constructs.combinatorics.GeneralizedPascalsTriangle">GeneralizedPascalsTriangle</a></li>
<li><a title="manimlib.once_useful_constructs.fractals.FractalCurve" href="../../once_useful_constructs/fractals.html#manimlib.once_useful_constructs.fractals.FractalCurve">FractalCurve</a></li>
<li><a title="manimlib.once_useful_constructs.fractals.JaggedCurvePiece" href="../../once_useful_constructs/fractals.html#manimlib.once_useful_constructs.fractals.JaggedCurvePiece">JaggedCurvePiece</a></li>
<li><a title="manimlib.once_useful_constructs.fractals.PiCreatureFractal" href="../../once_useful_constructs/fractals.html#manimlib.once_useful_constructs.fractals.PiCreatureFractal">PiCreatureFractal</a></li>
<li><a title="manimlib.once_useful_constructs.fractals.SelfSimilarFractal" href="../../once_useful_constructs/fractals.html#manimlib.once_useful_constructs.fractals.SelfSimilarFractal">SelfSimilarFractal</a></li>
<li><a title="manimlib.once_useful_constructs.light.AmbientLight" href="../../once_useful_constructs/light.html#manimlib.once_useful_constructs.light.AmbientLight">AmbientLight</a></li>
<li><a title="manimlib.once_useful_constructs.light.LightSource" href="../../once_useful_constructs/light.html#manimlib.once_useful_constructs.light.LightSource">LightSource</a></li>
<li><a title="manimlib.once_useful_constructs.light.Spotlight" href="../../once_useful_constructs/light.html#manimlib.once_useful_constructs.light.Spotlight">Spotlight</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve"><code class="name flex">
<span>def <span class="ident">add_cubic_bezier_curve</span></span>(<span>self, anchor1, handle1, handle2, anchor2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):
    # TODO, check the len(self.points) % 4 == 0?
    self.append_points([anchor1, handle1, handle2, anchor2])</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to"><code class="name flex">
<span>def <span class="ident">add_cubic_bezier_curve_to</span></span>(<span>self, handle1, handle2, anchor)</span>
</code></dt>
<dd>
<div class="desc"><p>Add cubic bezier curve to the path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):
    &#34;&#34;&#34;
    Add cubic bezier curve to the path.
    &#34;&#34;&#34;
    self.throw_error_if_no_points()
    new_points = [handle1, handle2, anchor]
    if self.has_new_path_started():
        self.append_points(new_points)
    else:
        self.append_points([self.get_last_point()] + new_points)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.add_line_to"><code class="name flex">
<span>def <span class="ident">add_line_to</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_line_to(self, point):
    nppcc = self.n_points_per_cubic_curve
    self.add_cubic_bezier_curve_to(*[
        interpolate(self.get_last_point(), point, a)
        for a in np.linspace(0, 1, nppcc)[1:]
    ])
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.add_points_as_corners"><code class="name flex">
<span>def <span class="ident">add_points_as_corners</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_points_as_corners(self, points):
    for point in points:
        self.add_line_to(point)
    return points</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to"><code class="name flex">
<span>def <span class="ident">add_smooth_curve_to</span></span>(<span>self, *points)</span>
</code></dt>
<dd>
<div class="desc"><p>If two points are passed in, the first is intepretted
as a handle, the second as an anchor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_smooth_curve_to(self, *points):
    &#34;&#34;&#34;
    If two points are passed in, the first is intepretted
    as a handle, the second as an anchor
    &#34;&#34;&#34;
    if len(points) == 1:
        handle2 = None
        new_anchor = points[0]
    elif len(points) == 2:
        handle2, new_anchor = points
    else:
        name = sys._getframe(0).f_code.co_name
        raise Exception(&#34;Only call {} with 1 or 2 points&#34;.format(name))

    if self.has_new_path_started():
        self.add_line_to(new_anchor)
    else:
        self.throw_error_if_no_points()
        last_h2, last_a2 = self.points[-2:]
        last_tangent = (last_a2 - last_h2)
        handle1 = last_a2 + last_tangent
        if handle2 is None:
            to_anchor_vect = new_anchor - last_a2
            new_tangent = rotate_vector(
                last_tangent, PI, axis=to_anchor_vect
            )
            handle2 = new_anchor - new_tangent
        self.append_points([
            last_a2, handle1, handle2, new_anchor
        ])
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.add_subpath"><code class="name flex">
<span>def <span class="ident">add_subpath</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_subpath(self, points):
    assert(len(points) % 4 == 0)
    self.points = np.append(self.points, points, axis=0)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.align_points"><code class="name flex">
<span>def <span class="ident">align_points</span></span>(<span>self, vmobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_points(self, vmobject):
    self.align_rgbas(vmobject)
    if self.get_num_points() == vmobject.get_num_points():
        return

    for mob in self, vmobject:
        # If there are no points, add one to
        # whereever the &#34;center&#34; is
        if mob.has_no_points():
            mob.start_new_path(mob.get_center())
        # If there&#39;s only one point, turn it into
        # a null curve
        if mob.has_new_path_started():
            mob.add_line_to(mob.get_last_point())

    # Figure out what the subpaths are, and align
    subpaths1 = self.get_subpaths()
    subpaths2 = vmobject.get_subpaths()
    n_subpaths = max(len(subpaths1), len(subpaths2))
    # Start building new ones
    new_path1 = np.zeros((0, self.dim))
    new_path2 = np.zeros((0, self.dim))

    nppcc = self.n_points_per_cubic_curve

    def get_nth_subpath(path_list, n):
        if n &gt;= len(path_list):
            # Create a null path at the very end
            return [path_list[-1][-1]] * nppcc
        return path_list[n]

    for n in range(n_subpaths):
        sp1 = get_nth_subpath(subpaths1, n)
        sp2 = get_nth_subpath(subpaths2, n)
        diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)
        diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)
        sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
        sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
        new_path1 = np.append(new_path1, sp1, axis=0)
        new_path2 = np.append(new_path2, sp2, axis=0)
    self.set_points(new_path1)
    vmobject.set_points(new_path2)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.align_rgbas"><code class="name flex">
<span>def <span class="ident">align_rgbas</span></span>(<span>self, vmobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_rgbas(self, vmobject):
    attrs = [&#34;fill_rgbas&#34;, &#34;stroke_rgbas&#34;, &#34;background_stroke_rgbas&#34;]
    for attr in attrs:
        a1 = getattr(self, attr)
        a2 = getattr(vmobject, attr)
        if len(a1) &gt; len(a2):
            new_a2 = stretch_array_to_length(a2, len(a1))
            setattr(vmobject, attr, new_a2)
        elif len(a2) &gt; len(a1):
            new_a1 = stretch_array_to_length(a1, len(a2))
            setattr(self, attr, new_a1)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.append_points"><code class="name flex">
<span>def <span class="ident">append_points</span></span>(<span>self, new_points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_points(self, new_points):
    # TODO, check that number new points is a multiple of 4?
    # or else that if len(self.points) % 4 == 1, then
    # len(new_points) % 4 == 3?
    self.points = np.append(self.points, new_points, axis=0)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.append_vectorized_mobject"><code class="name flex">
<span>def <span class="ident">append_vectorized_mobject</span></span>(<span>self, vectorized_mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_vectorized_mobject(self, vectorized_mobject):
    new_points = list(vectorized_mobject.points)

    if self.has_new_path_started():
        # Remove last point, which is starting
        # a new path
        self.points = self.points[:-1]
    self.append_points(new_points)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.apply_function"><code class="name flex">
<span>def <span class="ident">apply_function</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_function(self, function):
    factor = self.pre_function_handle_to_anchor_scale_factor
    self.scale_handle_to_anchor_distances(factor)
    Mobject.apply_function(self, function)
    self.scale_handle_to_anchor_distances(1. / factor)
    if self.make_smooth_after_applying_functions:
        self.make_smooth()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.change_anchor_mode"><code class="name flex">
<span>def <span class="ident">change_anchor_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_anchor_mode(self, mode):
    assert(mode in [&#34;jagged&#34;, &#34;smooth&#34;])
    nppcc = self.n_points_per_cubic_curve
    for submob in self.family_members_with_points():
        subpaths = submob.get_subpaths()
        submob.clear_points()
        for subpath in subpaths:
            anchors = np.append(
                subpath[::nppcc],
                subpath[-1:],
                0
            )
            if mode == &#34;smooth&#34;:
                h1, h2 = get_smooth_handle_points(anchors)
            elif mode == &#34;jagged&#34;:
                a1 = anchors[:-1]
                a2 = anchors[1:]
                h1 = interpolate(a1, a2, 1.0 / 3)
                h2 = interpolate(a1, a2, 2.0 / 3)
            new_subpath = np.array(subpath)
            new_subpath[1::nppcc] = h1
            new_subpath[2::nppcc] = h2
            submob.append_points(new_subpath)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.clear_points"><code class="name flex">
<span>def <span class="ident">clear_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_points(self):
    self.points = np.zeros((0, self.dim))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.color_using_background_image"><code class="name flex">
<span>def <span class="ident">color_using_background_image</span></span>(<span>self, background_image_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_using_background_image(self, background_image_file):
    self.background_image_file = background_image_file
    self.set_color(WHITE)
    for submob in self.submobjects:
        submob.color_using_background_image(background_image_file)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals"><code class="name flex">
<span>def <span class="ident">consider_points_equals</span></span>(<span>self, p0, p1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consider_points_equals(self, p0, p1):
    return np.allclose(
        p0, p1,
        atol=self.tolerance_for_point_equality
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d"><code class="name flex">
<span>def <span class="ident">consider_points_equals_2d</span></span>(<span>self, p0, p1)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if two points are close enough to be considered equal.</p>
<p>This uses the algorithm from np.isclose(), but expanded here for the
2D point case. NumPy is overkill for such a small question.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consider_points_equals_2d(self, p0, p1):
    &#34;&#34;&#34;
    Determine if two points are close enough to be considered equal.

    This uses the algorithm from np.isclose(), but expanded here for the
    2D point case. NumPy is overkill for such a small question.
    &#34;&#34;&#34;
    rtol = 1.e-5  # default from np.isclose()
    atol = self.tolerance_for_point_equality
    if abs(p0[0] - p1[0]) &gt; atol + rtol * abs(p1[0]):
        return False
    if abs(p0[1] - p1[1]) &gt; atol + rtol * abs(p1[1]):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.fade"><code class="name flex">
<span>def <span class="ident">fade</span></span>(<span>self, darkness=0.5, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fade(self, darkness=0.5, family=True):
    factor = 1.0 - darkness
    self.set_fill(
        opacity=factor * self.get_fill_opacity(),
        family=False,
    )
    self.set_stroke(
        opacity=factor * self.get_stroke_opacity(),
        family=False,
    )
    self.set_background_stroke(
        opacity=factor * self.get_stroke_opacity(
            background=True
        ),
        family=False,
    )
    super().fade(darkness, family)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points"><code class="name flex">
<span>def <span class="ident">gen_cubic_bezier_tuples_from_points</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a generator for the cubic bezier tuples of this object.</p>
<p>Generator to not materialize a list or np.array needlessly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_cubic_bezier_tuples_from_points(self, points):
    &#34;&#34;&#34;
    Get a generator for the cubic bezier tuples of this object.

    Generator to not materialize a list or np.array needlessly.
    &#34;&#34;&#34;
    nppcc = VMobject.CONFIG[&#34;n_points_per_cubic_curve&#34;]
    remainder = len(points) % nppcc
    points = points[:len(points) - remainder]
    return (
        points[i:i + nppcc]
        for i in range(0, len(points), nppcc)
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.gen_subpaths_from_points_2d"><code class="name flex">
<span>def <span class="ident">gen_subpaths_from_points_2d</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_subpaths_from_points_2d(self, points):
    return self._gen_subpaths_from_points(
            points,
            lambda n: not self.consider_points_equals_2d(
                points[n - 1], points[n]
            ))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array"><code class="name flex">
<span>def <span class="ident">generate_rgbas_array</span></span>(<span>self, color, opacity)</span>
</code></dt>
<dd>
<div class="desc"><p>First arg can be either a color, or a tuple/list of colors.
Likewise, opacity can either be a float, or a tuple of floats.
If self.sheen_factor is not zero, and only
one color was passed in, a second slightly light color
will automatically be added for the gradient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_rgbas_array(self, color, opacity):
    &#34;&#34;&#34;
    First arg can be either a color, or a tuple/list of colors.
    Likewise, opacity can either be a float, or a tuple of floats.
    If self.sheen_factor is not zero, and only
    one color was passed in, a second slightly light color
    will automatically be added for the gradient
    &#34;&#34;&#34;
    colors = list(tuplify(color))
    opacities = list(tuplify(opacity))
    rgbas = np.array([
        color_to_rgba(c, o)
        for c, o in zip(*make_even(colors, opacities))
    ])

    sheen_factor = self.get_sheen_factor()
    if sheen_factor != 0 and len(rgbas) == 1:
        light_rgbas = np.array(rgbas)
        light_rgbas[:, :3] += sheen_factor
        clip_in_place(light_rgbas, 0, 1)
        rgbas = np.append(rgbas, light_rgbas, axis=0)
    return rgbas</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors"><code class="name flex">
<span>def <span class="ident">get_anchors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_anchors(self):
    if self.points.shape[0] == 1:
        return self.points
    return np.array(list(it.chain(*zip(
        self.get_start_anchors(),
        self.get_end_anchors(),
    ))))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles"><code class="name flex">
<span>def <span class="ident">get_anchors_and_handles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns anchors1, handles1, handles2, anchors2,
where (anchors1[i], handles1[i], handles2[i], anchors2[i])
will be four points defining a cubic bezier curve
for any i in range(0, len(anchors1))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_anchors_and_handles(self):
    &#34;&#34;&#34;
    returns anchors1, handles1, handles2, anchors2,
    where (anchors1[i], handles1[i], handles2[i], anchors2[i])
    will be four points defining a cubic bezier curve
    for any i in range(0, len(anchors1))
    &#34;&#34;&#34;
    nppcc = self.n_points_per_cubic_curve
    return [
        self.points[i::nppcc]
        for i in range(nppcc)
    ]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_arc_length"><code class="name flex">
<span>def <span class="ident">get_arc_length</span></span>(<span>self, n_sample_points=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arc_length(self, n_sample_points=None):
    if n_sample_points is None:
        n_sample_points = 4 * self.get_num_curves() + 1
    points = np.array([
        self.point_from_proportion(a)
        for a in np.linspace(0, 1, n_sample_points)
    ])
    diffs = points[1:] - points[:-1]
    norms = np.apply_along_axis(get_norm, 1, diffs)
    return np.sum(norms)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_background_image_file"><code class="name flex">
<span>def <span class="ident">get_background_image_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_background_image_file(self):
    return self.background_image_file</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_color"><code class="name flex">
<span>def <span class="ident">get_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_color(self):
    if np.all(self.get_fill_opacities() == 0):
        return self.get_stroke_color()
    return self.get_fill_color()</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_cubic_bezier_tuples"><code class="name flex">
<span>def <span class="ident">get_cubic_bezier_tuples</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cubic_bezier_tuples(self):
    return self.get_cubic_bezier_tuples_from_points(
        self.get_points()
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_cubic_bezier_tuples_from_points"><code class="name flex">
<span>def <span class="ident">get_cubic_bezier_tuples_from_points</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cubic_bezier_tuples_from_points(self, points):
    return np.array(list(self.gen_cubic_bezier_tuples_from_points(points)))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_end_anchors"><code class="name flex">
<span>def <span class="ident">get_end_anchors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_anchors(self):
    nppcc = self.n_points_per_cubic_curve
    return self.points[nppcc - 1::nppcc]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color"><code class="name flex">
<span>def <span class="ident">get_fill_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If there are multiple colors (for gradient)
this returns the first one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fill_color(self):
    &#34;&#34;&#34;
    If there are multiple colors (for gradient)
    this returns the first one
    &#34;&#34;&#34;
    return self.get_fill_colors()[0]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_colors"><code class="name flex">
<span>def <span class="ident">get_fill_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fill_colors(self):
    return [
        Color(rgb=rgba[:3])
        for rgba in self.get_fill_rgbas()
    ]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacities"><code class="name flex">
<span>def <span class="ident">get_fill_opacities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fill_opacities(self):
    return self.get_fill_rgbas()[:, 3]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity"><code class="name flex">
<span>def <span class="ident">get_fill_opacity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If there are multiple opacities, this returns the
first</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fill_opacity(self):
    &#34;&#34;&#34;
    If there are multiple opacities, this returns the
    first
    &#34;&#34;&#34;
    return self.get_fill_opacities()[0]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_rgbas"><code class="name flex">
<span>def <span class="ident">get_fill_rgbas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fill_rgbas(self):
    try:
        return self.fill_rgbas
    except AttributeError:
        return np.zeros((1, 4))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_gradient_start_and_end_points"><code class="name flex">
<span>def <span class="ident">get_gradient_start_and_end_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gradient_start_and_end_points(self):
    if self.shade_in_3d:
        return get_3d_vmob_gradient_start_and_end_points(self)
    else:
        direction = self.get_sheen_direction()
        c = self.get_center()
        bases = np.array([
            self.get_edge_center(vect) - c
            for vect in [RIGHT, UP, OUT]
        ]).transpose()
        offset = np.dot(bases, direction)
        return (c - offset, c + offset)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_group_class"><code class="name flex">
<span>def <span class="ident">get_group_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group_class(self):
    return VGroup</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_last_point"><code class="name flex">
<span>def <span class="ident">get_last_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_point(self):
    return self.points[-1]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function"><code class="name flex">
<span>def <span class="ident">get_nth_curve_function</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nth_curve_function(self, n):
    return bezier(self.get_nth_curve_points(n))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_nth_curve_points"><code class="name flex">
<span>def <span class="ident">get_nth_curve_points</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nth_curve_points(self, n):
    assert(n &lt; self.get_num_curves())
    nppcc = self.n_points_per_cubic_curve
    return self.points[nppcc * n:nppcc * (n + 1)]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_num_curves"><code class="name flex">
<span>def <span class="ident">get_num_curves</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_curves(self):
    nppcc = self.n_points_per_cubic_curve
    return len(self.points) // nppcc</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_points"><code class="name flex">
<span>def <span class="ident">get_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points(self):
    return np.array(self.points)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_points_defining_boundary"><code class="name flex">
<span>def <span class="ident">get_points_defining_boundary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points_defining_boundary(self):
    return np.array(list(it.chain(*[
        sm.get_anchors()
        for sm in self.get_family()
    ])))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_sheen_direction"><code class="name flex">
<span>def <span class="ident">get_sheen_direction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sheen_direction(self):
    return np.array(self.sheen_direction)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_sheen_factor"><code class="name flex">
<span>def <span class="ident">get_sheen_factor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sheen_factor(self):
    return self.sheen_factor</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_start_anchors"><code class="name flex">
<span>def <span class="ident">get_start_anchors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_anchors(self):
    return self.points[0::self.n_points_per_cubic_curve]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_color"><code class="name flex">
<span>def <span class="ident">get_stroke_color</span></span>(<span>self, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_color(self, background=False):
    return self.get_stroke_colors(background)[0]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_colors"><code class="name flex">
<span>def <span class="ident">get_stroke_colors</span></span>(<span>self, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_colors(self, background=False):
    return [
        Color(rgb=rgba[:3])
        for rgba in self.get_stroke_rgbas(background)
    ]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_opacities"><code class="name flex">
<span>def <span class="ident">get_stroke_opacities</span></span>(<span>self, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_opacities(self, background=False):
    return self.get_stroke_rgbas(background)[:, 3]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_opacity"><code class="name flex">
<span>def <span class="ident">get_stroke_opacity</span></span>(<span>self, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_opacity(self, background=False):
    return self.get_stroke_opacities(background)[0]</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_rgbas"><code class="name flex">
<span>def <span class="ident">get_stroke_rgbas</span></span>(<span>self, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_rgbas(self, background=False):
    try:
        if background:
            rgbas = self.background_stroke_rgbas
        else:
            rgbas = self.stroke_rgbas
        return rgbas
    except AttributeError:
        return np.zeros((1, 4))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_width"><code class="name flex">
<span>def <span class="ident">get_stroke_width</span></span>(<span>self, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_width(self, background=False):
    if background:
        width = self.background_stroke_width
    else:
        width = self.stroke_width
    return max(0, width)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_style"><code class="name flex">
<span>def <span class="ident">get_style</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_style(self):
    return {
        &#34;fill_color&#34;: self.get_fill_colors(),
        &#34;fill_opacity&#34;: self.get_fill_opacities(),
        &#34;stroke_color&#34;: self.get_stroke_colors(),
        &#34;stroke_width&#34;: self.get_stroke_width(),
        &#34;stroke_opacity&#34;: self.get_stroke_opacity(),
        &#34;background_stroke_color&#34;: self.get_stroke_colors(background=True),
        &#34;background_stroke_width&#34;: self.get_stroke_width(background=True),
        &#34;background_stroke_opacity&#34;: self.get_stroke_opacity(background=True),
        &#34;sheen_factor&#34;: self.get_sheen_factor(),
        &#34;sheen_direction&#34;: self.get_sheen_direction(),
        &#34;background_image_file&#34;: self.get_background_image_file(),
    }</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_subcurve"><code class="name flex">
<span>def <span class="ident">get_subcurve</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subcurve(self, a, b):
    vmob = self.copy()
    vmob.pointwise_become_partial(self, a, b)
    return vmob</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_subpaths"><code class="name flex">
<span>def <span class="ident">get_subpaths</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subpaths(self):
    return self.get_subpaths_from_points(self.get_points())</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.get_subpaths_from_points"><code class="name flex">
<span>def <span class="ident">get_subpaths_from_points</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subpaths_from_points(self, points):
    return list(
        self._gen_subpaths_from_points(
            points,
            lambda n: not self.consider_points_equals(
                points[n - 1], points[n]
            ))
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.has_new_path_started"><code class="name flex">
<span>def <span class="ident">has_new_path_started</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_new_path_started(self):
    nppcc = self.n_points_per_cubic_curve  # 4
    return len(self.points) % nppcc == 1</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.init_colors"><code class="name flex">
<span>def <span class="ident">init_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_colors(self):
    self.set_fill(
        color=self.fill_color or self.color,
        opacity=self.fill_opacity,
    )
    self.set_stroke(
        color=self.stroke_color or self.color,
        width=self.stroke_width,
        opacity=self.stroke_opacity,
    )
    self.set_background_stroke(
        color=self.background_stroke_color,
        width=self.background_stroke_width,
        opacity=self.background_stroke_opacity,
    )
    self.set_sheen(
        factor=self.sheen_factor,
        direction=self.sheen_direction,
    )
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.insert_n_curves"><code class="name flex">
<span>def <span class="ident">insert_n_curves</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_n_curves(self, n):
    new_path_point = None
    if self.has_new_path_started():
        new_path_point = self.get_last_point()

    new_points = self.insert_n_curves_to_point_list(
        n, self.get_points()
    )
    self.set_points(new_points)

    if new_path_point is not None:
        self.append_points([new_path_point])
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.insert_n_curves_to_point_list"><code class="name flex">
<span>def <span class="ident">insert_n_curves_to_point_list</span></span>(<span>self, n, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_n_curves_to_point_list(self, n, points):
    if len(points) == 1:
        nppcc = self.n_points_per_cubic_curve
        return np.repeat(points, nppcc * n, 0)
    bezier_quads = self.get_cubic_bezier_tuples_from_points(points)
    curr_num = len(bezier_quads)
    target_num = curr_num + n
    # This is an array with values ranging from 0
    # up to curr_num,  with repeats such that
    # it&#39;s total length is target_num.  For example,
    # with curr_num = 10, target_num = 15, this would
    # be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]
    repeat_indices = (np.arange(target_num) * curr_num) // target_num

    # If the nth term of this list is k, it means
    # that the nth curve of our path should be split
    # into k pieces.  In the above example, this would
    # be [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]
    split_factors = [
        sum(repeat_indices == i)
        for i in range(curr_num)
    ]
    new_points = np.zeros((0, self.dim))
    for quad, sf in zip(bezier_quads, split_factors):
        # What was once a single cubic curve defined
        # by &#34;quad&#34; will now be broken into sf
        # smaller cubic curves
        alphas = np.linspace(0, 1, sf + 1)
        for a1, a2 in zip(alphas, alphas[1:]):
            new_points = np.append(
                new_points,
                partial_bezier_points(quad, a1, a2),
                axis=0
            )
    return new_points</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate_color"><code class="name flex">
<span>def <span class="ident">interpolate_color</span></span>(<span>self, mobject1, mobject2, alpha)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_color(self, mobject1, mobject2, alpha):
    attrs = [
        &#34;fill_rgbas&#34;,
        &#34;stroke_rgbas&#34;,
        &#34;background_stroke_rgbas&#34;,
        &#34;stroke_width&#34;,
        &#34;background_stroke_width&#34;,
        &#34;sheen_direction&#34;,
        &#34;sheen_factor&#34;,
    ]
    for attr in attrs:
        setattr(self, attr, interpolate(
            getattr(mobject1, attr),
            getattr(mobject2, attr),
            alpha
        ))
        if alpha == 1.0:
            setattr(self, attr, getattr(mobject2, attr))</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closed(self):
    return self.consider_points_equals(
        self.points[0], self.points[-1]
    )</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.make_jagged"><code class="name flex">
<span>def <span class="ident">make_jagged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_jagged(self):
    return self.change_anchor_mode(&#34;jagged&#34;)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.make_smooth"><code class="name flex">
<span>def <span class="ident">make_smooth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_smooth(self):
    return self.change_anchor_mode(&#34;smooth&#34;)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.match_background_image_file"><code class="name flex">
<span>def <span class="ident">match_background_image_file</span></span>(<span>self, vmobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_background_image_file(self, vmobject):
    self.color_using_background_image(vmobject.get_background_image_file())
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.match_style"><code class="name flex">
<span>def <span class="ident">match_style</span></span>(<span>self, vmobject, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_style(self, vmobject, family=True):
    self.set_style(**vmobject.get_style(), family=False)

    if family:
        # Does its best to match up submobject lists, and
        # match styles accordingly
        submobs1, submobs2 = self.submobjects, vmobject.submobjects
        if len(submobs1) == 0:
            return self
        elif len(submobs2) == 0:
            submobs2 = [vmobject]
        for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
            sm1.match_style(sm2)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.point_from_proportion"><code class="name flex">
<span>def <span class="ident">point_from_proportion</span></span>(<span>self, alpha)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_from_proportion(self, alpha):
    num_cubics = self.get_num_curves()
    n, residue = integer_interpolate(0, num_cubics, alpha)
    curve = self.get_nth_curve_function(n)
    return curve(residue)</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.pointwise_become_partial"><code class="name flex">
<span>def <span class="ident">pointwise_become_partial</span></span>(<span>self, vmobject, a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pointwise_become_partial(self, vmobject, a, b):
    assert(isinstance(vmobject, VMobject))
    # Partial curve includes three portions:
    # - A middle section, which matches the curve exactly
    # - A start, which is some ending portion of an inner cubic
    # - An end, which is the starting portion of a later inner cubic
    if a &lt;= 0 and b &gt;= 1:
        self.set_points(vmobject.points)
        return self
    bezier_quads = vmobject.get_cubic_bezier_tuples()
    num_cubics = len(bezier_quads)

    lower_index, lower_residue = integer_interpolate(0, num_cubics, a)
    upper_index, upper_residue = integer_interpolate(0, num_cubics, b)

    self.clear_points()
    if num_cubics == 0:
        return self
    if lower_index == upper_index:
        self.append_points(partial_bezier_points(
            bezier_quads[lower_index],
            lower_residue, upper_residue
        ))
    else:
        self.append_points(partial_bezier_points(
            bezier_quads[lower_index], lower_residue, 1
        ))
        for quad in bezier_quads[lower_index + 1:upper_index]:
            self.append_points(quad)
        self.append_points(partial_bezier_points(
            bezier_quads[upper_index], 0, upper_residue
        ))
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances"><code class="name flex">
<span>def <span class="ident">scale_handle_to_anchor_distances</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<div class="desc"><p>If the distance between a given handle point H and its associated
anchor point A is d, then it changes H to be a distances factor*d
away from A, but so that the line from A to H doesn't change.
This is mostly useful in the context of applying a (differentiable)
function, to preserve tangency properties.
One would pull all the
handles closer to their anchors, apply the function then push them out
again.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_handle_to_anchor_distances(self, factor):
    &#34;&#34;&#34;
    If the distance between a given handle point H and its associated
    anchor point A is d, then it changes H to be a distances factor*d
    away from A, but so that the line from A to H doesn&#39;t change.
    This is mostly useful in the context of applying a (differentiable)
    function, to preserve tangency properties.  One would pull all the
    handles closer to their anchors, apply the function then push them out
    again.
    &#34;&#34;&#34;
    for submob in self.family_members_with_points():
        if len(submob.points) &lt; self.n_points_per_cubic_curve:
            continue
        a1, h1, h2, a2 = submob.get_anchors_and_handles()
        a1_to_h1 = h1 - a1
        a2_to_h2 = h2 - a2
        new_h1 = a1 + factor * a1_to_h1
        new_h2 = a2 + factor * a2_to_h2
        submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_anchors_and_handles"><code class="name flex">
<span>def <span class="ident">set_anchors_and_handles</span></span>(<span>self, anchors1, handles1, handles2, anchors2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_anchors_and_handles(self, anchors1, handles1, handles2, anchors2):
    assert(len(anchors1) == len(handles1) == len(handles2) == len(anchors2))
    nppcc = self.n_points_per_cubic_curve  # 4
    total_len = nppcc * len(anchors1)
    self.points = np.zeros((total_len, self.dim))
    arrays = [anchors1, handles1, handles2, anchors2]
    for index, array in enumerate(arrays):
        self.points[index::nppcc] = array
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_background_stroke"><code class="name flex">
<span>def <span class="ident">set_background_stroke</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_background_stroke(self, **kwargs):
    kwargs[&#34;background&#34;] = True
    self.set_stroke(**kwargs)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_fill"><code class="name flex">
<span>def <span class="ident">set_fill</span></span>(<span>self, color=None, opacity=None, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fill(self, color=None, opacity=None, family=True):
    if family:
        for submobject in self.submobjects:
            submobject.set_fill(color, opacity, family)
    self.update_rgbas_array(&#34;fill_rgbas&#34;, color, opacity)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_opacity"><code class="name flex">
<span>def <span class="ident">set_opacity</span></span>(<span>self, opacity, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_opacity(self, opacity, family=True):
    self.set_fill(opacity=opacity, family=family)
    self.set_stroke(opacity=opacity, family=family)
    self.set_stroke(opacity=opacity, family=family, background=True)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_points"><code class="name flex">
<span>def <span class="ident">set_points</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_points(self, points):
    self.points = np.array(points)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_points_as_corners"><code class="name flex">
<span>def <span class="ident">set_points_as_corners</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_points_as_corners(self, points):
    nppcc = self.n_points_per_cubic_curve
    points = np.array(points)
    self.set_anchors_and_handles(*[
        interpolate(points[:-1], points[1:], a)
        for a in np.linspace(0, 1, nppcc)
    ])
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_points_smoothly"><code class="name flex">
<span>def <span class="ident">set_points_smoothly</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_points_smoothly(self, points):
    self.set_points_as_corners(points)
    self.make_smooth()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_shade_in_3d"><code class="name flex">
<span>def <span class="ident">set_shade_in_3d</span></span>(<span>self, value=True, z_index_as_group=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_shade_in_3d(self, value=True, z_index_as_group=False):
    for submob in self.get_family():
        submob.shade_in_3d = value
        if z_index_as_group:
            submob.z_index_group = self
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_sheen"><code class="name flex">
<span>def <span class="ident">set_sheen</span></span>(<span>self, factor, direction=None, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sheen(self, factor, direction=None, family=True):
    if family:
        for submob in self.submobjects:
            submob.set_sheen(factor, direction, family)
    self.sheen_factor = factor
    if direction is not None:
        # family set to false because recursion will
        # already be handled above
        self.set_sheen_direction(direction, family=False)
    # Reset color to put sheen_factor into effect
    if factor != 0:
        self.set_stroke(self.get_stroke_color(), family=family)
        self.set_fill(self.get_fill_color(), family=family)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_sheen_direction"><code class="name flex">
<span>def <span class="ident">set_sheen_direction</span></span>(<span>self, direction, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sheen_direction(self, direction, family=True):
    direction = np.array(direction)
    if family:
        for submob in self.get_family():
            submob.sheen_direction = direction
    else:
        self.sheen_direction = direction
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_stroke"><code class="name flex">
<span>def <span class="ident">set_stroke</span></span>(<span>self, color=None, width=None, opacity=None, background=False, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stroke(self, color=None, width=None, opacity=None,
               background=False, family=True):
    if family:
        for submobject in self.submobjects:
            submobject.set_stroke(
                color, width, opacity, background, family
            )
    if background:
        array_name = &#34;background_stroke_rgbas&#34;
        width_name = &#34;background_stroke_width&#34;
    else:
        array_name = &#34;stroke_rgbas&#34;
        width_name = &#34;stroke_width&#34;
    self.update_rgbas_array(array_name, color, opacity)
    if width is not None:
        setattr(self, width_name, width)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.set_style"><code class="name flex">
<span>def <span class="ident">set_style</span></span>(<span>self, fill_color=None, fill_opacity=None, stroke_color=None, stroke_width=None, stroke_opacity=None, background_stroke_color=None, background_stroke_width=None, background_stroke_opacity=None, sheen_factor=None, sheen_direction=None, background_image_file=None, family=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_style(self,
              fill_color=None,
              fill_opacity=None,
              stroke_color=None,
              stroke_width=None,
              stroke_opacity=None,
              background_stroke_color=None,
              background_stroke_width=None,
              background_stroke_opacity=None,
              sheen_factor=None,
              sheen_direction=None,
              background_image_file=None,
              family=True):
    self.set_fill(
        color=fill_color,
        opacity=fill_opacity,
        family=family
    )
    self.set_stroke(
        color=stroke_color,
        width=stroke_width,
        opacity=stroke_opacity,
        family=family,
    )
    self.set_background_stroke(
        color=background_stroke_color,
        width=background_stroke_width,
        opacity=background_stroke_opacity,
        family=family,
    )
    if sheen_factor:
        self.set_sheen(
            factor=sheen_factor,
            direction=sheen_direction,
            family=family,
        )
    if background_image_file:
        self.color_using_background_image(background_image_file)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.start_new_path"><code class="name flex">
<span>def <span class="ident">start_new_path</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_new_path(self, point):
    # TODO, make sure that len(self.points) % 4 == 0?
    self.append_points([point])
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VMobject.update_rgbas_array"><code class="name flex">
<span>def <span class="ident">update_rgbas_array</span></span>(<span>self, array_name, color=None, opacity=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_rgbas_array(self, array_name, color=None, opacity=None):
    passed_color = color if (color is not None) else BLACK
    passed_opacity = opacity if (opacity is not None) else 0
    rgbas = self.generate_rgbas_array(passed_color, passed_opacity)
    if not hasattr(self, array_name):
        setattr(self, array_name, rgbas)
        return self
    # Match up current rgbas array with the newly calculated
    # one. 99% of the time they&#39;ll be the same.
    curr_rgbas = getattr(self, array_name)
    if len(curr_rgbas) &lt; len(rgbas):
        curr_rgbas = stretch_array_to_length(
            curr_rgbas, len(rgbas)
        )
        setattr(self, array_name, curr_rgbas)
    elif len(rgbas) &lt; len(curr_rgbas):
        rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))
    # Only update rgb if color was not None, and only
    # update alpha channel if opacity was passed in
    if color is not None:
        curr_rgbas[:, :3] = rgbas[:, :3]
    if opacity is not None:
        curr_rgbas[:, 3] = rgbas[:, 3]
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.mobject.Mobject.add" href="../../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_on_border" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.align_to" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.become" href="../mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.become_partial" href="../mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.digest_mobject_attrs" href="../mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_coord" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_critical_point" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.get_point_mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.interpolate" href="../mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.null_point_align" href="../mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.remove" href="../../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.repeat" href="../mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.scale" href="../mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.mobject.Mobject.set_color" href="../mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VectorizedPoint"><code class="flex name class">
<span>class <span class="ident">VectorizedPoint</span></span>
<span>(</span><span>location=array([0., 0., 0.]), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorizedPoint(VMobject):
    CONFIG = {
        &#34;color&#34;: BLACK,
        &#34;fill_opacity&#34;: 0,
        &#34;stroke_width&#34;: 0,
        &#34;artificial_width&#34;: 0.01,
        &#34;artificial_height&#34;: 0.01,
    }

    def __init__(self, location=ORIGIN, **kwargs):
        VMobject.__init__(self, **kwargs)
        self.set_points(np.array([location]))

    def get_width(self):
        return self.artificial_width

    def get_height(self):
        return self.artificial_height

    def get_location(self):
        return np.array(self.points[0])

    def set_location(self, new_loc):
        self.set_points(np.array([new_loc]))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_height"><code class="name flex">
<span>def <span class="ident">get_height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_height(self):
    return self.artificial_height</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_location"><code class="name flex">
<span>def <span class="ident">get_location</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_location(self):
    return np.array(self.points[0])</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_width"><code class="name flex">
<span>def <span class="ident">get_width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width(self):
    return self.artificial_width</code></pre>
</details>
</dd>
<dt id="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.set_location"><code class="name flex">
<span>def <span class="ident">set_location</span></span>(<span>self, new_loc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_location(self, new_loc):
    self.set_points(np.array([new_loc]))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.mobject.types" href="index.html">manimlib.mobject.types</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.mobject.types.vectorized_mobject.CurvesAsSubmobjects" href="#manimlib.mobject.types.vectorized_mobject.CurvesAsSubmobjects">CurvesAsSubmobjects</a></code></h4>
</li>
<li>
<h4><code><a title="manimlib.mobject.types.vectorized_mobject.DashedVMobject" href="#manimlib.mobject.types.vectorized_mobject.DashedVMobject">DashedVMobject</a></code></h4>
<ul class="">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.DashedVMobject.CONFIG" href="#manimlib.mobject.types.vectorized_mobject.DashedVMobject.CONFIG">CONFIG</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.mobject.types.vectorized_mobject.VGroup" href="#manimlib.mobject.types.vectorized_mobject.VGroup">VGroup</a></code></h4>
</li>
<li>
<h4><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></code></h4>
<ul class="">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.CONFIG" href="#manimlib.mobject.types.vectorized_mobject.VMobject.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve">add_cubic_bezier_curve</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_line_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_line_to">add_line_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_points_as_corners" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_points_as_corners">add_points_as_corners</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_subpath" href="#manimlib.mobject.types.vectorized_mobject.VMobject.add_subpath">add_subpath</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.align_points">align_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_rgbas" href="#manimlib.mobject.types.vectorized_mobject.VMobject.align_rgbas">align_rgbas</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.append_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.append_points">append_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.append_vectorized_mobject" href="#manimlib.mobject.types.vectorized_mobject.VMobject.append_vectorized_mobject">append_vectorized_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.apply_function" href="#manimlib.mobject.types.vectorized_mobject.VMobject.apply_function">apply_function</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.change_anchor_mode" href="#manimlib.mobject.types.vectorized_mobject.VMobject.change_anchor_mode">change_anchor_mode</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.clear_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.clear_points">clear_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.color_using_background_image" href="#manimlib.mobject.types.vectorized_mobject.VMobject.color_using_background_image">color_using_background_image</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals" href="#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals">consider_points_equals</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.fade" href="#manimlib.mobject.types.vectorized_mobject.VMobject.fade">fade</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_subpaths_from_points_2d" href="#manimlib.mobject.types.vectorized_mobject.VMobject.gen_subpaths_from_points_2d">gen_subpaths_from_points_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors">get_anchors</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_arc_length" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_arc_length">get_arc_length</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_background_image_file" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_background_image_file">get_background_image_file</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_color">get_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_cubic_bezier_tuples" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_cubic_bezier_tuples">get_cubic_bezier_tuples</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_cubic_bezier_tuples_from_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_cubic_bezier_tuples_from_points">get_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_end_anchors" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_end_anchors">get_end_anchors</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_colors" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_colors">get_fill_colors</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacities" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacities">get_fill_opacities</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_rgbas" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_rgbas">get_fill_rgbas</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_gradient_start_and_end_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_gradient_start_and_end_points">get_gradient_start_and_end_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_group_class" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_group_class">get_group_class</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_last_point" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_last_point">get_last_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function">get_nth_curve_function</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_nth_curve_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_nth_curve_points">get_nth_curve_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_num_curves" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_num_curves">get_num_curves</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_points">get_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_points_defining_boundary" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_points_defining_boundary">get_points_defining_boundary</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_sheen_direction" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_sheen_direction">get_sheen_direction</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_sheen_factor" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_sheen_factor">get_sheen_factor</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_start_anchors" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_start_anchors">get_start_anchors</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_color">get_stroke_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_colors" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_colors">get_stroke_colors</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_opacities" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_opacities">get_stroke_opacities</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_opacity" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_opacity">get_stroke_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_rgbas" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_rgbas">get_stroke_rgbas</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_width" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_stroke_width">get_stroke_width</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_style" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_style">get_style</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_subcurve" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_subcurve">get_subcurve</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_subpaths" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_subpaths">get_subpaths</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_subpaths_from_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.get_subpaths_from_points">get_subpaths_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.has_new_path_started" href="#manimlib.mobject.types.vectorized_mobject.VMobject.has_new_path_started">has_new_path_started</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.init_colors" href="#manimlib.mobject.types.vectorized_mobject.VMobject.init_colors">init_colors</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.insert_n_curves" href="#manimlib.mobject.types.vectorized_mobject.VMobject.insert_n_curves">insert_n_curves</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.insert_n_curves_to_point_list" href="#manimlib.mobject.types.vectorized_mobject.VMobject.insert_n_curves_to_point_list">insert_n_curves_to_point_list</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate_color" href="#manimlib.mobject.types.vectorized_mobject.VMobject.interpolate_color">interpolate_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.is_closed" href="#manimlib.mobject.types.vectorized_mobject.VMobject.is_closed">is_closed</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.make_jagged" href="#manimlib.mobject.types.vectorized_mobject.VMobject.make_jagged">make_jagged</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.make_smooth" href="#manimlib.mobject.types.vectorized_mobject.VMobject.make_smooth">make_smooth</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.match_background_image_file" href="#manimlib.mobject.types.vectorized_mobject.VMobject.match_background_image_file">match_background_image_file</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.match_style" href="#manimlib.mobject.types.vectorized_mobject.VMobject.match_style">match_style</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.point_from_proportion" href="#manimlib.mobject.types.vectorized_mobject.VMobject.point_from_proportion">point_from_proportion</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.pointwise_become_partial" href="#manimlib.mobject.types.vectorized_mobject.VMobject.pointwise_become_partial">pointwise_become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_anchors_and_handles" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_anchors_and_handles">set_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_background_stroke" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_background_stroke">set_background_stroke</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_fill" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_fill">set_fill</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_opacity" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_opacity">set_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_points" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_points">set_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_points_as_corners" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_points_as_corners">set_points_as_corners</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_points_smoothly" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_points_smoothly">set_points_smoothly</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_shade_in_3d" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_shade_in_3d">set_shade_in_3d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_sheen" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_sheen">set_sheen</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_sheen_direction" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_sheen_direction">set_sheen_direction</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_stroke" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_stroke">set_stroke</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_style" href="#manimlib.mobject.types.vectorized_mobject.VMobject.set_style">set_style</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.start_new_path" href="#manimlib.mobject.types.vectorized_mobject.VMobject.start_new_path">start_new_path</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.update_rgbas_array" href="#manimlib.mobject.types.vectorized_mobject.VMobject.update_rgbas_array">update_rgbas_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.mobject.types.vectorized_mobject.VectorizedPoint" href="#manimlib.mobject.types.vectorized_mobject.VectorizedPoint">VectorizedPoint</a></code></h4>
<ul class="">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.CONFIG" href="#manimlib.mobject.types.vectorized_mobject.VectorizedPoint.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_height" href="#manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_height">get_height</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_location" href="#manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_location">get_location</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_width" href="#manimlib.mobject.types.vectorized_mobject.VectorizedPoint.get_width">get_width</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VectorizedPoint.set_location" href="#manimlib.mobject.types.vectorized_mobject.VectorizedPoint.set_location">set_location</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>