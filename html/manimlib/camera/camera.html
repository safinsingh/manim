<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.camera.camera API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.camera.camera</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from functools import reduce
import itertools as it
import operator as op
import time
import copy

from PIL import Image
from scipy.spatial.distance import pdist
import cairo
import numpy as np

from manimlib.constants import *
from manimlib.mobject.types.image_mobject import AbstractImageMobject
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.types.point_cloud_mobject import PMobject
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.color import color_to_int_rgba
from manimlib.utils.config_ops import digest_config
from manimlib.utils.images import get_full_raster_image_path
from manimlib.utils.iterables import batch_by_property
from manimlib.utils.iterables import list_difference_update
from manimlib.utils.iterables import remove_list_redundancies
from manimlib.utils.simple_functions import fdiv
from manimlib.utils.space_ops import angle_of_vector
from manimlib.utils.space_ops import get_norm


class Camera(object):
    CONFIG = {
        &#34;background_image&#34;: None,
        &#34;pixel_height&#34;: DEFAULT_PIXEL_HEIGHT,
        &#34;pixel_width&#34;: DEFAULT_PIXEL_WIDTH,
        &#34;frame_rate&#34;: DEFAULT_FRAME_RATE,
        # Note: frame height and width will be resized to match
        # the pixel aspect ratio
        &#34;frame_height&#34;: FRAME_HEIGHT,
        &#34;frame_width&#34;: FRAME_WIDTH,
        &#34;frame_center&#34;: ORIGIN,
        &#34;background_color&#34;: &#34;#0e0e0e&#34;,
        &#34;background_opacity&#34;: 1,
        # Points in vectorized mobjects with norm greater
        # than this value will be rescaled.
        &#34;max_allowable_norm&#34;: FRAME_WIDTH,
        &#34;image_mode&#34;: &#34;RGBA&#34;,
        &#34;n_channels&#34;: 4,
        &#34;pixel_array_dtype&#34;: &#39;uint8&#39;,
        # z_buff_func is only used if the flag above is set to True.
        # round z coordinate to nearest hundredth when comparring
        &#34;z_buff_func&#34;: lambda m: np.round(m.get_center()[2], 2),
        &#34;cairo_line_width_multiple&#34;: 0.01,
    }

    def __init__(self, background=None, **kwargs):
        digest_config(self, kwargs, locals())
        self.rgb_max_val = np.iinfo(self.pixel_array_dtype).max
        self.pixel_array_to_cairo_context = {}
        self.init_background()
        self.resize_frame_shape()
        self.reset()

    def __deepcopy__(self, memo):
        # This is to address a strange bug where deepcopying
        # will result in a segfault, which is somehow related
        # to the aggdraw library
        self.canvas = None
        return copy.copy(self)

    def reset_pixel_shape(self, new_height, new_width):
        self.pixel_width = new_width
        self.pixel_height = new_height
        self.init_background()
        self.resize_frame_shape()
        self.reset()

    def get_pixel_height(self):
        return self.pixel_height

    def get_pixel_width(self):
        return self.pixel_width

    def get_frame_height(self):
        return self.frame_height

    def get_frame_width(self):
        return self.frame_width

    def get_frame_center(self):
        return self.frame_center

    def set_frame_height(self, frame_height):
        self.frame_height = frame_height

    def set_frame_width(self, frame_width):
        self.frame_width = frame_width

    def set_frame_center(self, frame_center):
        self.frame_center = frame_center

    def resize_frame_shape(self, fixed_dimension=0):
        &#34;&#34;&#34;
        Changes frame_shape to match the aspect ratio
        of the pixels, where fixed_dimension determines
        whether frame_height or frame_width
        remains fixed while the other changes accordingly.
        &#34;&#34;&#34;
        pixel_height = self.get_pixel_height()
        pixel_width = self.get_pixel_width()
        frame_height = self.get_frame_height()
        frame_width = self.get_frame_width()
        aspect_ratio = fdiv(pixel_width, pixel_height)
        if fixed_dimension == 0:
            frame_height = frame_width / aspect_ratio
        else:
            frame_width = aspect_ratio * frame_height
        self.set_frame_height(frame_height)
        self.set_frame_width(frame_width)

    def init_background(self):
        height = self.get_pixel_height()
        width = self.get_pixel_width()
        if self.background_image is not None:
            path = get_full_raster_image_path(self.background_image)
            image = Image.open(path).convert(self.image_mode)
            # TODO, how to gracefully handle backgrounds
            # with different sizes?
            self.background = np.array(image)[:height, :width]
            self.background = self.background.astype(self.pixel_array_dtype)
        else:
            background_rgba = color_to_int_rgba(
                self.background_color, self.background_opacity
            )
            self.background = np.zeros(
                (height, width, self.n_channels),
                dtype=self.pixel_array_dtype
            )
            self.background[:, :] = background_rgba

    def get_image(self, pixel_array=None):
        if pixel_array is None:
            pixel_array = self.pixel_array
        return Image.fromarray(
            pixel_array,
            mode=self.image_mode
        )

    def get_pixel_array(self):
        return self.pixel_array

    def convert_pixel_array(self, pixel_array, convert_from_floats=False):
        retval = np.array(pixel_array)
        if convert_from_floats:
            retval = np.apply_along_axis(
                lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),
                2,
                retval
            )
        return retval

    def set_pixel_array(self, pixel_array, convert_from_floats=False):
        converted_array = self.convert_pixel_array(
            pixel_array, convert_from_floats)
        if not (hasattr(self, &#34;pixel_array&#34;) and self.pixel_array.shape == converted_array.shape):
            self.pixel_array = converted_array
        else:
            # Set in place
            self.pixel_array[:, :, :] = converted_array[:, :, :]

    def set_background(self, pixel_array, convert_from_floats=False):
        self.background = self.convert_pixel_array(
            pixel_array, convert_from_floats)

    # TODO, this should live in utils, not as a method of Camera
    def make_background_from_func(self, coords_to_colors_func):
        &#34;&#34;&#34;
        Sets background by using coords_to_colors_func to determine each pixel&#39;s color. Each input
        to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not
        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.
        &#34;&#34;&#34;

        print(&#34;Starting set_background; for reference, the current time is &#34;, time.strftime(&#34;%H:%M:%S&#34;))
        coords = self.get_coords_of_all_pixels()
        new_background = np.apply_along_axis(
            coords_to_colors_func,
            2,
            coords
        )
        print(&#34;Ending set_background; for reference, the current time is &#34;, time.strftime(&#34;%H:%M:%S&#34;))

        return self.convert_pixel_array(new_background, convert_from_floats=True)

    def set_background_from_func(self, coords_to_colors_func):
        self.set_background(
            self.make_background_from_func(coords_to_colors_func))

    def reset(self):
        self.set_pixel_array(self.background)
        return self

    ####

    # TODO, it&#39;s weird that this is part of camera.
    # Clearly it should live elsewhere.
    def extract_mobject_family_members(
            self, mobjects,
            only_those_with_points=False):
        if only_those_with_points:
            method = Mobject.family_members_with_points
        else:
            method = Mobject.get_family
        return remove_list_redundancies(list(
            it.chain(*[method(m) for m in mobjects])
        ))

    def get_mobjects_to_display(
            self, mobjects,
            include_submobjects=True,
            excluded_mobjects=None):
        if include_submobjects:
            mobjects = self.extract_mobject_family_members(
                mobjects, only_those_with_points=True,
            )
            if excluded_mobjects:
                all_excluded = self.extract_mobject_family_members(
                    excluded_mobjects
                )
                mobjects = list_difference_update(mobjects, all_excluded)
        return mobjects

    def is_in_frame(self, mobject):
        fc = self.get_frame_center()
        fh = self.get_frame_height()
        fw = self.get_frame_width()
        return not reduce(op.or_, [
            mobject.get_right()[0] &lt; fc[0] - fw,
            mobject.get_bottom()[1] &gt; fc[1] + fh,
            mobject.get_left()[0] &gt; fc[0] + fw,
            mobject.get_top()[1] &lt; fc[1] - fh,
        ])

    def capture_mobject(self, mobject, **kwargs):
        return self.capture_mobjects([mobject], **kwargs)

    def capture_mobjects(self, mobjects, **kwargs):
        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)

        # Organize this list into batches of the same type, and
        # apply corresponding function to those batches
        type_func_pairs = [
            (VMobject, self.display_multiple_vectorized_mobjects),
            (PMobject, self.display_multiple_point_cloud_mobjects),
            (AbstractImageMobject, self.display_multiple_image_mobjects),
            (Mobject, lambda batch, pa: batch),  # Do nothing
        ]

        def get_mobject_type(mobject):
            for mobject_type, func in type_func_pairs:
                if isinstance(mobject, mobject_type):
                    return mobject_type
            raise Exception(
                &#34;Trying to display something which is not of type Mobject&#34;
            )
        batch_type_pairs = batch_by_property(mobjects, get_mobject_type)

        # Display in these batches
        for batch, batch_type in batch_type_pairs:
            # check what the type is, and call the appropriate function
            for mobject_type, func in type_func_pairs:
                if batch_type == mobject_type:
                    func(batch, self.pixel_array)

    # Methods associated with svg rendering

    def get_cached_cairo_context(self, pixel_array):
        return self.pixel_array_to_cairo_context.get(
            id(pixel_array), None
        )

    def cache_cairo_context(self, pixel_array, ctx):
        self.pixel_array_to_cairo_context[id(pixel_array)] = ctx

    def get_cairo_context(self, pixel_array):
        cached_ctx = self.get_cached_cairo_context(pixel_array)
        if cached_ctx:
            return cached_ctx
        pw = self.get_pixel_width()
        ph = self.get_pixel_height()
        fw = self.get_frame_width()
        fh = self.get_frame_height()
        fc = self.get_frame_center()
        surface = cairo.ImageSurface.create_for_data(
            pixel_array,
            cairo.FORMAT_ARGB32,
            pw, ph
        )
        ctx = cairo.Context(surface)
        ctx.scale(pw, ph)
        ctx.set_matrix(cairo.Matrix(
            fdiv(pw, fw), 0,
            0, -fdiv(ph, fh),
            (pw / 2) - fc[0] * fdiv(pw, fw),
            (ph / 2) + fc[1] * fdiv(ph, fh),
        ))
        self.cache_cairo_context(pixel_array, ctx)
        return ctx

    def display_multiple_vectorized_mobjects(self, vmobjects, pixel_array):
        if len(vmobjects) == 0:
            return
        batch_file_pairs = batch_by_property(
            vmobjects,
            lambda vm: vm.get_background_image_file()
        )
        for batch, file_name in batch_file_pairs:
            if file_name:
                self.display_multiple_background_colored_vmobject(batch, pixel_array)
            else:
                self.display_multiple_non_background_colored_vmobjects(batch, pixel_array)

    def display_multiple_non_background_colored_vmobjects(self, vmobjects, pixel_array):
        ctx = self.get_cairo_context(pixel_array)
        for vmobject in vmobjects:
            self.display_vectorized(vmobject, ctx)

    def display_vectorized(self, vmobject, ctx):
        self.set_cairo_context_path(ctx, vmobject)
        self.apply_stroke(ctx, vmobject, background=True)
        self.apply_fill(ctx, vmobject)
        self.apply_stroke(ctx, vmobject)
        return self

    def set_cairo_context_path(self, ctx, vmobject):
        points = self.transform_points_pre_display(
            vmobject, vmobject.points
        )
        # TODO, shouldn&#39;t this be handled in transform_points_pre_display?
        # points = points - self.get_frame_center()
        if len(points) == 0:
            return

        ctx.new_path()
        subpaths = vmobject.gen_subpaths_from_points_2d(points)
        for subpath in subpaths:
            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)
            ctx.new_sub_path()
            start = subpath[0]
            ctx.move_to(*start[:2])
            for p0, p1, p2, p3 in quads:
                ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])
            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):
                ctx.close_path()
        return self

    def set_cairo_context_color(self, ctx, rgbas, vmobject):
        if len(rgbas) == 1:
            # Use reversed rgb because cairo surface is
            # encodes it in reverse order
            ctx.set_source_rgba(
                *rgbas[0][2::-1], rgbas[0][3]
            )
        else:
            points = vmobject.get_gradient_start_and_end_points()
            points = self.transform_points_pre_display(
                vmobject, points
            )
            pat = cairo.LinearGradient(*it.chain(*[
                point[:2] for point in points
            ]))
            step = 1.0 / (len(rgbas) - 1)
            offsets = np.arange(0, 1 + step, step)
            for rgba, offset in zip(rgbas, offsets):
                pat.add_color_stop_rgba(
                    offset, *rgba[2::-1], rgba[3]
                )
            ctx.set_source(pat)
        return self

    def apply_fill(self, ctx, vmobject):
        self.set_cairo_context_color(
            ctx, self.get_fill_rgbas(vmobject), vmobject
        )
        ctx.fill_preserve()
        return self

    def apply_stroke(self, ctx, vmobject, background=False):
        width = vmobject.get_stroke_width(background)
        if width == 0:
            return self
        self.set_cairo_context_color(
            ctx,
            self.get_stroke_rgbas(vmobject, background=background),
            vmobject
        )
        ctx.set_line_width(
            width * self.cairo_line_width_multiple *
            # This ensures lines have constant width
            # as you zoom in on them.
            (self.get_frame_width() / FRAME_WIDTH)
        )
        ctx.stroke_preserve()
        return self

    def get_stroke_rgbas(self, vmobject, background=False):
        return vmobject.get_stroke_rgbas(background)

    def get_fill_rgbas(self, vmobject):
        return vmobject.get_fill_rgbas()

    def get_background_colored_vmobject_displayer(self):
        # Quite wordy to type out a bunch
        bcvd = &#34;background_colored_vmobject_displayer&#34;
        if not hasattr(self, bcvd):
            setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))
        return getattr(self, bcvd)

    def display_multiple_background_colored_vmobject(self, cvmobjects, pixel_array):
        displayer = self.get_background_colored_vmobject_displayer()
        cvmobject_pixel_array = displayer.display(*cvmobjects)
        self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)
        return self

    # Methods for other rendering

    def display_multiple_point_cloud_mobjects(self, pmobjects, pixel_array):
        for pmobject in pmobjects:
            self.display_point_cloud(
                pmobject,
                pmobject.points,
                pmobject.rgbas,
                self.adjusted_thickness(pmobject.stroke_width),
                pixel_array,
            )

    def display_point_cloud(self, pmobject, points, rgbas, thickness, pixel_array):
        if len(points) == 0:
            return
        pixel_coords = self.points_to_pixel_coords(
            pmobject, points
        )
        pixel_coords = self.thickened_coordinates(
            pixel_coords, thickness
        )
        rgba_len = pixel_array.shape[2]

        rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)
        target_len = len(pixel_coords)
        factor = target_len // len(rgbas)
        rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))

        on_screen_indices = self.on_screen_pixels(pixel_coords)
        pixel_coords = pixel_coords[on_screen_indices]
        rgbas = rgbas[on_screen_indices]

        ph = self.get_pixel_height()
        pw = self.get_pixel_width()

        flattener = np.array([1, pw], dtype=&#39;int&#39;)
        flattener = flattener.reshape((2, 1))
        indices = np.dot(pixel_coords, flattener)[:, 0]
        indices = indices.astype(&#39;int&#39;)

        new_pa = pixel_array.reshape((ph * pw, rgba_len))
        new_pa[indices] = rgbas
        pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))

    def display_multiple_image_mobjects(self, image_mobjects, pixel_array):
        for image_mobject in image_mobjects:
            self.display_image_mobject(image_mobject, pixel_array)

    def display_image_mobject(self, image_mobject, pixel_array):
        corner_coords = self.points_to_pixel_coords(
            image_mobject, image_mobject.points
        )
        ul_coords, ur_coords, dl_coords = corner_coords
        right_vect = ur_coords - ul_coords
        down_vect = dl_coords - ul_coords
        center_coords = ul_coords + (right_vect + down_vect) / 2

        sub_image = Image.fromarray(
            image_mobject.get_pixel_array(),
            mode=&#34;RGBA&#34;
        )

        # Reshape
        pixel_width = max(int(pdist([ul_coords, ur_coords])), 1)
        pixel_height = max(int(pdist([ul_coords, dl_coords])), 1)
        sub_image = sub_image.resize(
            (pixel_width, pixel_height), resample=Image.BICUBIC
        )

        # Rotate
        angle = angle_of_vector(right_vect)
        adjusted_angle = -int(360 * angle / TAU)
        if adjusted_angle != 0:
            sub_image = sub_image.rotate(
                adjusted_angle, resample=Image.BICUBIC, expand=1
            )

        # TODO, there is no accounting for a shear...

        # Paste into an image as large as the camear&#39;s pixel array
        full_image = Image.fromarray(
            np.zeros((self.get_pixel_height(), self.get_pixel_width())),
            mode=&#34;RGBA&#34;
        )
        new_ul_coords = center_coords - np.array(sub_image.size) / 2
        new_ul_coords = new_ul_coords.astype(int)
        full_image.paste(
            sub_image,
            box=(
                new_ul_coords[0],
                new_ul_coords[1],
                new_ul_coords[0] + sub_image.size[0],
                new_ul_coords[1] + sub_image.size[1],
            )
        )
        # Paint on top of existing pixel array
        self.overlay_PIL_image(pixel_array, full_image)

    def overlay_rgba_array(self, pixel_array, new_array):
        self.overlay_PIL_image(
            pixel_array,
            self.get_image(new_array),
        )

    def overlay_PIL_image(self, pixel_array, image):
        pixel_array[:, :] = np.array(
            Image.alpha_composite(
                self.get_image(pixel_array),
                image
            ),
            dtype=&#39;uint8&#39;
        )

    def adjust_out_of_range_points(self, points):
        if not np.any(points &gt; self.max_allowable_norm):
            return points
        norms = np.apply_along_axis(get_norm, 1, points)
        violator_indices = norms &gt; self.max_allowable_norm
        violators = points[violator_indices, :]
        violator_norms = norms[violator_indices]
        reshaped_norms = np.repeat(
            violator_norms.reshape((len(violator_norms), 1)),
            points.shape[1], 1
        )
        rescaled = self.max_allowable_norm * violators / reshaped_norms
        points[violator_indices] = rescaled
        return points

    def transform_points_pre_display(self, mobject, points):
        # Subclasses (like ThreeDCamera) may want to
        # adjust points futher before they&#39;re shown
        if not np.all(np.isfinite(points)):
            # TODO, print some kind of warning about
            # mobject having invalid points?
            points = np.zeros((1, 3))
        return points

    def points_to_pixel_coords(self, mobject, points):
        points = self.transform_points_pre_display(
            mobject, points
        )
        shifted_points = points - self.get_frame_center()

        result = np.zeros((len(points), 2))
        pixel_height = self.get_pixel_height()
        pixel_width = self.get_pixel_width()
        frame_height = self.get_frame_height()
        frame_width = self.get_frame_width()
        width_mult = pixel_width / frame_width
        width_add = pixel_width / 2
        height_mult = pixel_height / frame_height
        height_add = pixel_height / 2
        # Flip on y-axis as you go
        height_mult *= -1

        result[:, 0] = shifted_points[:, 0] * width_mult + width_add
        result[:, 1] = shifted_points[:, 1] * height_mult + height_add
        return result.astype(&#39;int&#39;)

    def on_screen_pixels(self, pixel_coords):
        return reduce(op.and_, [
            pixel_coords[:, 0] &gt;= 0,
            pixel_coords[:, 0] &lt; self.get_pixel_width(),
            pixel_coords[:, 1] &gt;= 0,
            pixel_coords[:, 1] &lt; self.get_pixel_height(),
        ])

    def adjusted_thickness(self, thickness):
        # TODO: This seems...unsystematic
        big_sum = op.add(
            PRODUCTION_QUALITY_CAMERA_CONFIG[&#34;pixel_height&#34;],
            PRODUCTION_QUALITY_CAMERA_CONFIG[&#34;pixel_width&#34;],
        )
        this_sum = op.add(
            self.get_pixel_height(),
            self.get_pixel_width(),
        )
        factor = fdiv(big_sum, this_sum)
        return 1 + (thickness - 1) / factor

    def get_thickening_nudges(self, thickness):
        thickness = int(thickness)
        _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))
        return np.array(list(it.product(_range, _range)))

    def thickened_coordinates(self, pixel_coords, thickness):
        nudges = self.get_thickening_nudges(thickness)
        pixel_coords = np.array([
            pixel_coords + nudge
            for nudge in nudges
        ])
        size = pixel_coords.size
        return pixel_coords.reshape((size // 2, 2))

    # TODO, reimplement using cairo matrix
    def get_coords_of_all_pixels(self):
        # These are in x, y order, to help me keep things straight
        full_space_dims = np.array([
            self.get_frame_width(),
            self.get_frame_height()
        ])
        full_pixel_dims = np.array([
            self.get_pixel_width(),
            self.get_pixel_height()
        ])

        # These are addressed in the same y, x order as in pixel_array, but the values in them
        # are listed in x, y order
        uncentered_pixel_coords = np.indices(
            [self.get_pixel_height(), self.get_pixel_width()]
        )[::-1].transpose(1, 2, 0)
        uncentered_space_coords = fdiv(
            uncentered_pixel_coords * full_space_dims,
            full_pixel_dims)
        # Could structure above line&#39;s computation slightly differently, but figured (without much
        # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably
        # better than the other order, for avoiding underflow quantization in the division (whereas
        # overflow is unlikely to be a problem)

        centered_space_coords = (
            uncentered_space_coords - fdiv(full_space_dims, 2)
        )

        # Have to also flip the y coordinates to account for pixel array being listed in
        # top-to-bottom order, opposite of screen coordinate convention
        centered_space_coords = centered_space_coords * (1, -1)

        return centered_space_coords


class BackgroundColoredVMobjectDisplayer(object):
    def __init__(self, camera):
        self.camera = camera
        self.file_name_to_pixel_array_map = {}
        self.pixel_array = np.array(camera.get_pixel_array())
        self.reset_pixel_array()

    def reset_pixel_array(self):
        self.pixel_array[:, :] = 0

    def resize_background_array(
        self, background_array,
        new_width, new_height,
        mode=&#34;RGBA&#34;
    ):
        image = Image.fromarray(background_array)
        image = image.convert(mode)
        resized_image = image.resize((new_width, new_height))
        return np.array(resized_image)

    def resize_background_array_to_match(self, background_array, pixel_array):
        height, width = pixel_array.shape[:2]
        mode = &#34;RGBA&#34; if pixel_array.shape[2] == 4 else &#34;RGB&#34;
        return self.resize_background_array(background_array, width, height, mode)

    def get_background_array(self, file_name):
        if file_name in self.file_name_to_pixel_array_map:
            return self.file_name_to_pixel_array_map[file_name]
        full_path = get_full_raster_image_path(file_name)
        image = Image.open(full_path)
        back_array = np.array(image)

        pixel_array = self.pixel_array
        if not np.all(pixel_array.shape == back_array.shape):
            back_array = self.resize_background_array_to_match(
                back_array, pixel_array
            )

        self.file_name_to_pixel_array_map[file_name] = back_array
        return back_array

    def display(self, *cvmobjects):
        batch_image_file_pairs = batch_by_property(
            cvmobjects, lambda cv: cv.get_background_image_file()
        )
        curr_array = None
        for batch, image_file in batch_image_file_pairs:
            background_array = self.get_background_array(image_file)
            pixel_array = self.pixel_array
            self.camera.display_multiple_non_background_colored_vmobjects(
                batch, pixel_array
            )
            new_array = np.array(
                (background_array * pixel_array.astype(&#39;float&#39;) / 255),
                dtype=self.camera.pixel_array_dtype
            )
            if curr_array is None:
                curr_array = new_array
            else:
                curr_array = np.maximum(curr_array, new_array)
            self.reset_pixel_array()
        return curr_array</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer"><code class="flex name class">
<span>class <span class="ident">BackgroundColoredVMobjectDisplayer</span></span>
<span>(</span><span>camera)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackgroundColoredVMobjectDisplayer(object):
    def __init__(self, camera):
        self.camera = camera
        self.file_name_to_pixel_array_map = {}
        self.pixel_array = np.array(camera.get_pixel_array())
        self.reset_pixel_array()

    def reset_pixel_array(self):
        self.pixel_array[:, :] = 0

    def resize_background_array(
        self, background_array,
        new_width, new_height,
        mode=&#34;RGBA&#34;
    ):
        image = Image.fromarray(background_array)
        image = image.convert(mode)
        resized_image = image.resize((new_width, new_height))
        return np.array(resized_image)

    def resize_background_array_to_match(self, background_array, pixel_array):
        height, width = pixel_array.shape[:2]
        mode = &#34;RGBA&#34; if pixel_array.shape[2] == 4 else &#34;RGB&#34;
        return self.resize_background_array(background_array, width, height, mode)

    def get_background_array(self, file_name):
        if file_name in self.file_name_to_pixel_array_map:
            return self.file_name_to_pixel_array_map[file_name]
        full_path = get_full_raster_image_path(file_name)
        image = Image.open(full_path)
        back_array = np.array(image)

        pixel_array = self.pixel_array
        if not np.all(pixel_array.shape == back_array.shape):
            back_array = self.resize_background_array_to_match(
                back_array, pixel_array
            )

        self.file_name_to_pixel_array_map[file_name] = back_array
        return back_array

    def display(self, *cvmobjects):
        batch_image_file_pairs = batch_by_property(
            cvmobjects, lambda cv: cv.get_background_image_file()
        )
        curr_array = None
        for batch, image_file in batch_image_file_pairs:
            background_array = self.get_background_array(image_file)
            pixel_array = self.pixel_array
            self.camera.display_multiple_non_background_colored_vmobjects(
                batch, pixel_array
            )
            new_array = np.array(
                (background_array * pixel_array.astype(&#39;float&#39;) / 255),
                dtype=self.camera.pixel_array_dtype
            )
            if curr_array is None:
                curr_array = new_array
            else:
                curr_array = np.maximum(curr_array, new_array)
            self.reset_pixel_array()
        return curr_array</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, *cvmobjects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self, *cvmobjects):
    batch_image_file_pairs = batch_by_property(
        cvmobjects, lambda cv: cv.get_background_image_file()
    )
    curr_array = None
    for batch, image_file in batch_image_file_pairs:
        background_array = self.get_background_array(image_file)
        pixel_array = self.pixel_array
        self.camera.display_multiple_non_background_colored_vmobjects(
            batch, pixel_array
        )
        new_array = np.array(
            (background_array * pixel_array.astype(&#39;float&#39;) / 255),
            dtype=self.camera.pixel_array_dtype
        )
        if curr_array is None:
            curr_array = new_array
        else:
            curr_array = np.maximum(curr_array, new_array)
        self.reset_pixel_array()
    return curr_array</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.get_background_array"><code class="name flex">
<span>def <span class="ident">get_background_array</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_background_array(self, file_name):
    if file_name in self.file_name_to_pixel_array_map:
        return self.file_name_to_pixel_array_map[file_name]
    full_path = get_full_raster_image_path(file_name)
    image = Image.open(full_path)
    back_array = np.array(image)

    pixel_array = self.pixel_array
    if not np.all(pixel_array.shape == back_array.shape):
        back_array = self.resize_background_array_to_match(
            back_array, pixel_array
        )

    self.file_name_to_pixel_array_map[file_name] = back_array
    return back_array</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.reset_pixel_array"><code class="name flex">
<span>def <span class="ident">reset_pixel_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_pixel_array(self):
    self.pixel_array[:, :] = 0</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.resize_background_array"><code class="name flex">
<span>def <span class="ident">resize_background_array</span></span>(<span>self, background_array, new_width, new_height, mode='RGBA')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_background_array(
    self, background_array,
    new_width, new_height,
    mode=&#34;RGBA&#34;
):
    image = Image.fromarray(background_array)
    image = image.convert(mode)
    resized_image = image.resize((new_width, new_height))
    return np.array(resized_image)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.resize_background_array_to_match"><code class="name flex">
<span>def <span class="ident">resize_background_array_to_match</span></span>(<span>self, background_array, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_background_array_to_match(self, background_array, pixel_array):
    height, width = pixel_array.shape[:2]
    mode = &#34;RGBA&#34; if pixel_array.shape[2] == 4 else &#34;RGB&#34;
    return self.resize_background_array(background_array, width, height, mode)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="manimlib.camera.camera.Camera"><code class="flex name class">
<span>class <span class="ident">Camera</span></span>
<span>(</span><span>background=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Camera(object):
    CONFIG = {
        &#34;background_image&#34;: None,
        &#34;pixel_height&#34;: DEFAULT_PIXEL_HEIGHT,
        &#34;pixel_width&#34;: DEFAULT_PIXEL_WIDTH,
        &#34;frame_rate&#34;: DEFAULT_FRAME_RATE,
        # Note: frame height and width will be resized to match
        # the pixel aspect ratio
        &#34;frame_height&#34;: FRAME_HEIGHT,
        &#34;frame_width&#34;: FRAME_WIDTH,
        &#34;frame_center&#34;: ORIGIN,
        &#34;background_color&#34;: &#34;#0e0e0e&#34;,
        &#34;background_opacity&#34;: 1,
        # Points in vectorized mobjects with norm greater
        # than this value will be rescaled.
        &#34;max_allowable_norm&#34;: FRAME_WIDTH,
        &#34;image_mode&#34;: &#34;RGBA&#34;,
        &#34;n_channels&#34;: 4,
        &#34;pixel_array_dtype&#34;: &#39;uint8&#39;,
        # z_buff_func is only used if the flag above is set to True.
        # round z coordinate to nearest hundredth when comparring
        &#34;z_buff_func&#34;: lambda m: np.round(m.get_center()[2], 2),
        &#34;cairo_line_width_multiple&#34;: 0.01,
    }

    def __init__(self, background=None, **kwargs):
        digest_config(self, kwargs, locals())
        self.rgb_max_val = np.iinfo(self.pixel_array_dtype).max
        self.pixel_array_to_cairo_context = {}
        self.init_background()
        self.resize_frame_shape()
        self.reset()

    def __deepcopy__(self, memo):
        # This is to address a strange bug where deepcopying
        # will result in a segfault, which is somehow related
        # to the aggdraw library
        self.canvas = None
        return copy.copy(self)

    def reset_pixel_shape(self, new_height, new_width):
        self.pixel_width = new_width
        self.pixel_height = new_height
        self.init_background()
        self.resize_frame_shape()
        self.reset()

    def get_pixel_height(self):
        return self.pixel_height

    def get_pixel_width(self):
        return self.pixel_width

    def get_frame_height(self):
        return self.frame_height

    def get_frame_width(self):
        return self.frame_width

    def get_frame_center(self):
        return self.frame_center

    def set_frame_height(self, frame_height):
        self.frame_height = frame_height

    def set_frame_width(self, frame_width):
        self.frame_width = frame_width

    def set_frame_center(self, frame_center):
        self.frame_center = frame_center

    def resize_frame_shape(self, fixed_dimension=0):
        &#34;&#34;&#34;
        Changes frame_shape to match the aspect ratio
        of the pixels, where fixed_dimension determines
        whether frame_height or frame_width
        remains fixed while the other changes accordingly.
        &#34;&#34;&#34;
        pixel_height = self.get_pixel_height()
        pixel_width = self.get_pixel_width()
        frame_height = self.get_frame_height()
        frame_width = self.get_frame_width()
        aspect_ratio = fdiv(pixel_width, pixel_height)
        if fixed_dimension == 0:
            frame_height = frame_width / aspect_ratio
        else:
            frame_width = aspect_ratio * frame_height
        self.set_frame_height(frame_height)
        self.set_frame_width(frame_width)

    def init_background(self):
        height = self.get_pixel_height()
        width = self.get_pixel_width()
        if self.background_image is not None:
            path = get_full_raster_image_path(self.background_image)
            image = Image.open(path).convert(self.image_mode)
            # TODO, how to gracefully handle backgrounds
            # with different sizes?
            self.background = np.array(image)[:height, :width]
            self.background = self.background.astype(self.pixel_array_dtype)
        else:
            background_rgba = color_to_int_rgba(
                self.background_color, self.background_opacity
            )
            self.background = np.zeros(
                (height, width, self.n_channels),
                dtype=self.pixel_array_dtype
            )
            self.background[:, :] = background_rgba

    def get_image(self, pixel_array=None):
        if pixel_array is None:
            pixel_array = self.pixel_array
        return Image.fromarray(
            pixel_array,
            mode=self.image_mode
        )

    def get_pixel_array(self):
        return self.pixel_array

    def convert_pixel_array(self, pixel_array, convert_from_floats=False):
        retval = np.array(pixel_array)
        if convert_from_floats:
            retval = np.apply_along_axis(
                lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),
                2,
                retval
            )
        return retval

    def set_pixel_array(self, pixel_array, convert_from_floats=False):
        converted_array = self.convert_pixel_array(
            pixel_array, convert_from_floats)
        if not (hasattr(self, &#34;pixel_array&#34;) and self.pixel_array.shape == converted_array.shape):
            self.pixel_array = converted_array
        else:
            # Set in place
            self.pixel_array[:, :, :] = converted_array[:, :, :]

    def set_background(self, pixel_array, convert_from_floats=False):
        self.background = self.convert_pixel_array(
            pixel_array, convert_from_floats)

    # TODO, this should live in utils, not as a method of Camera
    def make_background_from_func(self, coords_to_colors_func):
        &#34;&#34;&#34;
        Sets background by using coords_to_colors_func to determine each pixel&#39;s color. Each input
        to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not
        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.
        &#34;&#34;&#34;

        print(&#34;Starting set_background; for reference, the current time is &#34;, time.strftime(&#34;%H:%M:%S&#34;))
        coords = self.get_coords_of_all_pixels()
        new_background = np.apply_along_axis(
            coords_to_colors_func,
            2,
            coords
        )
        print(&#34;Ending set_background; for reference, the current time is &#34;, time.strftime(&#34;%H:%M:%S&#34;))

        return self.convert_pixel_array(new_background, convert_from_floats=True)

    def set_background_from_func(self, coords_to_colors_func):
        self.set_background(
            self.make_background_from_func(coords_to_colors_func))

    def reset(self):
        self.set_pixel_array(self.background)
        return self

    ####

    # TODO, it&#39;s weird that this is part of camera.
    # Clearly it should live elsewhere.
    def extract_mobject_family_members(
            self, mobjects,
            only_those_with_points=False):
        if only_those_with_points:
            method = Mobject.family_members_with_points
        else:
            method = Mobject.get_family
        return remove_list_redundancies(list(
            it.chain(*[method(m) for m in mobjects])
        ))

    def get_mobjects_to_display(
            self, mobjects,
            include_submobjects=True,
            excluded_mobjects=None):
        if include_submobjects:
            mobjects = self.extract_mobject_family_members(
                mobjects, only_those_with_points=True,
            )
            if excluded_mobjects:
                all_excluded = self.extract_mobject_family_members(
                    excluded_mobjects
                )
                mobjects = list_difference_update(mobjects, all_excluded)
        return mobjects

    def is_in_frame(self, mobject):
        fc = self.get_frame_center()
        fh = self.get_frame_height()
        fw = self.get_frame_width()
        return not reduce(op.or_, [
            mobject.get_right()[0] &lt; fc[0] - fw,
            mobject.get_bottom()[1] &gt; fc[1] + fh,
            mobject.get_left()[0] &gt; fc[0] + fw,
            mobject.get_top()[1] &lt; fc[1] - fh,
        ])

    def capture_mobject(self, mobject, **kwargs):
        return self.capture_mobjects([mobject], **kwargs)

    def capture_mobjects(self, mobjects, **kwargs):
        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)

        # Organize this list into batches of the same type, and
        # apply corresponding function to those batches
        type_func_pairs = [
            (VMobject, self.display_multiple_vectorized_mobjects),
            (PMobject, self.display_multiple_point_cloud_mobjects),
            (AbstractImageMobject, self.display_multiple_image_mobjects),
            (Mobject, lambda batch, pa: batch),  # Do nothing
        ]

        def get_mobject_type(mobject):
            for mobject_type, func in type_func_pairs:
                if isinstance(mobject, mobject_type):
                    return mobject_type
            raise Exception(
                &#34;Trying to display something which is not of type Mobject&#34;
            )
        batch_type_pairs = batch_by_property(mobjects, get_mobject_type)

        # Display in these batches
        for batch, batch_type in batch_type_pairs:
            # check what the type is, and call the appropriate function
            for mobject_type, func in type_func_pairs:
                if batch_type == mobject_type:
                    func(batch, self.pixel_array)

    # Methods associated with svg rendering

    def get_cached_cairo_context(self, pixel_array):
        return self.pixel_array_to_cairo_context.get(
            id(pixel_array), None
        )

    def cache_cairo_context(self, pixel_array, ctx):
        self.pixel_array_to_cairo_context[id(pixel_array)] = ctx

    def get_cairo_context(self, pixel_array):
        cached_ctx = self.get_cached_cairo_context(pixel_array)
        if cached_ctx:
            return cached_ctx
        pw = self.get_pixel_width()
        ph = self.get_pixel_height()
        fw = self.get_frame_width()
        fh = self.get_frame_height()
        fc = self.get_frame_center()
        surface = cairo.ImageSurface.create_for_data(
            pixel_array,
            cairo.FORMAT_ARGB32,
            pw, ph
        )
        ctx = cairo.Context(surface)
        ctx.scale(pw, ph)
        ctx.set_matrix(cairo.Matrix(
            fdiv(pw, fw), 0,
            0, -fdiv(ph, fh),
            (pw / 2) - fc[0] * fdiv(pw, fw),
            (ph / 2) + fc[1] * fdiv(ph, fh),
        ))
        self.cache_cairo_context(pixel_array, ctx)
        return ctx

    def display_multiple_vectorized_mobjects(self, vmobjects, pixel_array):
        if len(vmobjects) == 0:
            return
        batch_file_pairs = batch_by_property(
            vmobjects,
            lambda vm: vm.get_background_image_file()
        )
        for batch, file_name in batch_file_pairs:
            if file_name:
                self.display_multiple_background_colored_vmobject(batch, pixel_array)
            else:
                self.display_multiple_non_background_colored_vmobjects(batch, pixel_array)

    def display_multiple_non_background_colored_vmobjects(self, vmobjects, pixel_array):
        ctx = self.get_cairo_context(pixel_array)
        for vmobject in vmobjects:
            self.display_vectorized(vmobject, ctx)

    def display_vectorized(self, vmobject, ctx):
        self.set_cairo_context_path(ctx, vmobject)
        self.apply_stroke(ctx, vmobject, background=True)
        self.apply_fill(ctx, vmobject)
        self.apply_stroke(ctx, vmobject)
        return self

    def set_cairo_context_path(self, ctx, vmobject):
        points = self.transform_points_pre_display(
            vmobject, vmobject.points
        )
        # TODO, shouldn&#39;t this be handled in transform_points_pre_display?
        # points = points - self.get_frame_center()
        if len(points) == 0:
            return

        ctx.new_path()
        subpaths = vmobject.gen_subpaths_from_points_2d(points)
        for subpath in subpaths:
            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)
            ctx.new_sub_path()
            start = subpath[0]
            ctx.move_to(*start[:2])
            for p0, p1, p2, p3 in quads:
                ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])
            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):
                ctx.close_path()
        return self

    def set_cairo_context_color(self, ctx, rgbas, vmobject):
        if len(rgbas) == 1:
            # Use reversed rgb because cairo surface is
            # encodes it in reverse order
            ctx.set_source_rgba(
                *rgbas[0][2::-1], rgbas[0][3]
            )
        else:
            points = vmobject.get_gradient_start_and_end_points()
            points = self.transform_points_pre_display(
                vmobject, points
            )
            pat = cairo.LinearGradient(*it.chain(*[
                point[:2] for point in points
            ]))
            step = 1.0 / (len(rgbas) - 1)
            offsets = np.arange(0, 1 + step, step)
            for rgba, offset in zip(rgbas, offsets):
                pat.add_color_stop_rgba(
                    offset, *rgba[2::-1], rgba[3]
                )
            ctx.set_source(pat)
        return self

    def apply_fill(self, ctx, vmobject):
        self.set_cairo_context_color(
            ctx, self.get_fill_rgbas(vmobject), vmobject
        )
        ctx.fill_preserve()
        return self

    def apply_stroke(self, ctx, vmobject, background=False):
        width = vmobject.get_stroke_width(background)
        if width == 0:
            return self
        self.set_cairo_context_color(
            ctx,
            self.get_stroke_rgbas(vmobject, background=background),
            vmobject
        )
        ctx.set_line_width(
            width * self.cairo_line_width_multiple *
            # This ensures lines have constant width
            # as you zoom in on them.
            (self.get_frame_width() / FRAME_WIDTH)
        )
        ctx.stroke_preserve()
        return self

    def get_stroke_rgbas(self, vmobject, background=False):
        return vmobject.get_stroke_rgbas(background)

    def get_fill_rgbas(self, vmobject):
        return vmobject.get_fill_rgbas()

    def get_background_colored_vmobject_displayer(self):
        # Quite wordy to type out a bunch
        bcvd = &#34;background_colored_vmobject_displayer&#34;
        if not hasattr(self, bcvd):
            setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))
        return getattr(self, bcvd)

    def display_multiple_background_colored_vmobject(self, cvmobjects, pixel_array):
        displayer = self.get_background_colored_vmobject_displayer()
        cvmobject_pixel_array = displayer.display(*cvmobjects)
        self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)
        return self

    # Methods for other rendering

    def display_multiple_point_cloud_mobjects(self, pmobjects, pixel_array):
        for pmobject in pmobjects:
            self.display_point_cloud(
                pmobject,
                pmobject.points,
                pmobject.rgbas,
                self.adjusted_thickness(pmobject.stroke_width),
                pixel_array,
            )

    def display_point_cloud(self, pmobject, points, rgbas, thickness, pixel_array):
        if len(points) == 0:
            return
        pixel_coords = self.points_to_pixel_coords(
            pmobject, points
        )
        pixel_coords = self.thickened_coordinates(
            pixel_coords, thickness
        )
        rgba_len = pixel_array.shape[2]

        rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)
        target_len = len(pixel_coords)
        factor = target_len // len(rgbas)
        rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))

        on_screen_indices = self.on_screen_pixels(pixel_coords)
        pixel_coords = pixel_coords[on_screen_indices]
        rgbas = rgbas[on_screen_indices]

        ph = self.get_pixel_height()
        pw = self.get_pixel_width()

        flattener = np.array([1, pw], dtype=&#39;int&#39;)
        flattener = flattener.reshape((2, 1))
        indices = np.dot(pixel_coords, flattener)[:, 0]
        indices = indices.astype(&#39;int&#39;)

        new_pa = pixel_array.reshape((ph * pw, rgba_len))
        new_pa[indices] = rgbas
        pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))

    def display_multiple_image_mobjects(self, image_mobjects, pixel_array):
        for image_mobject in image_mobjects:
            self.display_image_mobject(image_mobject, pixel_array)

    def display_image_mobject(self, image_mobject, pixel_array):
        corner_coords = self.points_to_pixel_coords(
            image_mobject, image_mobject.points
        )
        ul_coords, ur_coords, dl_coords = corner_coords
        right_vect = ur_coords - ul_coords
        down_vect = dl_coords - ul_coords
        center_coords = ul_coords + (right_vect + down_vect) / 2

        sub_image = Image.fromarray(
            image_mobject.get_pixel_array(),
            mode=&#34;RGBA&#34;
        )

        # Reshape
        pixel_width = max(int(pdist([ul_coords, ur_coords])), 1)
        pixel_height = max(int(pdist([ul_coords, dl_coords])), 1)
        sub_image = sub_image.resize(
            (pixel_width, pixel_height), resample=Image.BICUBIC
        )

        # Rotate
        angle = angle_of_vector(right_vect)
        adjusted_angle = -int(360 * angle / TAU)
        if adjusted_angle != 0:
            sub_image = sub_image.rotate(
                adjusted_angle, resample=Image.BICUBIC, expand=1
            )

        # TODO, there is no accounting for a shear...

        # Paste into an image as large as the camear&#39;s pixel array
        full_image = Image.fromarray(
            np.zeros((self.get_pixel_height(), self.get_pixel_width())),
            mode=&#34;RGBA&#34;
        )
        new_ul_coords = center_coords - np.array(sub_image.size) / 2
        new_ul_coords = new_ul_coords.astype(int)
        full_image.paste(
            sub_image,
            box=(
                new_ul_coords[0],
                new_ul_coords[1],
                new_ul_coords[0] + sub_image.size[0],
                new_ul_coords[1] + sub_image.size[1],
            )
        )
        # Paint on top of existing pixel array
        self.overlay_PIL_image(pixel_array, full_image)

    def overlay_rgba_array(self, pixel_array, new_array):
        self.overlay_PIL_image(
            pixel_array,
            self.get_image(new_array),
        )

    def overlay_PIL_image(self, pixel_array, image):
        pixel_array[:, :] = np.array(
            Image.alpha_composite(
                self.get_image(pixel_array),
                image
            ),
            dtype=&#39;uint8&#39;
        )

    def adjust_out_of_range_points(self, points):
        if not np.any(points &gt; self.max_allowable_norm):
            return points
        norms = np.apply_along_axis(get_norm, 1, points)
        violator_indices = norms &gt; self.max_allowable_norm
        violators = points[violator_indices, :]
        violator_norms = norms[violator_indices]
        reshaped_norms = np.repeat(
            violator_norms.reshape((len(violator_norms), 1)),
            points.shape[1], 1
        )
        rescaled = self.max_allowable_norm * violators / reshaped_norms
        points[violator_indices] = rescaled
        return points

    def transform_points_pre_display(self, mobject, points):
        # Subclasses (like ThreeDCamera) may want to
        # adjust points futher before they&#39;re shown
        if not np.all(np.isfinite(points)):
            # TODO, print some kind of warning about
            # mobject having invalid points?
            points = np.zeros((1, 3))
        return points

    def points_to_pixel_coords(self, mobject, points):
        points = self.transform_points_pre_display(
            mobject, points
        )
        shifted_points = points - self.get_frame_center()

        result = np.zeros((len(points), 2))
        pixel_height = self.get_pixel_height()
        pixel_width = self.get_pixel_width()
        frame_height = self.get_frame_height()
        frame_width = self.get_frame_width()
        width_mult = pixel_width / frame_width
        width_add = pixel_width / 2
        height_mult = pixel_height / frame_height
        height_add = pixel_height / 2
        # Flip on y-axis as you go
        height_mult *= -1

        result[:, 0] = shifted_points[:, 0] * width_mult + width_add
        result[:, 1] = shifted_points[:, 1] * height_mult + height_add
        return result.astype(&#39;int&#39;)

    def on_screen_pixels(self, pixel_coords):
        return reduce(op.and_, [
            pixel_coords[:, 0] &gt;= 0,
            pixel_coords[:, 0] &lt; self.get_pixel_width(),
            pixel_coords[:, 1] &gt;= 0,
            pixel_coords[:, 1] &lt; self.get_pixel_height(),
        ])

    def adjusted_thickness(self, thickness):
        # TODO: This seems...unsystematic
        big_sum = op.add(
            PRODUCTION_QUALITY_CAMERA_CONFIG[&#34;pixel_height&#34;],
            PRODUCTION_QUALITY_CAMERA_CONFIG[&#34;pixel_width&#34;],
        )
        this_sum = op.add(
            self.get_pixel_height(),
            self.get_pixel_width(),
        )
        factor = fdiv(big_sum, this_sum)
        return 1 + (thickness - 1) / factor

    def get_thickening_nudges(self, thickness):
        thickness = int(thickness)
        _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))
        return np.array(list(it.product(_range, _range)))

    def thickened_coordinates(self, pixel_coords, thickness):
        nudges = self.get_thickening_nudges(thickness)
        pixel_coords = np.array([
            pixel_coords + nudge
            for nudge in nudges
        ])
        size = pixel_coords.size
        return pixel_coords.reshape((size // 2, 2))

    # TODO, reimplement using cairo matrix
    def get_coords_of_all_pixels(self):
        # These are in x, y order, to help me keep things straight
        full_space_dims = np.array([
            self.get_frame_width(),
            self.get_frame_height()
        ])
        full_pixel_dims = np.array([
            self.get_pixel_width(),
            self.get_pixel_height()
        ])

        # These are addressed in the same y, x order as in pixel_array, but the values in them
        # are listed in x, y order
        uncentered_pixel_coords = np.indices(
            [self.get_pixel_height(), self.get_pixel_width()]
        )[::-1].transpose(1, 2, 0)
        uncentered_space_coords = fdiv(
            uncentered_pixel_coords * full_space_dims,
            full_pixel_dims)
        # Could structure above line&#39;s computation slightly differently, but figured (without much
        # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably
        # better than the other order, for avoiding underflow quantization in the division (whereas
        # overflow is unlikely to be a problem)

        centered_space_coords = (
            uncentered_space_coords - fdiv(full_space_dims, 2)
        )

        # Have to also flip the y coordinates to account for pixel array being listed in
        # top-to-bottom order, opposite of screen coordinate convention
        centered_space_coords = centered_space_coords * (1, -1)

        return centered_space_coords</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.camera.mapping_camera.MappingCamera" href="mapping_camera.html#manimlib.camera.mapping_camera.MappingCamera">MappingCamera</a></li>
<li><a title="manimlib.camera.mapping_camera.OldMultiCamera" href="mapping_camera.html#manimlib.camera.mapping_camera.OldMultiCamera">OldMultiCamera</a></li>
<li><a title="manimlib.camera.moving_camera.MovingCamera" href="moving_camera.html#manimlib.camera.moving_camera.MovingCamera">MovingCamera</a></li>
<li><a title="manimlib.camera.three_d_camera.ThreeDCamera" href="three_d_camera.html#manimlib.camera.three_d_camera.ThreeDCamera">ThreeDCamera</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.camera.camera.Camera.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.camera.camera.Camera.adjust_out_of_range_points"><code class="name flex">
<span>def <span class="ident">adjust_out_of_range_points</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_out_of_range_points(self, points):
    if not np.any(points &gt; self.max_allowable_norm):
        return points
    norms = np.apply_along_axis(get_norm, 1, points)
    violator_indices = norms &gt; self.max_allowable_norm
    violators = points[violator_indices, :]
    violator_norms = norms[violator_indices]
    reshaped_norms = np.repeat(
        violator_norms.reshape((len(violator_norms), 1)),
        points.shape[1], 1
    )
    rescaled = self.max_allowable_norm * violators / reshaped_norms
    points[violator_indices] = rescaled
    return points</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.adjusted_thickness"><code class="name flex">
<span>def <span class="ident">adjusted_thickness</span></span>(<span>self, thickness)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjusted_thickness(self, thickness):
    # TODO: This seems...unsystematic
    big_sum = op.add(
        PRODUCTION_QUALITY_CAMERA_CONFIG[&#34;pixel_height&#34;],
        PRODUCTION_QUALITY_CAMERA_CONFIG[&#34;pixel_width&#34;],
    )
    this_sum = op.add(
        self.get_pixel_height(),
        self.get_pixel_width(),
    )
    factor = fdiv(big_sum, this_sum)
    return 1 + (thickness - 1) / factor</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.apply_fill"><code class="name flex">
<span>def <span class="ident">apply_fill</span></span>(<span>self, ctx, vmobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_fill(self, ctx, vmobject):
    self.set_cairo_context_color(
        ctx, self.get_fill_rgbas(vmobject), vmobject
    )
    ctx.fill_preserve()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.apply_stroke"><code class="name flex">
<span>def <span class="ident">apply_stroke</span></span>(<span>self, ctx, vmobject, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_stroke(self, ctx, vmobject, background=False):
    width = vmobject.get_stroke_width(background)
    if width == 0:
        return self
    self.set_cairo_context_color(
        ctx,
        self.get_stroke_rgbas(vmobject, background=background),
        vmobject
    )
    ctx.set_line_width(
        width * self.cairo_line_width_multiple *
        # This ensures lines have constant width
        # as you zoom in on them.
        (self.get_frame_width() / FRAME_WIDTH)
    )
    ctx.stroke_preserve()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.cache_cairo_context"><code class="name flex">
<span>def <span class="ident">cache_cairo_context</span></span>(<span>self, pixel_array, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_cairo_context(self, pixel_array, ctx):
    self.pixel_array_to_cairo_context[id(pixel_array)] = ctx</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.capture_mobject"><code class="name flex">
<span>def <span class="ident">capture_mobject</span></span>(<span>self, mobject, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_mobject(self, mobject, **kwargs):
    return self.capture_mobjects([mobject], **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.capture_mobjects"><code class="name flex">
<span>def <span class="ident">capture_mobjects</span></span>(<span>self, mobjects, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_mobjects(self, mobjects, **kwargs):
    mobjects = self.get_mobjects_to_display(mobjects, **kwargs)

    # Organize this list into batches of the same type, and
    # apply corresponding function to those batches
    type_func_pairs = [
        (VMobject, self.display_multiple_vectorized_mobjects),
        (PMobject, self.display_multiple_point_cloud_mobjects),
        (AbstractImageMobject, self.display_multiple_image_mobjects),
        (Mobject, lambda batch, pa: batch),  # Do nothing
    ]

    def get_mobject_type(mobject):
        for mobject_type, func in type_func_pairs:
            if isinstance(mobject, mobject_type):
                return mobject_type
        raise Exception(
            &#34;Trying to display something which is not of type Mobject&#34;
        )
    batch_type_pairs = batch_by_property(mobjects, get_mobject_type)

    # Display in these batches
    for batch, batch_type in batch_type_pairs:
        # check what the type is, and call the appropriate function
        for mobject_type, func in type_func_pairs:
            if batch_type == mobject_type:
                func(batch, self.pixel_array)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.convert_pixel_array"><code class="name flex">
<span>def <span class="ident">convert_pixel_array</span></span>(<span>self, pixel_array, convert_from_floats=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_pixel_array(self, pixel_array, convert_from_floats=False):
    retval = np.array(pixel_array)
    if convert_from_floats:
        retval = np.apply_along_axis(
            lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),
            2,
            retval
        )
    return retval</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_image_mobject"><code class="name flex">
<span>def <span class="ident">display_image_mobject</span></span>(<span>self, image_mobject, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_image_mobject(self, image_mobject, pixel_array):
    corner_coords = self.points_to_pixel_coords(
        image_mobject, image_mobject.points
    )
    ul_coords, ur_coords, dl_coords = corner_coords
    right_vect = ur_coords - ul_coords
    down_vect = dl_coords - ul_coords
    center_coords = ul_coords + (right_vect + down_vect) / 2

    sub_image = Image.fromarray(
        image_mobject.get_pixel_array(),
        mode=&#34;RGBA&#34;
    )

    # Reshape
    pixel_width = max(int(pdist([ul_coords, ur_coords])), 1)
    pixel_height = max(int(pdist([ul_coords, dl_coords])), 1)
    sub_image = sub_image.resize(
        (pixel_width, pixel_height), resample=Image.BICUBIC
    )

    # Rotate
    angle = angle_of_vector(right_vect)
    adjusted_angle = -int(360 * angle / TAU)
    if adjusted_angle != 0:
        sub_image = sub_image.rotate(
            adjusted_angle, resample=Image.BICUBIC, expand=1
        )

    # TODO, there is no accounting for a shear...

    # Paste into an image as large as the camear&#39;s pixel array
    full_image = Image.fromarray(
        np.zeros((self.get_pixel_height(), self.get_pixel_width())),
        mode=&#34;RGBA&#34;
    )
    new_ul_coords = center_coords - np.array(sub_image.size) / 2
    new_ul_coords = new_ul_coords.astype(int)
    full_image.paste(
        sub_image,
        box=(
            new_ul_coords[0],
            new_ul_coords[1],
            new_ul_coords[0] + sub_image.size[0],
            new_ul_coords[1] + sub_image.size[1],
        )
    )
    # Paint on top of existing pixel array
    self.overlay_PIL_image(pixel_array, full_image)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_multiple_background_colored_vmobject"><code class="name flex">
<span>def <span class="ident">display_multiple_background_colored_vmobject</span></span>(<span>self, cvmobjects, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_multiple_background_colored_vmobject(self, cvmobjects, pixel_array):
    displayer = self.get_background_colored_vmobject_displayer()
    cvmobject_pixel_array = displayer.display(*cvmobjects)
    self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_multiple_image_mobjects"><code class="name flex">
<span>def <span class="ident">display_multiple_image_mobjects</span></span>(<span>self, image_mobjects, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_multiple_image_mobjects(self, image_mobjects, pixel_array):
    for image_mobject in image_mobjects:
        self.display_image_mobject(image_mobject, pixel_array)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_multiple_non_background_colored_vmobjects"><code class="name flex">
<span>def <span class="ident">display_multiple_non_background_colored_vmobjects</span></span>(<span>self, vmobjects, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_multiple_non_background_colored_vmobjects(self, vmobjects, pixel_array):
    ctx = self.get_cairo_context(pixel_array)
    for vmobject in vmobjects:
        self.display_vectorized(vmobject, ctx)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_multiple_point_cloud_mobjects"><code class="name flex">
<span>def <span class="ident">display_multiple_point_cloud_mobjects</span></span>(<span>self, pmobjects, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_multiple_point_cloud_mobjects(self, pmobjects, pixel_array):
    for pmobject in pmobjects:
        self.display_point_cloud(
            pmobject,
            pmobject.points,
            pmobject.rgbas,
            self.adjusted_thickness(pmobject.stroke_width),
            pixel_array,
        )</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_multiple_vectorized_mobjects"><code class="name flex">
<span>def <span class="ident">display_multiple_vectorized_mobjects</span></span>(<span>self, vmobjects, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_multiple_vectorized_mobjects(self, vmobjects, pixel_array):
    if len(vmobjects) == 0:
        return
    batch_file_pairs = batch_by_property(
        vmobjects,
        lambda vm: vm.get_background_image_file()
    )
    for batch, file_name in batch_file_pairs:
        if file_name:
            self.display_multiple_background_colored_vmobject(batch, pixel_array)
        else:
            self.display_multiple_non_background_colored_vmobjects(batch, pixel_array)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_point_cloud"><code class="name flex">
<span>def <span class="ident">display_point_cloud</span></span>(<span>self, pmobject, points, rgbas, thickness, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_point_cloud(self, pmobject, points, rgbas, thickness, pixel_array):
    if len(points) == 0:
        return
    pixel_coords = self.points_to_pixel_coords(
        pmobject, points
    )
    pixel_coords = self.thickened_coordinates(
        pixel_coords, thickness
    )
    rgba_len = pixel_array.shape[2]

    rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)
    target_len = len(pixel_coords)
    factor = target_len // len(rgbas)
    rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))

    on_screen_indices = self.on_screen_pixels(pixel_coords)
    pixel_coords = pixel_coords[on_screen_indices]
    rgbas = rgbas[on_screen_indices]

    ph = self.get_pixel_height()
    pw = self.get_pixel_width()

    flattener = np.array([1, pw], dtype=&#39;int&#39;)
    flattener = flattener.reshape((2, 1))
    indices = np.dot(pixel_coords, flattener)[:, 0]
    indices = indices.astype(&#39;int&#39;)

    new_pa = pixel_array.reshape((ph * pw, rgba_len))
    new_pa[indices] = rgbas
    pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.display_vectorized"><code class="name flex">
<span>def <span class="ident">display_vectorized</span></span>(<span>self, vmobject, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_vectorized(self, vmobject, ctx):
    self.set_cairo_context_path(ctx, vmobject)
    self.apply_stroke(ctx, vmobject, background=True)
    self.apply_fill(ctx, vmobject)
    self.apply_stroke(ctx, vmobject)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.extract_mobject_family_members"><code class="name flex">
<span>def <span class="ident">extract_mobject_family_members</span></span>(<span>self, mobjects, only_those_with_points=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_mobject_family_members(
        self, mobjects,
        only_those_with_points=False):
    if only_those_with_points:
        method = Mobject.family_members_with_points
    else:
        method = Mobject.get_family
    return remove_list_redundancies(list(
        it.chain(*[method(m) for m in mobjects])
    ))</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_background_colored_vmobject_displayer"><code class="name flex">
<span>def <span class="ident">get_background_colored_vmobject_displayer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_background_colored_vmobject_displayer(self):
    # Quite wordy to type out a bunch
    bcvd = &#34;background_colored_vmobject_displayer&#34;
    if not hasattr(self, bcvd):
        setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))
    return getattr(self, bcvd)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_cached_cairo_context"><code class="name flex">
<span>def <span class="ident">get_cached_cairo_context</span></span>(<span>self, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cached_cairo_context(self, pixel_array):
    return self.pixel_array_to_cairo_context.get(
        id(pixel_array), None
    )</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_cairo_context"><code class="name flex">
<span>def <span class="ident">get_cairo_context</span></span>(<span>self, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cairo_context(self, pixel_array):
    cached_ctx = self.get_cached_cairo_context(pixel_array)
    if cached_ctx:
        return cached_ctx
    pw = self.get_pixel_width()
    ph = self.get_pixel_height()
    fw = self.get_frame_width()
    fh = self.get_frame_height()
    fc = self.get_frame_center()
    surface = cairo.ImageSurface.create_for_data(
        pixel_array,
        cairo.FORMAT_ARGB32,
        pw, ph
    )
    ctx = cairo.Context(surface)
    ctx.scale(pw, ph)
    ctx.set_matrix(cairo.Matrix(
        fdiv(pw, fw), 0,
        0, -fdiv(ph, fh),
        (pw / 2) - fc[0] * fdiv(pw, fw),
        (ph / 2) + fc[1] * fdiv(ph, fh),
    ))
    self.cache_cairo_context(pixel_array, ctx)
    return ctx</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_coords_of_all_pixels"><code class="name flex">
<span>def <span class="ident">get_coords_of_all_pixels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords_of_all_pixels(self):
    # These are in x, y order, to help me keep things straight
    full_space_dims = np.array([
        self.get_frame_width(),
        self.get_frame_height()
    ])
    full_pixel_dims = np.array([
        self.get_pixel_width(),
        self.get_pixel_height()
    ])

    # These are addressed in the same y, x order as in pixel_array, but the values in them
    # are listed in x, y order
    uncentered_pixel_coords = np.indices(
        [self.get_pixel_height(), self.get_pixel_width()]
    )[::-1].transpose(1, 2, 0)
    uncentered_space_coords = fdiv(
        uncentered_pixel_coords * full_space_dims,
        full_pixel_dims)
    # Could structure above line&#39;s computation slightly differently, but figured (without much
    # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably
    # better than the other order, for avoiding underflow quantization in the division (whereas
    # overflow is unlikely to be a problem)

    centered_space_coords = (
        uncentered_space_coords - fdiv(full_space_dims, 2)
    )

    # Have to also flip the y coordinates to account for pixel array being listed in
    # top-to-bottom order, opposite of screen coordinate convention
    centered_space_coords = centered_space_coords * (1, -1)

    return centered_space_coords</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_fill_rgbas"><code class="name flex">
<span>def <span class="ident">get_fill_rgbas</span></span>(<span>self, vmobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fill_rgbas(self, vmobject):
    return vmobject.get_fill_rgbas()</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_frame_center"><code class="name flex">
<span>def <span class="ident">get_frame_center</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_center(self):
    return self.frame_center</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_frame_height"><code class="name flex">
<span>def <span class="ident">get_frame_height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_height(self):
    return self.frame_height</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_frame_width"><code class="name flex">
<span>def <span class="ident">get_frame_width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_width(self):
    return self.frame_width</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>self, pixel_array=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image(self, pixel_array=None):
    if pixel_array is None:
        pixel_array = self.pixel_array
    return Image.fromarray(
        pixel_array,
        mode=self.image_mode
    )</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_mobjects_to_display"><code class="name flex">
<span>def <span class="ident">get_mobjects_to_display</span></span>(<span>self, mobjects, include_submobjects=True, excluded_mobjects=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobjects_to_display(
        self, mobjects,
        include_submobjects=True,
        excluded_mobjects=None):
    if include_submobjects:
        mobjects = self.extract_mobject_family_members(
            mobjects, only_those_with_points=True,
        )
        if excluded_mobjects:
            all_excluded = self.extract_mobject_family_members(
                excluded_mobjects
            )
            mobjects = list_difference_update(mobjects, all_excluded)
    return mobjects</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_pixel_array"><code class="name flex">
<span>def <span class="ident">get_pixel_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixel_array(self):
    return self.pixel_array</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_pixel_height"><code class="name flex">
<span>def <span class="ident">get_pixel_height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixel_height(self):
    return self.pixel_height</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_pixel_width"><code class="name flex">
<span>def <span class="ident">get_pixel_width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixel_width(self):
    return self.pixel_width</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_stroke_rgbas"><code class="name flex">
<span>def <span class="ident">get_stroke_rgbas</span></span>(<span>self, vmobject, background=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_rgbas(self, vmobject, background=False):
    return vmobject.get_stroke_rgbas(background)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.get_thickening_nudges"><code class="name flex">
<span>def <span class="ident">get_thickening_nudges</span></span>(<span>self, thickness)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_thickening_nudges(self, thickness):
    thickness = int(thickness)
    _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))
    return np.array(list(it.product(_range, _range)))</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.init_background"><code class="name flex">
<span>def <span class="ident">init_background</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_background(self):
    height = self.get_pixel_height()
    width = self.get_pixel_width()
    if self.background_image is not None:
        path = get_full_raster_image_path(self.background_image)
        image = Image.open(path).convert(self.image_mode)
        # TODO, how to gracefully handle backgrounds
        # with different sizes?
        self.background = np.array(image)[:height, :width]
        self.background = self.background.astype(self.pixel_array_dtype)
    else:
        background_rgba = color_to_int_rgba(
            self.background_color, self.background_opacity
        )
        self.background = np.zeros(
            (height, width, self.n_channels),
            dtype=self.pixel_array_dtype
        )
        self.background[:, :] = background_rgba</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.is_in_frame"><code class="name flex">
<span>def <span class="ident">is_in_frame</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_frame(self, mobject):
    fc = self.get_frame_center()
    fh = self.get_frame_height()
    fw = self.get_frame_width()
    return not reduce(op.or_, [
        mobject.get_right()[0] &lt; fc[0] - fw,
        mobject.get_bottom()[1] &gt; fc[1] + fh,
        mobject.get_left()[0] &gt; fc[0] + fw,
        mobject.get_top()[1] &lt; fc[1] - fh,
    ])</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.make_background_from_func"><code class="name flex">
<span>def <span class="ident">make_background_from_func</span></span>(<span>self, coords_to_colors_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets background by using coords_to_colors_func to determine each pixel's color. Each input
to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not
pixel coordinates), and each output is expected to be an RGBA array of 4 floats.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_background_from_func(self, coords_to_colors_func):
    &#34;&#34;&#34;
    Sets background by using coords_to_colors_func to determine each pixel&#39;s color. Each input
    to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not
    pixel coordinates), and each output is expected to be an RGBA array of 4 floats.
    &#34;&#34;&#34;

    print(&#34;Starting set_background; for reference, the current time is &#34;, time.strftime(&#34;%H:%M:%S&#34;))
    coords = self.get_coords_of_all_pixels()
    new_background = np.apply_along_axis(
        coords_to_colors_func,
        2,
        coords
    )
    print(&#34;Ending set_background; for reference, the current time is &#34;, time.strftime(&#34;%H:%M:%S&#34;))

    return self.convert_pixel_array(new_background, convert_from_floats=True)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.on_screen_pixels"><code class="name flex">
<span>def <span class="ident">on_screen_pixels</span></span>(<span>self, pixel_coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_screen_pixels(self, pixel_coords):
    return reduce(op.and_, [
        pixel_coords[:, 0] &gt;= 0,
        pixel_coords[:, 0] &lt; self.get_pixel_width(),
        pixel_coords[:, 1] &gt;= 0,
        pixel_coords[:, 1] &lt; self.get_pixel_height(),
    ])</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.overlay_PIL_image"><code class="name flex">
<span>def <span class="ident">overlay_PIL_image</span></span>(<span>self, pixel_array, image)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlay_PIL_image(self, pixel_array, image):
    pixel_array[:, :] = np.array(
        Image.alpha_composite(
            self.get_image(pixel_array),
            image
        ),
        dtype=&#39;uint8&#39;
    )</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.overlay_rgba_array"><code class="name flex">
<span>def <span class="ident">overlay_rgba_array</span></span>(<span>self, pixel_array, new_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlay_rgba_array(self, pixel_array, new_array):
    self.overlay_PIL_image(
        pixel_array,
        self.get_image(new_array),
    )</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.points_to_pixel_coords"><code class="name flex">
<span>def <span class="ident">points_to_pixel_coords</span></span>(<span>self, mobject, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def points_to_pixel_coords(self, mobject, points):
    points = self.transform_points_pre_display(
        mobject, points
    )
    shifted_points = points - self.get_frame_center()

    result = np.zeros((len(points), 2))
    pixel_height = self.get_pixel_height()
    pixel_width = self.get_pixel_width()
    frame_height = self.get_frame_height()
    frame_width = self.get_frame_width()
    width_mult = pixel_width / frame_width
    width_add = pixel_width / 2
    height_mult = pixel_height / frame_height
    height_add = pixel_height / 2
    # Flip on y-axis as you go
    height_mult *= -1

    result[:, 0] = shifted_points[:, 0] * width_mult + width_add
    result[:, 1] = shifted_points[:, 1] * height_mult + height_add
    return result.astype(&#39;int&#39;)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.set_pixel_array(self.background)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.reset_pixel_shape"><code class="name flex">
<span>def <span class="ident">reset_pixel_shape</span></span>(<span>self, new_height, new_width)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_pixel_shape(self, new_height, new_width):
    self.pixel_width = new_width
    self.pixel_height = new_height
    self.init_background()
    self.resize_frame_shape()
    self.reset()</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.resize_frame_shape"><code class="name flex">
<span>def <span class="ident">resize_frame_shape</span></span>(<span>self, fixed_dimension=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes frame_shape to match the aspect ratio
of the pixels, where fixed_dimension determines
whether frame_height or frame_width
remains fixed while the other changes accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_frame_shape(self, fixed_dimension=0):
    &#34;&#34;&#34;
    Changes frame_shape to match the aspect ratio
    of the pixels, where fixed_dimension determines
    whether frame_height or frame_width
    remains fixed while the other changes accordingly.
    &#34;&#34;&#34;
    pixel_height = self.get_pixel_height()
    pixel_width = self.get_pixel_width()
    frame_height = self.get_frame_height()
    frame_width = self.get_frame_width()
    aspect_ratio = fdiv(pixel_width, pixel_height)
    if fixed_dimension == 0:
        frame_height = frame_width / aspect_ratio
    else:
        frame_width = aspect_ratio * frame_height
    self.set_frame_height(frame_height)
    self.set_frame_width(frame_width)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_background"><code class="name flex">
<span>def <span class="ident">set_background</span></span>(<span>self, pixel_array, convert_from_floats=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_background(self, pixel_array, convert_from_floats=False):
    self.background = self.convert_pixel_array(
        pixel_array, convert_from_floats)</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_background_from_func"><code class="name flex">
<span>def <span class="ident">set_background_from_func</span></span>(<span>self, coords_to_colors_func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_background_from_func(self, coords_to_colors_func):
    self.set_background(
        self.make_background_from_func(coords_to_colors_func))</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_cairo_context_color"><code class="name flex">
<span>def <span class="ident">set_cairo_context_color</span></span>(<span>self, ctx, rgbas, vmobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cairo_context_color(self, ctx, rgbas, vmobject):
    if len(rgbas) == 1:
        # Use reversed rgb because cairo surface is
        # encodes it in reverse order
        ctx.set_source_rgba(
            *rgbas[0][2::-1], rgbas[0][3]
        )
    else:
        points = vmobject.get_gradient_start_and_end_points()
        points = self.transform_points_pre_display(
            vmobject, points
        )
        pat = cairo.LinearGradient(*it.chain(*[
            point[:2] for point in points
        ]))
        step = 1.0 / (len(rgbas) - 1)
        offsets = np.arange(0, 1 + step, step)
        for rgba, offset in zip(rgbas, offsets):
            pat.add_color_stop_rgba(
                offset, *rgba[2::-1], rgba[3]
            )
        ctx.set_source(pat)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_cairo_context_path"><code class="name flex">
<span>def <span class="ident">set_cairo_context_path</span></span>(<span>self, ctx, vmobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cairo_context_path(self, ctx, vmobject):
    points = self.transform_points_pre_display(
        vmobject, vmobject.points
    )
    # TODO, shouldn&#39;t this be handled in transform_points_pre_display?
    # points = points - self.get_frame_center()
    if len(points) == 0:
        return

    ctx.new_path()
    subpaths = vmobject.gen_subpaths_from_points_2d(points)
    for subpath in subpaths:
        quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)
        ctx.new_sub_path()
        start = subpath[0]
        ctx.move_to(*start[:2])
        for p0, p1, p2, p3 in quads:
            ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])
        if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):
            ctx.close_path()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_frame_center"><code class="name flex">
<span>def <span class="ident">set_frame_center</span></span>(<span>self, frame_center)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frame_center(self, frame_center):
    self.frame_center = frame_center</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_frame_height"><code class="name flex">
<span>def <span class="ident">set_frame_height</span></span>(<span>self, frame_height)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frame_height(self, frame_height):
    self.frame_height = frame_height</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_frame_width"><code class="name flex">
<span>def <span class="ident">set_frame_width</span></span>(<span>self, frame_width)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frame_width(self, frame_width):
    self.frame_width = frame_width</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.set_pixel_array"><code class="name flex">
<span>def <span class="ident">set_pixel_array</span></span>(<span>self, pixel_array, convert_from_floats=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pixel_array(self, pixel_array, convert_from_floats=False):
    converted_array = self.convert_pixel_array(
        pixel_array, convert_from_floats)
    if not (hasattr(self, &#34;pixel_array&#34;) and self.pixel_array.shape == converted_array.shape):
        self.pixel_array = converted_array
    else:
        # Set in place
        self.pixel_array[:, :, :] = converted_array[:, :, :]</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.thickened_coordinates"><code class="name flex">
<span>def <span class="ident">thickened_coordinates</span></span>(<span>self, pixel_coords, thickness)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thickened_coordinates(self, pixel_coords, thickness):
    nudges = self.get_thickening_nudges(thickness)
    pixel_coords = np.array([
        pixel_coords + nudge
        for nudge in nudges
    ])
    size = pixel_coords.size
    return pixel_coords.reshape((size // 2, 2))</code></pre>
</details>
</dd>
<dt id="manimlib.camera.camera.Camera.transform_points_pre_display"><code class="name flex">
<span>def <span class="ident">transform_points_pre_display</span></span>(<span>self, mobject, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_points_pre_display(self, mobject, points):
    # Subclasses (like ThreeDCamera) may want to
    # adjust points futher before they&#39;re shown
    if not np.all(np.isfinite(points)):
        # TODO, print some kind of warning about
        # mobject having invalid points?
        points = np.zeros((1, 3))
    return points</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.camera" href="index.html">manimlib.camera</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer" href="#manimlib.camera.camera.BackgroundColoredVMobjectDisplayer">BackgroundColoredVMobjectDisplayer</a></code></h4>
<ul class="">
<li><code><a title="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.display" href="#manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.display">display</a></code></li>
<li><code><a title="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.get_background_array" href="#manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.get_background_array">get_background_array</a></code></li>
<li><code><a title="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.reset_pixel_array" href="#manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.reset_pixel_array">reset_pixel_array</a></code></li>
<li><code><a title="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.resize_background_array" href="#manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.resize_background_array">resize_background_array</a></code></li>
<li><code><a title="manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.resize_background_array_to_match" href="#manimlib.camera.camera.BackgroundColoredVMobjectDisplayer.resize_background_array_to_match">resize_background_array_to_match</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.camera.camera.Camera" href="#manimlib.camera.camera.Camera">Camera</a></code></h4>
<ul class="">
<li><code><a title="manimlib.camera.camera.Camera.CONFIG" href="#manimlib.camera.camera.Camera.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.adjust_out_of_range_points" href="#manimlib.camera.camera.Camera.adjust_out_of_range_points">adjust_out_of_range_points</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.adjusted_thickness" href="#manimlib.camera.camera.Camera.adjusted_thickness">adjusted_thickness</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.apply_fill" href="#manimlib.camera.camera.Camera.apply_fill">apply_fill</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.apply_stroke" href="#manimlib.camera.camera.Camera.apply_stroke">apply_stroke</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.cache_cairo_context" href="#manimlib.camera.camera.Camera.cache_cairo_context">cache_cairo_context</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.capture_mobject" href="#manimlib.camera.camera.Camera.capture_mobject">capture_mobject</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.capture_mobjects" href="#manimlib.camera.camera.Camera.capture_mobjects">capture_mobjects</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.convert_pixel_array" href="#manimlib.camera.camera.Camera.convert_pixel_array">convert_pixel_array</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_image_mobject" href="#manimlib.camera.camera.Camera.display_image_mobject">display_image_mobject</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_multiple_background_colored_vmobject" href="#manimlib.camera.camera.Camera.display_multiple_background_colored_vmobject">display_multiple_background_colored_vmobject</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_multiple_image_mobjects" href="#manimlib.camera.camera.Camera.display_multiple_image_mobjects">display_multiple_image_mobjects</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_multiple_non_background_colored_vmobjects" href="#manimlib.camera.camera.Camera.display_multiple_non_background_colored_vmobjects">display_multiple_non_background_colored_vmobjects</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_multiple_point_cloud_mobjects" href="#manimlib.camera.camera.Camera.display_multiple_point_cloud_mobjects">display_multiple_point_cloud_mobjects</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_multiple_vectorized_mobjects" href="#manimlib.camera.camera.Camera.display_multiple_vectorized_mobjects">display_multiple_vectorized_mobjects</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_point_cloud" href="#manimlib.camera.camera.Camera.display_point_cloud">display_point_cloud</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.display_vectorized" href="#manimlib.camera.camera.Camera.display_vectorized">display_vectorized</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.extract_mobject_family_members" href="#manimlib.camera.camera.Camera.extract_mobject_family_members">extract_mobject_family_members</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_background_colored_vmobject_displayer" href="#manimlib.camera.camera.Camera.get_background_colored_vmobject_displayer">get_background_colored_vmobject_displayer</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_cached_cairo_context" href="#manimlib.camera.camera.Camera.get_cached_cairo_context">get_cached_cairo_context</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_cairo_context" href="#manimlib.camera.camera.Camera.get_cairo_context">get_cairo_context</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_coords_of_all_pixels" href="#manimlib.camera.camera.Camera.get_coords_of_all_pixels">get_coords_of_all_pixels</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_fill_rgbas" href="#manimlib.camera.camera.Camera.get_fill_rgbas">get_fill_rgbas</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_frame_center" href="#manimlib.camera.camera.Camera.get_frame_center">get_frame_center</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_frame_height" href="#manimlib.camera.camera.Camera.get_frame_height">get_frame_height</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_frame_width" href="#manimlib.camera.camera.Camera.get_frame_width">get_frame_width</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_image" href="#manimlib.camera.camera.Camera.get_image">get_image</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_mobjects_to_display" href="#manimlib.camera.camera.Camera.get_mobjects_to_display">get_mobjects_to_display</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_pixel_array" href="#manimlib.camera.camera.Camera.get_pixel_array">get_pixel_array</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_pixel_height" href="#manimlib.camera.camera.Camera.get_pixel_height">get_pixel_height</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_pixel_width" href="#manimlib.camera.camera.Camera.get_pixel_width">get_pixel_width</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_stroke_rgbas" href="#manimlib.camera.camera.Camera.get_stroke_rgbas">get_stroke_rgbas</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.get_thickening_nudges" href="#manimlib.camera.camera.Camera.get_thickening_nudges">get_thickening_nudges</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.init_background" href="#manimlib.camera.camera.Camera.init_background">init_background</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.is_in_frame" href="#manimlib.camera.camera.Camera.is_in_frame">is_in_frame</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.make_background_from_func" href="#manimlib.camera.camera.Camera.make_background_from_func">make_background_from_func</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.on_screen_pixels" href="#manimlib.camera.camera.Camera.on_screen_pixels">on_screen_pixels</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.overlay_PIL_image" href="#manimlib.camera.camera.Camera.overlay_PIL_image">overlay_PIL_image</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.overlay_rgba_array" href="#manimlib.camera.camera.Camera.overlay_rgba_array">overlay_rgba_array</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.points_to_pixel_coords" href="#manimlib.camera.camera.Camera.points_to_pixel_coords">points_to_pixel_coords</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.reset" href="#manimlib.camera.camera.Camera.reset">reset</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.reset_pixel_shape" href="#manimlib.camera.camera.Camera.reset_pixel_shape">reset_pixel_shape</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.resize_frame_shape" href="#manimlib.camera.camera.Camera.resize_frame_shape">resize_frame_shape</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_background" href="#manimlib.camera.camera.Camera.set_background">set_background</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_background_from_func" href="#manimlib.camera.camera.Camera.set_background_from_func">set_background_from_func</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_cairo_context_color" href="#manimlib.camera.camera.Camera.set_cairo_context_color">set_cairo_context_color</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_cairo_context_path" href="#manimlib.camera.camera.Camera.set_cairo_context_path">set_cairo_context_path</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_frame_center" href="#manimlib.camera.camera.Camera.set_frame_center">set_frame_center</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_frame_height" href="#manimlib.camera.camera.Camera.set_frame_height">set_frame_height</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_frame_width" href="#manimlib.camera.camera.Camera.set_frame_width">set_frame_width</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.set_pixel_array" href="#manimlib.camera.camera.Camera.set_pixel_array">set_pixel_array</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.thickened_coordinates" href="#manimlib.camera.camera.Camera.thickened_coordinates">thickened_coordinates</a></code></li>
<li><code><a title="manimlib.camera.camera.Camera.transform_points_pre_display" href="#manimlib.camera.camera.Camera.transform_points_pre_display">transform_points_pre_display</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>