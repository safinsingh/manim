<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.once_useful_constructs.light API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.once_useful_constructs.light</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from traceback import *

from scipy.spatial import ConvexHull

from manimlib.animation.composition import LaggedStartMap
from manimlib.animation.fading import FadeIn
from manimlib.animation.fading import FadeOut
from manimlib.animation.transform import Transform
from manimlib.constants import *
from manimlib.mobject.geometry import AnnularSector
from manimlib.mobject.geometry import Annulus
from manimlib.mobject.svg.svg_mobject import SVGMobject
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.mobject.types.vectorized_mobject import VectorizedPoint
from manimlib.utils.space_ops import angle_between_vectors
from manimlib.utils.space_ops import project_along_vector
from manimlib.utils.space_ops import rotate_vector
from manimlib.utils.space_ops import z_to_vector

LIGHT_COLOR = YELLOW
SHADOW_COLOR = BLACK
SWITCH_ON_RUN_TIME = 1.5
FAST_SWITCH_ON_RUN_TIME = 0.1
NUM_LEVELS = 30
NUM_CONES = 7  # in first lighthouse scene
NUM_VISIBLE_CONES = 5  # ibidem
ARC_TIP_LENGTH = 0.2
AMBIENT_FULL = 0.8
AMBIENT_DIMMED = 0.5
SPOTLIGHT_FULL = 0.8
SPOTLIGHT_DIMMED = 0.5
LIGHTHOUSE_HEIGHT = 0.8

DEGREES = TAU / 360


def inverse_power_law(maxint, scale, cutoff, exponent):
    return (lambda r: maxint * (cutoff / (r / scale + cutoff))**exponent)


def inverse_quadratic(maxint, scale, cutoff):
    return inverse_power_law(maxint, scale, cutoff, 2)


class SwitchOn(LaggedStartMap):
    CONFIG = {
        &#34;lag_ratio&#34;: 0.2,
        &#34;run_time&#34;: SWITCH_ON_RUN_TIME
    }

    def __init__(self, light, **kwargs):
        if (not isinstance(light, AmbientLight) and not isinstance(light, Spotlight)):
            raise Exception(
                &#34;Only AmbientLights and Spotlights can be switched on&#34;)
        LaggedStartMap.__init__(
            self, FadeIn, light, **kwargs
        )


class SwitchOff(LaggedStartMap):
    CONFIG = {
        &#34;lag_ratio&#34;: 0.2,
        &#34;run_time&#34;: SWITCH_ON_RUN_TIME
    }

    def __init__(self, light, **kwargs):
        if (not isinstance(light, AmbientLight) and not isinstance(light, Spotlight)):
            raise Exception(
                &#34;Only AmbientLights and Spotlights can be switched off&#34;)
        light.submobjects = light.submobjects[::-1]
        LaggedStartMap.__init__(self, FadeOut, light, **kwargs)
        light.submobjects = light.submobjects[::-1]


class Lighthouse(SVGMobject):
    CONFIG = {
        &#34;file_name&#34;: &#34;lighthouse&#34;,
        &#34;height&#34;: LIGHTHOUSE_HEIGHT,
        &#34;fill_color&#34;: WHITE,
        &#34;fill_opacity&#34;: 1.0,
    }

    def move_to(self, point):
        self.next_to(point, DOWN, buff=0)


class AmbientLight(VMobject):

    # Parameters are:
    # * a source point
    # * an opacity function
    # * a light color
    # * a max opacity
    # * a radius (larger than the opacity&#39;s dropoff length)
    # * the number of subdivisions (levels, annuli)

    CONFIG = {
        &#34;source_point&#34;: VectorizedPoint(location=ORIGIN, stroke_width=0, fill_opacity=0),
        &#34;opacity_function&#34;: lambda r: 1.0 / (r + 1.0)**2,
        &#34;color&#34;: LIGHT_COLOR,
        &#34;max_opacity&#34;: 1.0,
        &#34;num_levels&#34;: NUM_LEVELS,
        &#34;radius&#34;: 5.0
    }

    def generate_points(self):
        # in theory, this method is only called once, right?
        # so removing submobs shd not be necessary
        #
        # Note: Usually, yes, it is only called within Mobject.__init__,
        # but there is no strong guarantee of that, and you may want certain
        # update functions to regenerate points here and there.
        for submob in self.submobjects:
            self.remove(submob)

        self.add(self.source_point)

        # create annuli
        self.radius = float(self.radius)
        dr = self.radius / self.num_levels
        for r in np.arange(0, self.radius, dr):
            alpha = self.max_opacity * self.opacity_function(r)
            annulus = Annulus(
                inner_radius=r,
                outer_radius=r + dr,
                color=self.color,
                fill_opacity=alpha
            )
            annulus.move_to(self.get_source_point())
            self.add(annulus)

    def move_source_to(self, point):
        # old_source_point = self.get_source_point()
        # self.shift(point - old_source_point)
        self.move_to(point)

        return self

    def get_source_point(self):
        return self.source_point.get_location()

    def dimming(self, new_alpha):
        old_alpha = self.max_opacity
        self.max_opacity = new_alpha
        for submob in self.submobjects:
            old_submob_alpha = submob.fill_opacity
            new_submob_alpha = old_submob_alpha * new_alpha / old_alpha
            submob.set_fill(opacity=new_submob_alpha)


class Spotlight(VMobject):
    CONFIG = {
        &#34;source_point&#34;: VectorizedPoint(location=ORIGIN, stroke_width=0, fill_opacity=0),
        &#34;opacity_function&#34;: lambda r: 1.0 / (r / 2 + 1.0)**2,
        &#34;color&#34;: GREEN,  # LIGHT_COLOR,
        &#34;max_opacity&#34;: 1.0,
        &#34;num_levels&#34;: 10,
        &#34;radius&#34;: 10.0,
        &#34;screen&#34;: None,
        &#34;camera_mob&#34;: None
    }

    def projection_direction(self):
        # Note: This seems reasonable, though for it to work you&#39;d
        # need to be sure that any 3d scene including a spotlight
        # somewhere assigns that spotlights &#34;camera&#34; attribute
        # to be the camera associated with that scene.
        if self.camera_mob is None:
            return OUT
        else:
            [phi, theta, r] = self.camera_mob.get_center()
            v = np.array([np.sin(phi) * np.cos(theta),
                          np.sin(phi) * np.sin(theta), np.cos(phi)])
            return v  # /get_norm(v)

    def project(self, point):
        v = self.projection_direction()
        w = project_along_vector(point, v)
        return w

    def get_source_point(self):
        return self.source_point.get_location()

    def generate_points(self):
        self.submobjects = []

        self.add(self.source_point)

        if self.screen is not None:
            # look for the screen and create annular sectors
            lower_angle, upper_angle = self.viewing_angles(self.screen)
            self.radius = float(self.radius)
            dr = self.radius / self.num_levels
            lower_ray, upper_ray = self.viewing_rays(self.screen)

            for r in np.arange(0, self.radius, dr):
                new_sector = self.new_sector(r, dr, lower_angle, upper_angle)
                self.add(new_sector)

    def new_sector(self, r, dr, lower_angle, upper_angle):
        alpha = self.max_opacity * self.opacity_function(r)
        annular_sector = AnnularSector(
            inner_radius=r,
            outer_radius=r + dr,
            color=self.color,
            fill_opacity=alpha,
            start_angle=lower_angle,
            angle=upper_angle - lower_angle
        )
        # rotate (not project) it into the viewing plane
        rotation_matrix = z_to_vector(self.projection_direction())
        annular_sector.apply_matrix(rotation_matrix)
        # now rotate it inside that plane
        rotated_RIGHT = np.dot(RIGHT, rotation_matrix.T)
        projected_RIGHT = self.project(RIGHT)
        omega = angle_between_vectors(rotated_RIGHT, projected_RIGHT)
        annular_sector.rotate(omega, axis=self.projection_direction())
        annular_sector.move_arc_center_to(self.get_source_point())

        return annular_sector

    def viewing_angle_of_point(self, point):
        # as measured from the positive x-axis
        v1 = self.project(RIGHT)
        v2 = self.project(np.array(point) - self.get_source_point())
        absolute_angle = angle_between_vectors(v1, v2)
        # determine the angle&#39;s sign depending on their plane&#39;s
        # choice of orientation. That choice is set by the camera
        # position, i. e. projection direction

        if np.dot(self.projection_direction(), np.cross(v1, v2)) &gt; 0:
            return absolute_angle
        else:
            return -absolute_angle

    def viewing_angles(self, screen):

        screen_points = screen.get_anchors()
        projected_screen_points = list(map(self.project, screen_points))

        viewing_angles = np.array(list(map(self.viewing_angle_of_point,
                                           projected_screen_points)))

        lower_angle = upper_angle = 0
        if len(viewing_angles) != 0:
            lower_angle = np.min(viewing_angles)
            upper_angle = np.max(viewing_angles)

        if upper_angle - lower_angle &gt; TAU / 2:
            lower_angle, upper_angle = upper_angle, lower_angle + TAU
        return lower_angle, upper_angle

    def viewing_rays(self, screen):

        lower_angle, upper_angle = self.viewing_angles(screen)
        projected_RIGHT = self.project(
            RIGHT) / get_norm(self.project(RIGHT))
        lower_ray = rotate_vector(
            projected_RIGHT, lower_angle, axis=self.projection_direction())
        upper_ray = rotate_vector(
            projected_RIGHT, upper_angle, axis=self.projection_direction())

        return lower_ray, upper_ray

    def opening_angle(self):
        l, u = self.viewing_angles(self.screen)
        return u - l

    def start_angle(self):
        l, u = self.viewing_angles(self.screen)
        return l

    def stop_angle(self):
        l, u = self.viewing_angles(self.screen)
        return u

    def move_source_to(self, point):
        self.source_point.set_location(np.array(point))
        # self.source_point.move_to(np.array(point))
        # self.move_to(point)
        self.update_sectors()
        return self

    def update_sectors(self):
        if self.screen is None:
            return
        for submob in self.submobjects:
            if type(submob) == AnnularSector:
                lower_angle, upper_angle = self.viewing_angles(self.screen)
                # dr = submob.outer_radius - submob.inner_radius
                dr = self.radius / self.num_levels
                new_submob = self.new_sector(
                    submob.inner_radius, dr, lower_angle, upper_angle
                )
                # submob.points = new_submob.points
                # submob.set_fill(opacity = 10 * self.opacity_function(submob.outer_radius))
                Transform(submob, new_submob).update(1)

    def dimming(self, new_alpha):
        old_alpha = self.max_opacity
        self.max_opacity = new_alpha
        for submob in self.submobjects:
            # Note: Maybe it&#39;d be best to have a Shadow class so that the
            # type can be checked directly?
            if type(submob) != AnnularSector:
                # it&#39;s the shadow, don&#39;t dim it
                continue
            old_submob_alpha = submob.fill_opacity
            new_submob_alpha = old_submob_alpha * new_alpha / old_alpha
            submob.set_fill(opacity=new_submob_alpha)

    def change_opacity_function(self, new_f):
        self.opacity_function = new_f
        dr = self.radius / self.num_levels

        sectors = []
        for submob in self.submobjects:
            if type(submob) == AnnularSector:
                sectors.append(submob)

        for (r, submob) in zip(np.arange(0, self.radius, dr), sectors):
            if type(submob) != AnnularSector:
                # it&#39;s the shadow, don&#39;t dim it
                continue
            alpha = self.opacity_function(r)
            submob.set_fill(opacity=alpha)

# Warning: This class is likely quite buggy.


class LightSource(VMobject):
    # combines:
    # a lighthouse
    # an ambient light
    # a spotlight
    # and a shadow
    CONFIG = {
        &#34;source_point&#34;: VectorizedPoint(location=ORIGIN, stroke_width=0, fill_opacity=0),
        &#34;color&#34;: LIGHT_COLOR,
        &#34;num_levels&#34;: 10,
        &#34;radius&#34;: 10.0,
        &#34;screen&#34;: None,
        &#34;opacity_function&#34;: inverse_quadratic(1, 2, 1),
        &#34;max_opacity_ambient&#34;: AMBIENT_FULL,
        &#34;max_opacity_spotlight&#34;: SPOTLIGHT_FULL,
        &#34;camera_mob&#34;: None
    }

    def generate_points(self):

        self.add(self.source_point)

        self.lighthouse = Lighthouse()
        self.ambient_light = AmbientLight(
            source_point=VectorizedPoint(location=self.get_source_point()),
            color=self.color,
            num_levels=self.num_levels,
            radius=self.radius,
            opacity_function=self.opacity_function,
            max_opacity=self.max_opacity_ambient
        )
        if self.has_screen():
            self.spotlight = Spotlight(
                source_point=VectorizedPoint(location=self.get_source_point()),
                color=self.color,
                num_levels=self.num_levels,
                radius=self.radius,
                screen=self.screen,
                opacity_function=self.opacity_function,
                max_opacity=self.max_opacity_spotlight,
                camera_mob=self.camera_mob
            )
        else:
            self.spotlight = Spotlight()

        self.shadow = VMobject(fill_color=SHADOW_COLOR,
                               fill_opacity=1.0, stroke_color=BLACK)
        self.lighthouse.next_to(self.get_source_point(), DOWN, buff=0)
        self.ambient_light.move_source_to(self.get_source_point())

        if self.has_screen():
            self.spotlight.move_source_to(self.get_source_point())
            self.update_shadow()

        self.add(self.ambient_light, self.spotlight,
                 self.lighthouse, self.shadow)

    def has_screen(self):
        if self.screen is None:
            return False
        elif np.size(self.screen.points) == 0:
            return False
        else:
            return True

    def dim_ambient(self):
        self.set_max_opacity_ambient(AMBIENT_DIMMED)

    def set_max_opacity_ambient(self, new_opacity):
        self.max_opacity_ambient = new_opacity
        self.ambient_light.dimming(new_opacity)

    def dim_spotlight(self):
        self.set_max_opacity_spotlight(SPOTLIGHT_DIMMED)

    def set_max_opacity_spotlight(self, new_opacity):
        self.max_opacity_spotlight = new_opacity
        self.spotlight.dimming(new_opacity)

    def set_camera_mob(self, new_cam_mob):
        self.camera_mob = new_cam_mob
        self.spotlight.camera_mob = new_cam_mob

    def set_screen(self, new_screen):
        if self.has_screen():
            self.spotlight.screen = new_screen
        else:
            # Note: See below
            index = self.submobjects.index(self.spotlight)
            # camera_mob = self.spotlight.camera_mob
            self.remove(self.spotlight)
            self.spotlight = Spotlight(
                source_point=VectorizedPoint(location=self.get_source_point()),
                color=self.color,
                num_levels=self.num_levels,
                radius=self.radius,
                screen=new_screen,
                camera_mob=self.camera_mob,
                opacity_function=self.opacity_function,
                max_opacity=self.max_opacity_spotlight,
            )
            self.spotlight.move_source_to(self.get_source_point())

            # Note: This line will make spotlight show up at the end
            # of the submojects list, which can make it show up on
            # top of the shadow. To make it show up in the
            # same spot, you could try the following line,
            # where &#34;index&#34; is what I defined above:
            self.submobjects.insert(index, self.spotlight)
            # self.add(self.spotlight)

        # in any case
        self.screen = new_screen

    def move_source_to(self, point):
        apoint = np.array(point)
        v = apoint - self.get_source_point()
        # Note: As discussed, things stand to behave better if source
        # point is a submobject, so that it automatically interpolates
        # during an animation, and other updates can be defined wrt
        # that source point&#39;s location
        self.source_point.set_location(apoint)
        # self.lighthouse.next_to(apoint,DOWN,buff = 0)
        # self.ambient_light.move_source_to(apoint)
        self.lighthouse.shift(v)
        # self.ambient_light.shift(v)
        self.ambient_light.move_source_to(apoint)
        if self.has_screen():
            self.spotlight.move_source_to(apoint)
        self.update()
        return self

    def change_spotlight_opacity_function(self, new_of):
        self.spotlight.change_opacity_function(new_of)

    def set_radius(self, new_radius):
        self.radius = new_radius
        self.ambient_light.radius = new_radius
        self.spotlight.radius = new_radius

    def update(self):
        self.update_lighthouse()
        self.update_ambient()
        self.spotlight.update_sectors()
        self.update_shadow()

    def update_lighthouse(self):
        self.lighthouse.move_to(self.get_source_point())
        # new_lh = Lighthouse()
        # new_lh.move_to(ORIGIN)
        # new_lh.apply_matrix(self.rotation_matrix())
        # new_lh.shift(self.get_source_point())
        # self.lighthouse.submobjects = new_lh.submobjects

    def update_ambient(self):
        new_ambient_light = AmbientLight(
            source_point=VectorizedPoint(location=ORIGIN),
            color=self.color,
            num_levels=self.num_levels,
            radius=self.radius,
            opacity_function=self.opacity_function,
            max_opacity=self.max_opacity_ambient
        )
        new_ambient_light.apply_matrix(self.rotation_matrix())
        new_ambient_light.move_source_to(self.get_source_point())
        self.ambient_light.submobjects = new_ambient_light.submobjects

    def get_source_point(self):
        return self.source_point.get_location()

    def rotation_matrix(self):

        if self.camera_mob is None:
            return np.eye(3)

        phi = self.camera_mob.get_center()[0]
        theta = self.camera_mob.get_center()[1]

        R1 = np.array([
            [1, 0, 0],
            [0, np.cos(phi), -np.sin(phi)],
            [0, np.sin(phi), np.cos(phi)]
        ])

        R2 = np.array([
            [np.cos(theta + TAU / 4), -np.sin(theta + TAU / 4), 0],
            [np.sin(theta + TAU / 4), np.cos(theta + TAU / 4), 0],
            [0, 0, 1]
        ])

        R = np.dot(R2, R1)
        return R

    def update_shadow(self):
        point = self.get_source_point()
        projected_screen_points = []
        if not self.has_screen():
            return
        for point in self.screen.get_anchors():
            projected_screen_points.append(self.spotlight.project(point))

        projected_source = project_along_vector(
            self.get_source_point(), self.spotlight.projection_direction())

        projected_point_cloud_3d = np.append(
            projected_screen_points,
            np.reshape(projected_source, (1, 3)),
            axis=0
        )
        # z_to_vector(self.spotlight.projection_direction())
        rotation_matrix = self.rotation_matrix()
        back_rotation_matrix = rotation_matrix.T  # i. e. its inverse

        rotated_point_cloud_3d = np.dot(
            projected_point_cloud_3d, back_rotation_matrix.T)
        # these points now should all have z = 0

        point_cloud_2d = rotated_point_cloud_3d[:, :2]
        # now we can compute the convex hull
        hull_2d = ConvexHull(point_cloud_2d)  # guaranteed to run ccw
        hull = []

        # we also need the projected source point
        source_point_2d = np.dot(self.spotlight.project(
            self.get_source_point()), back_rotation_matrix.T)[:2]

        index = 0
        for point in point_cloud_2d[hull_2d.vertices]:
            if np.all(np.abs(point - source_point_2d) &lt; 1.0e-6):
                source_index = index
                index += 1
                continue
            point_3d = np.array([point[0], point[1], 0])
            hull.append(point_3d)
            index += 1

        hull_mobject = VMobject()
        hull_mobject.set_points_as_corners(hull)
        hull_mobject.apply_matrix(rotation_matrix)

        anchors = hull_mobject.get_anchors()

        # add two control points for the outer cone
        if np.size(anchors) == 0:
            self.shadow.points = []
            return

        ray1 = anchors[source_index - 1] - projected_source
        ray1 = ray1 / get_norm(ray1) * 100

        ray2 = anchors[source_index] - projected_source
        ray2 = ray2 / get_norm(ray2) * 100
        outpoint1 = anchors[source_index - 1] + ray1
        outpoint2 = anchors[source_index] + ray2

        new_anchors = anchors[:source_index]
        new_anchors = np.append(new_anchors, np.array(
            [outpoint1, outpoint2]), axis=0)
        new_anchors = np.append(new_anchors, anchors[source_index:], axis=0)
        self.shadow.set_points_as_corners(new_anchors)

        # shift it closer to the camera so it is in front of the spotlight
        self.shadow.mark_paths_closed = True


# Redefining what was once a ContinualAnimation class
# as a function
def ScreenTracker(light_source):
    light_source.add_updater(lambda m: m.update())
    return light_source</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="manimlib.once_useful_constructs.light.ScreenTracker"><code class="name flex">
<span>def <span class="ident">ScreenTracker</span></span>(<span>light_source)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ScreenTracker(light_source):
    light_source.add_updater(lambda m: m.update())
    return light_source</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.inverse_power_law"><code class="name flex">
<span>def <span class="ident">inverse_power_law</span></span>(<span>maxint, scale, cutoff, exponent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse_power_law(maxint, scale, cutoff, exponent):
    return (lambda r: maxint * (cutoff / (r / scale + cutoff))**exponent)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.inverse_quadratic"><code class="name flex">
<span>def <span class="ident">inverse_quadratic</span></span>(<span>maxint, scale, cutoff)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse_quadratic(maxint, scale, cutoff):
    return inverse_power_law(maxint, scale, cutoff, 2)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.once_useful_constructs.light.AmbientLight"><code class="flex name class">
<span>class <span class="ident">AmbientLight</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmbientLight(VMobject):

    # Parameters are:
    # * a source point
    # * an opacity function
    # * a light color
    # * a max opacity
    # * a radius (larger than the opacity&#39;s dropoff length)
    # * the number of subdivisions (levels, annuli)

    CONFIG = {
        &#34;source_point&#34;: VectorizedPoint(location=ORIGIN, stroke_width=0, fill_opacity=0),
        &#34;opacity_function&#34;: lambda r: 1.0 / (r + 1.0)**2,
        &#34;color&#34;: LIGHT_COLOR,
        &#34;max_opacity&#34;: 1.0,
        &#34;num_levels&#34;: NUM_LEVELS,
        &#34;radius&#34;: 5.0
    }

    def generate_points(self):
        # in theory, this method is only called once, right?
        # so removing submobs shd not be necessary
        #
        # Note: Usually, yes, it is only called within Mobject.__init__,
        # but there is no strong guarantee of that, and you may want certain
        # update functions to regenerate points here and there.
        for submob in self.submobjects:
            self.remove(submob)

        self.add(self.source_point)

        # create annuli
        self.radius = float(self.radius)
        dr = self.radius / self.num_levels
        for r in np.arange(0, self.radius, dr):
            alpha = self.max_opacity * self.opacity_function(r)
            annulus = Annulus(
                inner_radius=r,
                outer_radius=r + dr,
                color=self.color,
                fill_opacity=alpha
            )
            annulus.move_to(self.get_source_point())
            self.add(annulus)

    def move_source_to(self, point):
        # old_source_point = self.get_source_point()
        # self.shift(point - old_source_point)
        self.move_to(point)

        return self

    def get_source_point(self):
        return self.source_point.get_location()

    def dimming(self, new_alpha):
        old_alpha = self.max_opacity
        self.max_opacity = new_alpha
        for submob in self.submobjects:
            old_submob_alpha = submob.fill_opacity
            new_submob_alpha = old_submob_alpha * new_alpha / old_alpha
            submob.set_fill(opacity=new_submob_alpha)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.AmbientLight.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.AmbientLight.dimming"><code class="name flex">
<span>def <span class="ident">dimming</span></span>(<span>self, new_alpha)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dimming(self, new_alpha):
    old_alpha = self.max_opacity
    self.max_opacity = new_alpha
    for submob in self.submobjects:
        old_submob_alpha = submob.fill_opacity
        new_submob_alpha = old_submob_alpha * new_alpha / old_alpha
        submob.set_fill(opacity=new_submob_alpha)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.AmbientLight.generate_points"><code class="name flex">
<span>def <span class="ident">generate_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_points(self):
    # in theory, this method is only called once, right?
    # so removing submobs shd not be necessary
    #
    # Note: Usually, yes, it is only called within Mobject.__init__,
    # but there is no strong guarantee of that, and you may want certain
    # update functions to regenerate points here and there.
    for submob in self.submobjects:
        self.remove(submob)

    self.add(self.source_point)

    # create annuli
    self.radius = float(self.radius)
    dr = self.radius / self.num_levels
    for r in np.arange(0, self.radius, dr):
        alpha = self.max_opacity * self.opacity_function(r)
        annulus = Annulus(
            inner_radius=r,
            outer_radius=r + dr,
            color=self.color,
            fill_opacity=alpha
        )
        annulus.move_to(self.get_source_point())
        self.add(annulus)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.AmbientLight.get_source_point"><code class="name flex">
<span>def <span class="ident">get_source_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_source_point(self):
    return self.source_point.get_location()</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.AmbientLight.move_source_to"><code class="name flex">
<span>def <span class="ident">move_source_to</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_source_to(self, point):
    # old_source_point = self.get_source_point()
    # self.shift(point - old_source_point)
    self.move_to(point)

    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource"><code class="flex name class">
<span>class <span class="ident">LightSource</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LightSource(VMobject):
    # combines:
    # a lighthouse
    # an ambient light
    # a spotlight
    # and a shadow
    CONFIG = {
        &#34;source_point&#34;: VectorizedPoint(location=ORIGIN, stroke_width=0, fill_opacity=0),
        &#34;color&#34;: LIGHT_COLOR,
        &#34;num_levels&#34;: 10,
        &#34;radius&#34;: 10.0,
        &#34;screen&#34;: None,
        &#34;opacity_function&#34;: inverse_quadratic(1, 2, 1),
        &#34;max_opacity_ambient&#34;: AMBIENT_FULL,
        &#34;max_opacity_spotlight&#34;: SPOTLIGHT_FULL,
        &#34;camera_mob&#34;: None
    }

    def generate_points(self):

        self.add(self.source_point)

        self.lighthouse = Lighthouse()
        self.ambient_light = AmbientLight(
            source_point=VectorizedPoint(location=self.get_source_point()),
            color=self.color,
            num_levels=self.num_levels,
            radius=self.radius,
            opacity_function=self.opacity_function,
            max_opacity=self.max_opacity_ambient
        )
        if self.has_screen():
            self.spotlight = Spotlight(
                source_point=VectorizedPoint(location=self.get_source_point()),
                color=self.color,
                num_levels=self.num_levels,
                radius=self.radius,
                screen=self.screen,
                opacity_function=self.opacity_function,
                max_opacity=self.max_opacity_spotlight,
                camera_mob=self.camera_mob
            )
        else:
            self.spotlight = Spotlight()

        self.shadow = VMobject(fill_color=SHADOW_COLOR,
                               fill_opacity=1.0, stroke_color=BLACK)
        self.lighthouse.next_to(self.get_source_point(), DOWN, buff=0)
        self.ambient_light.move_source_to(self.get_source_point())

        if self.has_screen():
            self.spotlight.move_source_to(self.get_source_point())
            self.update_shadow()

        self.add(self.ambient_light, self.spotlight,
                 self.lighthouse, self.shadow)

    def has_screen(self):
        if self.screen is None:
            return False
        elif np.size(self.screen.points) == 0:
            return False
        else:
            return True

    def dim_ambient(self):
        self.set_max_opacity_ambient(AMBIENT_DIMMED)

    def set_max_opacity_ambient(self, new_opacity):
        self.max_opacity_ambient = new_opacity
        self.ambient_light.dimming(new_opacity)

    def dim_spotlight(self):
        self.set_max_opacity_spotlight(SPOTLIGHT_DIMMED)

    def set_max_opacity_spotlight(self, new_opacity):
        self.max_opacity_spotlight = new_opacity
        self.spotlight.dimming(new_opacity)

    def set_camera_mob(self, new_cam_mob):
        self.camera_mob = new_cam_mob
        self.spotlight.camera_mob = new_cam_mob

    def set_screen(self, new_screen):
        if self.has_screen():
            self.spotlight.screen = new_screen
        else:
            # Note: See below
            index = self.submobjects.index(self.spotlight)
            # camera_mob = self.spotlight.camera_mob
            self.remove(self.spotlight)
            self.spotlight = Spotlight(
                source_point=VectorizedPoint(location=self.get_source_point()),
                color=self.color,
                num_levels=self.num_levels,
                radius=self.radius,
                screen=new_screen,
                camera_mob=self.camera_mob,
                opacity_function=self.opacity_function,
                max_opacity=self.max_opacity_spotlight,
            )
            self.spotlight.move_source_to(self.get_source_point())

            # Note: This line will make spotlight show up at the end
            # of the submojects list, which can make it show up on
            # top of the shadow. To make it show up in the
            # same spot, you could try the following line,
            # where &#34;index&#34; is what I defined above:
            self.submobjects.insert(index, self.spotlight)
            # self.add(self.spotlight)

        # in any case
        self.screen = new_screen

    def move_source_to(self, point):
        apoint = np.array(point)
        v = apoint - self.get_source_point()
        # Note: As discussed, things stand to behave better if source
        # point is a submobject, so that it automatically interpolates
        # during an animation, and other updates can be defined wrt
        # that source point&#39;s location
        self.source_point.set_location(apoint)
        # self.lighthouse.next_to(apoint,DOWN,buff = 0)
        # self.ambient_light.move_source_to(apoint)
        self.lighthouse.shift(v)
        # self.ambient_light.shift(v)
        self.ambient_light.move_source_to(apoint)
        if self.has_screen():
            self.spotlight.move_source_to(apoint)
        self.update()
        return self

    def change_spotlight_opacity_function(self, new_of):
        self.spotlight.change_opacity_function(new_of)

    def set_radius(self, new_radius):
        self.radius = new_radius
        self.ambient_light.radius = new_radius
        self.spotlight.radius = new_radius

    def update(self):
        self.update_lighthouse()
        self.update_ambient()
        self.spotlight.update_sectors()
        self.update_shadow()

    def update_lighthouse(self):
        self.lighthouse.move_to(self.get_source_point())
        # new_lh = Lighthouse()
        # new_lh.move_to(ORIGIN)
        # new_lh.apply_matrix(self.rotation_matrix())
        # new_lh.shift(self.get_source_point())
        # self.lighthouse.submobjects = new_lh.submobjects

    def update_ambient(self):
        new_ambient_light = AmbientLight(
            source_point=VectorizedPoint(location=ORIGIN),
            color=self.color,
            num_levels=self.num_levels,
            radius=self.radius,
            opacity_function=self.opacity_function,
            max_opacity=self.max_opacity_ambient
        )
        new_ambient_light.apply_matrix(self.rotation_matrix())
        new_ambient_light.move_source_to(self.get_source_point())
        self.ambient_light.submobjects = new_ambient_light.submobjects

    def get_source_point(self):
        return self.source_point.get_location()

    def rotation_matrix(self):

        if self.camera_mob is None:
            return np.eye(3)

        phi = self.camera_mob.get_center()[0]
        theta = self.camera_mob.get_center()[1]

        R1 = np.array([
            [1, 0, 0],
            [0, np.cos(phi), -np.sin(phi)],
            [0, np.sin(phi), np.cos(phi)]
        ])

        R2 = np.array([
            [np.cos(theta + TAU / 4), -np.sin(theta + TAU / 4), 0],
            [np.sin(theta + TAU / 4), np.cos(theta + TAU / 4), 0],
            [0, 0, 1]
        ])

        R = np.dot(R2, R1)
        return R

    def update_shadow(self):
        point = self.get_source_point()
        projected_screen_points = []
        if not self.has_screen():
            return
        for point in self.screen.get_anchors():
            projected_screen_points.append(self.spotlight.project(point))

        projected_source = project_along_vector(
            self.get_source_point(), self.spotlight.projection_direction())

        projected_point_cloud_3d = np.append(
            projected_screen_points,
            np.reshape(projected_source, (1, 3)),
            axis=0
        )
        # z_to_vector(self.spotlight.projection_direction())
        rotation_matrix = self.rotation_matrix()
        back_rotation_matrix = rotation_matrix.T  # i. e. its inverse

        rotated_point_cloud_3d = np.dot(
            projected_point_cloud_3d, back_rotation_matrix.T)
        # these points now should all have z = 0

        point_cloud_2d = rotated_point_cloud_3d[:, :2]
        # now we can compute the convex hull
        hull_2d = ConvexHull(point_cloud_2d)  # guaranteed to run ccw
        hull = []

        # we also need the projected source point
        source_point_2d = np.dot(self.spotlight.project(
            self.get_source_point()), back_rotation_matrix.T)[:2]

        index = 0
        for point in point_cloud_2d[hull_2d.vertices]:
            if np.all(np.abs(point - source_point_2d) &lt; 1.0e-6):
                source_index = index
                index += 1
                continue
            point_3d = np.array([point[0], point[1], 0])
            hull.append(point_3d)
            index += 1

        hull_mobject = VMobject()
        hull_mobject.set_points_as_corners(hull)
        hull_mobject.apply_matrix(rotation_matrix)

        anchors = hull_mobject.get_anchors()

        # add two control points for the outer cone
        if np.size(anchors) == 0:
            self.shadow.points = []
            return

        ray1 = anchors[source_index - 1] - projected_source
        ray1 = ray1 / get_norm(ray1) * 100

        ray2 = anchors[source_index] - projected_source
        ray2 = ray2 / get_norm(ray2) * 100
        outpoint1 = anchors[source_index - 1] + ray1
        outpoint2 = anchors[source_index] + ray2

        new_anchors = anchors[:source_index]
        new_anchors = np.append(new_anchors, np.array(
            [outpoint1, outpoint2]), axis=0)
        new_anchors = np.append(new_anchors, anchors[source_index:], axis=0)
        self.shadow.set_points_as_corners(new_anchors)

        # shift it closer to the camera so it is in front of the spotlight
        self.shadow.mark_paths_closed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.LightSource.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.LightSource.change_spotlight_opacity_function"><code class="name flex">
<span>def <span class="ident">change_spotlight_opacity_function</span></span>(<span>self, new_of)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_spotlight_opacity_function(self, new_of):
    self.spotlight.change_opacity_function(new_of)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.dim_ambient"><code class="name flex">
<span>def <span class="ident">dim_ambient</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dim_ambient(self):
    self.set_max_opacity_ambient(AMBIENT_DIMMED)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.dim_spotlight"><code class="name flex">
<span>def <span class="ident">dim_spotlight</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dim_spotlight(self):
    self.set_max_opacity_spotlight(SPOTLIGHT_DIMMED)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.generate_points"><code class="name flex">
<span>def <span class="ident">generate_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_points(self):

    self.add(self.source_point)

    self.lighthouse = Lighthouse()
    self.ambient_light = AmbientLight(
        source_point=VectorizedPoint(location=self.get_source_point()),
        color=self.color,
        num_levels=self.num_levels,
        radius=self.radius,
        opacity_function=self.opacity_function,
        max_opacity=self.max_opacity_ambient
    )
    if self.has_screen():
        self.spotlight = Spotlight(
            source_point=VectorizedPoint(location=self.get_source_point()),
            color=self.color,
            num_levels=self.num_levels,
            radius=self.radius,
            screen=self.screen,
            opacity_function=self.opacity_function,
            max_opacity=self.max_opacity_spotlight,
            camera_mob=self.camera_mob
        )
    else:
        self.spotlight = Spotlight()

    self.shadow = VMobject(fill_color=SHADOW_COLOR,
                           fill_opacity=1.0, stroke_color=BLACK)
    self.lighthouse.next_to(self.get_source_point(), DOWN, buff=0)
    self.ambient_light.move_source_to(self.get_source_point())

    if self.has_screen():
        self.spotlight.move_source_to(self.get_source_point())
        self.update_shadow()

    self.add(self.ambient_light, self.spotlight,
             self.lighthouse, self.shadow)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.get_source_point"><code class="name flex">
<span>def <span class="ident">get_source_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_source_point(self):
    return self.source_point.get_location()</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.has_screen"><code class="name flex">
<span>def <span class="ident">has_screen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_screen(self):
    if self.screen is None:
        return False
    elif np.size(self.screen.points) == 0:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.move_source_to"><code class="name flex">
<span>def <span class="ident">move_source_to</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_source_to(self, point):
    apoint = np.array(point)
    v = apoint - self.get_source_point()
    # Note: As discussed, things stand to behave better if source
    # point is a submobject, so that it automatically interpolates
    # during an animation, and other updates can be defined wrt
    # that source point&#39;s location
    self.source_point.set_location(apoint)
    # self.lighthouse.next_to(apoint,DOWN,buff = 0)
    # self.ambient_light.move_source_to(apoint)
    self.lighthouse.shift(v)
    # self.ambient_light.shift(v)
    self.ambient_light.move_source_to(apoint)
    if self.has_screen():
        self.spotlight.move_source_to(apoint)
    self.update()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.rotation_matrix"><code class="name flex">
<span>def <span class="ident">rotation_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_matrix(self):

    if self.camera_mob is None:
        return np.eye(3)

    phi = self.camera_mob.get_center()[0]
    theta = self.camera_mob.get_center()[1]

    R1 = np.array([
        [1, 0, 0],
        [0, np.cos(phi), -np.sin(phi)],
        [0, np.sin(phi), np.cos(phi)]
    ])

    R2 = np.array([
        [np.cos(theta + TAU / 4), -np.sin(theta + TAU / 4), 0],
        [np.sin(theta + TAU / 4), np.cos(theta + TAU / 4), 0],
        [0, 0, 1]
    ])

    R = np.dot(R2, R1)
    return R</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.set_camera_mob"><code class="name flex">
<span>def <span class="ident">set_camera_mob</span></span>(<span>self, new_cam_mob)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_camera_mob(self, new_cam_mob):
    self.camera_mob = new_cam_mob
    self.spotlight.camera_mob = new_cam_mob</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.set_max_opacity_ambient"><code class="name flex">
<span>def <span class="ident">set_max_opacity_ambient</span></span>(<span>self, new_opacity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_max_opacity_ambient(self, new_opacity):
    self.max_opacity_ambient = new_opacity
    self.ambient_light.dimming(new_opacity)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.set_max_opacity_spotlight"><code class="name flex">
<span>def <span class="ident">set_max_opacity_spotlight</span></span>(<span>self, new_opacity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_max_opacity_spotlight(self, new_opacity):
    self.max_opacity_spotlight = new_opacity
    self.spotlight.dimming(new_opacity)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.set_radius"><code class="name flex">
<span>def <span class="ident">set_radius</span></span>(<span>self, new_radius)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_radius(self, new_radius):
    self.radius = new_radius
    self.ambient_light.radius = new_radius
    self.spotlight.radius = new_radius</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.set_screen"><code class="name flex">
<span>def <span class="ident">set_screen</span></span>(<span>self, new_screen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_screen(self, new_screen):
    if self.has_screen():
        self.spotlight.screen = new_screen
    else:
        # Note: See below
        index = self.submobjects.index(self.spotlight)
        # camera_mob = self.spotlight.camera_mob
        self.remove(self.spotlight)
        self.spotlight = Spotlight(
            source_point=VectorizedPoint(location=self.get_source_point()),
            color=self.color,
            num_levels=self.num_levels,
            radius=self.radius,
            screen=new_screen,
            camera_mob=self.camera_mob,
            opacity_function=self.opacity_function,
            max_opacity=self.max_opacity_spotlight,
        )
        self.spotlight.move_source_to(self.get_source_point())

        # Note: This line will make spotlight show up at the end
        # of the submojects list, which can make it show up on
        # top of the shadow. To make it show up in the
        # same spot, you could try the following line,
        # where &#34;index&#34; is what I defined above:
        self.submobjects.insert(index, self.spotlight)
        # self.add(self.spotlight)

    # in any case
    self.screen = new_screen</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    self.update_lighthouse()
    self.update_ambient()
    self.spotlight.update_sectors()
    self.update_shadow()</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.update_ambient"><code class="name flex">
<span>def <span class="ident">update_ambient</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ambient(self):
    new_ambient_light = AmbientLight(
        source_point=VectorizedPoint(location=ORIGIN),
        color=self.color,
        num_levels=self.num_levels,
        radius=self.radius,
        opacity_function=self.opacity_function,
        max_opacity=self.max_opacity_ambient
    )
    new_ambient_light.apply_matrix(self.rotation_matrix())
    new_ambient_light.move_source_to(self.get_source_point())
    self.ambient_light.submobjects = new_ambient_light.submobjects</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.update_lighthouse"><code class="name flex">
<span>def <span class="ident">update_lighthouse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_lighthouse(self):
    self.lighthouse.move_to(self.get_source_point())</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.LightSource.update_shadow"><code class="name flex">
<span>def <span class="ident">update_shadow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_shadow(self):
    point = self.get_source_point()
    projected_screen_points = []
    if not self.has_screen():
        return
    for point in self.screen.get_anchors():
        projected_screen_points.append(self.spotlight.project(point))

    projected_source = project_along_vector(
        self.get_source_point(), self.spotlight.projection_direction())

    projected_point_cloud_3d = np.append(
        projected_screen_points,
        np.reshape(projected_source, (1, 3)),
        axis=0
    )
    # z_to_vector(self.spotlight.projection_direction())
    rotation_matrix = self.rotation_matrix()
    back_rotation_matrix = rotation_matrix.T  # i. e. its inverse

    rotated_point_cloud_3d = np.dot(
        projected_point_cloud_3d, back_rotation_matrix.T)
    # these points now should all have z = 0

    point_cloud_2d = rotated_point_cloud_3d[:, :2]
    # now we can compute the convex hull
    hull_2d = ConvexHull(point_cloud_2d)  # guaranteed to run ccw
    hull = []

    # we also need the projected source point
    source_point_2d = np.dot(self.spotlight.project(
        self.get_source_point()), back_rotation_matrix.T)[:2]

    index = 0
    for point in point_cloud_2d[hull_2d.vertices]:
        if np.all(np.abs(point - source_point_2d) &lt; 1.0e-6):
            source_index = index
            index += 1
            continue
        point_3d = np.array([point[0], point[1], 0])
        hull.append(point_3d)
        index += 1

    hull_mobject = VMobject()
    hull_mobject.set_points_as_corners(hull)
    hull_mobject.apply_matrix(rotation_matrix)

    anchors = hull_mobject.get_anchors()

    # add two control points for the outer cone
    if np.size(anchors) == 0:
        self.shadow.points = []
        return

    ray1 = anchors[source_index - 1] - projected_source
    ray1 = ray1 / get_norm(ray1) * 100

    ray2 = anchors[source_index] - projected_source
    ray2 = ray2 / get_norm(ray2) * 100
    outpoint1 = anchors[source_index - 1] + ray1
    outpoint2 = anchors[source_index] + ray2

    new_anchors = anchors[:source_index]
    new_anchors = np.append(new_anchors, np.array(
        [outpoint1, outpoint2]), axis=0)
    new_anchors = np.append(new_anchors, anchors[source_index:], axis=0)
    self.shadow.set_points_as_corners(new_anchors)

    # shift it closer to the camera so it is in front of the spotlight
    self.shadow.mark_paths_closed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.once_useful_constructs.light.Lighthouse"><code class="flex name class">
<span>class <span class="ident">Lighthouse</span></span>
<span>(</span><span>file_name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lighthouse(SVGMobject):
    CONFIG = {
        &#34;file_name&#34;: &#34;lighthouse&#34;,
        &#34;height&#34;: LIGHTHOUSE_HEIGHT,
        &#34;fill_color&#34;: WHITE,
        &#34;fill_opacity&#34;: 1.0,
    }

    def move_to(self, point):
        self.next_to(point, DOWN, buff=0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.svg.svg_mobject.SVGMobject" href="../mobject/svg/svg_mobject.html#manimlib.mobject.svg.svg_mobject.SVGMobject">SVGMobject</a></li>
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.Lighthouse.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.Lighthouse.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to(self, point):
    self.next_to(point, DOWN, buff=0)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.svg.svg_mobject.SVGMobject" href="../mobject/svg/svg_mobject.html#manimlib.mobject.svg.svg_mobject.SVGMobject">SVGMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.add" href="../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.add_cubic_bezier_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.add_smooth_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.align_on_border" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.align_to" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.become" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.become_partial" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.consider_points_equals_2d" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.digest_mobject_attrs" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.gen_cubic_bezier_tuples_from_points" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.generate_rgbas_array" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_anchors_and_handles" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_coord" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_critical_point" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_fill_color" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_fill_opacity" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.get_point_mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.interpolate" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.null_point_align" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.remove" href="../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.repeat" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.scale" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.scale_handle_to_anchor_distances" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.svg.svg_mobject.SVGMobject.set_color" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight"><code class="flex name class">
<span>class <span class="ident">Spotlight</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mathematical Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spotlight(VMobject):
    CONFIG = {
        &#34;source_point&#34;: VectorizedPoint(location=ORIGIN, stroke_width=0, fill_opacity=0),
        &#34;opacity_function&#34;: lambda r: 1.0 / (r / 2 + 1.0)**2,
        &#34;color&#34;: GREEN,  # LIGHT_COLOR,
        &#34;max_opacity&#34;: 1.0,
        &#34;num_levels&#34;: 10,
        &#34;radius&#34;: 10.0,
        &#34;screen&#34;: None,
        &#34;camera_mob&#34;: None
    }

    def projection_direction(self):
        # Note: This seems reasonable, though for it to work you&#39;d
        # need to be sure that any 3d scene including a spotlight
        # somewhere assigns that spotlights &#34;camera&#34; attribute
        # to be the camera associated with that scene.
        if self.camera_mob is None:
            return OUT
        else:
            [phi, theta, r] = self.camera_mob.get_center()
            v = np.array([np.sin(phi) * np.cos(theta),
                          np.sin(phi) * np.sin(theta), np.cos(phi)])
            return v  # /get_norm(v)

    def project(self, point):
        v = self.projection_direction()
        w = project_along_vector(point, v)
        return w

    def get_source_point(self):
        return self.source_point.get_location()

    def generate_points(self):
        self.submobjects = []

        self.add(self.source_point)

        if self.screen is not None:
            # look for the screen and create annular sectors
            lower_angle, upper_angle = self.viewing_angles(self.screen)
            self.radius = float(self.radius)
            dr = self.radius / self.num_levels
            lower_ray, upper_ray = self.viewing_rays(self.screen)

            for r in np.arange(0, self.radius, dr):
                new_sector = self.new_sector(r, dr, lower_angle, upper_angle)
                self.add(new_sector)

    def new_sector(self, r, dr, lower_angle, upper_angle):
        alpha = self.max_opacity * self.opacity_function(r)
        annular_sector = AnnularSector(
            inner_radius=r,
            outer_radius=r + dr,
            color=self.color,
            fill_opacity=alpha,
            start_angle=lower_angle,
            angle=upper_angle - lower_angle
        )
        # rotate (not project) it into the viewing plane
        rotation_matrix = z_to_vector(self.projection_direction())
        annular_sector.apply_matrix(rotation_matrix)
        # now rotate it inside that plane
        rotated_RIGHT = np.dot(RIGHT, rotation_matrix.T)
        projected_RIGHT = self.project(RIGHT)
        omega = angle_between_vectors(rotated_RIGHT, projected_RIGHT)
        annular_sector.rotate(omega, axis=self.projection_direction())
        annular_sector.move_arc_center_to(self.get_source_point())

        return annular_sector

    def viewing_angle_of_point(self, point):
        # as measured from the positive x-axis
        v1 = self.project(RIGHT)
        v2 = self.project(np.array(point) - self.get_source_point())
        absolute_angle = angle_between_vectors(v1, v2)
        # determine the angle&#39;s sign depending on their plane&#39;s
        # choice of orientation. That choice is set by the camera
        # position, i. e. projection direction

        if np.dot(self.projection_direction(), np.cross(v1, v2)) &gt; 0:
            return absolute_angle
        else:
            return -absolute_angle

    def viewing_angles(self, screen):

        screen_points = screen.get_anchors()
        projected_screen_points = list(map(self.project, screen_points))

        viewing_angles = np.array(list(map(self.viewing_angle_of_point,
                                           projected_screen_points)))

        lower_angle = upper_angle = 0
        if len(viewing_angles) != 0:
            lower_angle = np.min(viewing_angles)
            upper_angle = np.max(viewing_angles)

        if upper_angle - lower_angle &gt; TAU / 2:
            lower_angle, upper_angle = upper_angle, lower_angle + TAU
        return lower_angle, upper_angle

    def viewing_rays(self, screen):

        lower_angle, upper_angle = self.viewing_angles(screen)
        projected_RIGHT = self.project(
            RIGHT) / get_norm(self.project(RIGHT))
        lower_ray = rotate_vector(
            projected_RIGHT, lower_angle, axis=self.projection_direction())
        upper_ray = rotate_vector(
            projected_RIGHT, upper_angle, axis=self.projection_direction())

        return lower_ray, upper_ray

    def opening_angle(self):
        l, u = self.viewing_angles(self.screen)
        return u - l

    def start_angle(self):
        l, u = self.viewing_angles(self.screen)
        return l

    def stop_angle(self):
        l, u = self.viewing_angles(self.screen)
        return u

    def move_source_to(self, point):
        self.source_point.set_location(np.array(point))
        # self.source_point.move_to(np.array(point))
        # self.move_to(point)
        self.update_sectors()
        return self

    def update_sectors(self):
        if self.screen is None:
            return
        for submob in self.submobjects:
            if type(submob) == AnnularSector:
                lower_angle, upper_angle = self.viewing_angles(self.screen)
                # dr = submob.outer_radius - submob.inner_radius
                dr = self.radius / self.num_levels
                new_submob = self.new_sector(
                    submob.inner_radius, dr, lower_angle, upper_angle
                )
                # submob.points = new_submob.points
                # submob.set_fill(opacity = 10 * self.opacity_function(submob.outer_radius))
                Transform(submob, new_submob).update(1)

    def dimming(self, new_alpha):
        old_alpha = self.max_opacity
        self.max_opacity = new_alpha
        for submob in self.submobjects:
            # Note: Maybe it&#39;d be best to have a Shadow class so that the
            # type can be checked directly?
            if type(submob) != AnnularSector:
                # it&#39;s the shadow, don&#39;t dim it
                continue
            old_submob_alpha = submob.fill_opacity
            new_submob_alpha = old_submob_alpha * new_alpha / old_alpha
            submob.set_fill(opacity=new_submob_alpha)

    def change_opacity_function(self, new_f):
        self.opacity_function = new_f
        dr = self.radius / self.num_levels

        sectors = []
        for submob in self.submobjects:
            if type(submob) == AnnularSector:
                sectors.append(submob)

        for (r, submob) in zip(np.arange(0, self.radius, dr), sectors):
            if type(submob) != AnnularSector:
                # it&#39;s the shadow, don&#39;t dim it
                continue
            alpha = self.opacity_function(r)
            submob.set_fill(opacity=alpha)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></li>
<li><a title="manimlib.mobject.mobject.Mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject">Mobject</a></li>
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.Spotlight.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.Spotlight.change_opacity_function"><code class="name flex">
<span>def <span class="ident">change_opacity_function</span></span>(<span>self, new_f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_opacity_function(self, new_f):
    self.opacity_function = new_f
    dr = self.radius / self.num_levels

    sectors = []
    for submob in self.submobjects:
        if type(submob) == AnnularSector:
            sectors.append(submob)

    for (r, submob) in zip(np.arange(0, self.radius, dr), sectors):
        if type(submob) != AnnularSector:
            # it&#39;s the shadow, don&#39;t dim it
            continue
        alpha = self.opacity_function(r)
        submob.set_fill(opacity=alpha)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.dimming"><code class="name flex">
<span>def <span class="ident">dimming</span></span>(<span>self, new_alpha)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dimming(self, new_alpha):
    old_alpha = self.max_opacity
    self.max_opacity = new_alpha
    for submob in self.submobjects:
        # Note: Maybe it&#39;d be best to have a Shadow class so that the
        # type can be checked directly?
        if type(submob) != AnnularSector:
            # it&#39;s the shadow, don&#39;t dim it
            continue
        old_submob_alpha = submob.fill_opacity
        new_submob_alpha = old_submob_alpha * new_alpha / old_alpha
        submob.set_fill(opacity=new_submob_alpha)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.generate_points"><code class="name flex">
<span>def <span class="ident">generate_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_points(self):
    self.submobjects = []

    self.add(self.source_point)

    if self.screen is not None:
        # look for the screen and create annular sectors
        lower_angle, upper_angle = self.viewing_angles(self.screen)
        self.radius = float(self.radius)
        dr = self.radius / self.num_levels
        lower_ray, upper_ray = self.viewing_rays(self.screen)

        for r in np.arange(0, self.radius, dr):
            new_sector = self.new_sector(r, dr, lower_angle, upper_angle)
            self.add(new_sector)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.get_source_point"><code class="name flex">
<span>def <span class="ident">get_source_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_source_point(self):
    return self.source_point.get_location()</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.move_source_to"><code class="name flex">
<span>def <span class="ident">move_source_to</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_source_to(self, point):
    self.source_point.set_location(np.array(point))
    # self.source_point.move_to(np.array(point))
    # self.move_to(point)
    self.update_sectors()
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.new_sector"><code class="name flex">
<span>def <span class="ident">new_sector</span></span>(<span>self, r, dr, lower_angle, upper_angle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_sector(self, r, dr, lower_angle, upper_angle):
    alpha = self.max_opacity * self.opacity_function(r)
    annular_sector = AnnularSector(
        inner_radius=r,
        outer_radius=r + dr,
        color=self.color,
        fill_opacity=alpha,
        start_angle=lower_angle,
        angle=upper_angle - lower_angle
    )
    # rotate (not project) it into the viewing plane
    rotation_matrix = z_to_vector(self.projection_direction())
    annular_sector.apply_matrix(rotation_matrix)
    # now rotate it inside that plane
    rotated_RIGHT = np.dot(RIGHT, rotation_matrix.T)
    projected_RIGHT = self.project(RIGHT)
    omega = angle_between_vectors(rotated_RIGHT, projected_RIGHT)
    annular_sector.rotate(omega, axis=self.projection_direction())
    annular_sector.move_arc_center_to(self.get_source_point())

    return annular_sector</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.opening_angle"><code class="name flex">
<span>def <span class="ident">opening_angle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opening_angle(self):
    l, u = self.viewing_angles(self.screen)
    return u - l</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, point):
    v = self.projection_direction()
    w = project_along_vector(point, v)
    return w</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.projection_direction"><code class="name flex">
<span>def <span class="ident">projection_direction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projection_direction(self):
    # Note: This seems reasonable, though for it to work you&#39;d
    # need to be sure that any 3d scene including a spotlight
    # somewhere assigns that spotlights &#34;camera&#34; attribute
    # to be the camera associated with that scene.
    if self.camera_mob is None:
        return OUT
    else:
        [phi, theta, r] = self.camera_mob.get_center()
        v = np.array([np.sin(phi) * np.cos(theta),
                      np.sin(phi) * np.sin(theta), np.cos(phi)])
        return v  # /get_norm(v)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.start_angle"><code class="name flex">
<span>def <span class="ident">start_angle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_angle(self):
    l, u = self.viewing_angles(self.screen)
    return l</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.stop_angle"><code class="name flex">
<span>def <span class="ident">stop_angle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_angle(self):
    l, u = self.viewing_angles(self.screen)
    return u</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.update_sectors"><code class="name flex">
<span>def <span class="ident">update_sectors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_sectors(self):
    if self.screen is None:
        return
    for submob in self.submobjects:
        if type(submob) == AnnularSector:
            lower_angle, upper_angle = self.viewing_angles(self.screen)
            # dr = submob.outer_radius - submob.inner_radius
            dr = self.radius / self.num_levels
            new_submob = self.new_sector(
                submob.inner_radius, dr, lower_angle, upper_angle
            )
            # submob.points = new_submob.points
            # submob.set_fill(opacity = 10 * self.opacity_function(submob.outer_radius))
            Transform(submob, new_submob).update(1)</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.viewing_angle_of_point"><code class="name flex">
<span>def <span class="ident">viewing_angle_of_point</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewing_angle_of_point(self, point):
    # as measured from the positive x-axis
    v1 = self.project(RIGHT)
    v2 = self.project(np.array(point) - self.get_source_point())
    absolute_angle = angle_between_vectors(v1, v2)
    # determine the angle&#39;s sign depending on their plane&#39;s
    # choice of orientation. That choice is set by the camera
    # position, i. e. projection direction

    if np.dot(self.projection_direction(), np.cross(v1, v2)) &gt; 0:
        return absolute_angle
    else:
        return -absolute_angle</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.viewing_angles"><code class="name flex">
<span>def <span class="ident">viewing_angles</span></span>(<span>self, screen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewing_angles(self, screen):

    screen_points = screen.get_anchors()
    projected_screen_points = list(map(self.project, screen_points))

    viewing_angles = np.array(list(map(self.viewing_angle_of_point,
                                       projected_screen_points)))

    lower_angle = upper_angle = 0
    if len(viewing_angles) != 0:
        lower_angle = np.min(viewing_angles)
        upper_angle = np.max(viewing_angles)

    if upper_angle - lower_angle &gt; TAU / 2:
        lower_angle, upper_angle = upper_angle, lower_angle + TAU
    return lower_angle, upper_angle</code></pre>
</details>
</dd>
<dt id="manimlib.once_useful_constructs.light.Spotlight.viewing_rays"><code class="name flex">
<span>def <span class="ident">viewing_rays</span></span>(<span>self, screen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewing_rays(self, screen):

    lower_angle, upper_angle = self.viewing_angles(screen)
    projected_RIGHT = self.project(
        RIGHT) / get_norm(self.project(RIGHT))
    lower_ray = rotate_vector(
        projected_RIGHT, lower_angle, axis=self.projection_direction())
    upper_ray = rotate_vector(
        projected_RIGHT, upper_angle, axis=self.projection_direction())

    return lower_ray, upper_ray</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.mobject.types.vectorized_mobject.VMobject" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject">VMobject</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add" href="../container/container.html#manimlib.container.container.Container.add">add</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to">add_cubic_bezier_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to">add_smooth_curve_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_on_border" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_on_border">align_on_border</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.align_to" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.align_to">align_to</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become">become</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.become_partial" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.become_partial">become_partial</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d">consider_points_equals_2d</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.digest_mobject_attrs" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.digest_mobject_attrs">digest_mobject_attrs</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points">gen_cubic_bezier_tuples_from_points</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array">generate_rgbas_array</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles">get_anchors_and_handles</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_coord" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_coord">get_coord</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_critical_point" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_critical_point">get_critical_point</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_color">get_fill_color</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.get_fill_opacity">get_fill_opacity</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.get_point_mobject" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.get_point_mobject">get_point_mobject</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.interpolate" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.interpolate">interpolate</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.null_point_align" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.null_point_align">null_point_align</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.remove" href="../container/container.html#manimlib.container.container.Container.remove">remove</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.repeat" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.repeat">repeat</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.scale">scale</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances" href="../mobject/types/vectorized_mobject.html#manimlib.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances">scale_handle_to_anchor_distances</a></code></li>
<li><code><a title="manimlib.mobject.types.vectorized_mobject.VMobject.set_color" href="../mobject/mobject.html#manimlib.mobject.mobject.Mobject.set_color">set_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.once_useful_constructs.light.SwitchOff"><code class="flex name class">
<span>class <span class="ident">SwitchOff</span></span>
<span>(</span><span>light, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwitchOff(LaggedStartMap):
    CONFIG = {
        &#34;lag_ratio&#34;: 0.2,
        &#34;run_time&#34;: SWITCH_ON_RUN_TIME
    }

    def __init__(self, light, **kwargs):
        if (not isinstance(light, AmbientLight) and not isinstance(light, Spotlight)):
            raise Exception(
                &#34;Only AmbientLights and Spotlights can be switched off&#34;)
        light.submobjects = light.submobjects[::-1]
        LaggedStartMap.__init__(self, FadeOut, light, **kwargs)
        light.submobjects = light.submobjects[::-1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.animation.composition.LaggedStartMap" href="../animation/composition.html#manimlib.animation.composition.LaggedStartMap">LaggedStartMap</a></li>
<li><a title="manimlib.animation.composition.LaggedStart" href="../animation/composition.html#manimlib.animation.composition.LaggedStart">LaggedStart</a></li>
<li><a title="manimlib.animation.composition.AnimationGroup" href="../animation/composition.html#manimlib.animation.composition.AnimationGroup">AnimationGroup</a></li>
<li><a title="manimlib.animation.animation.Animation" href="../animation/animation.html#manimlib.animation.animation.Animation">Animation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.SwitchOff.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.animation.composition.LaggedStartMap" href="../animation/composition.html#manimlib.animation.composition.LaggedStartMap">LaggedStartMap</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.animation.composition.LaggedStartMap.build_animations_with_timings" href="../animation/composition.html#manimlib.animation.composition.AnimationGroup.build_animations_with_timings">build_animations_with_timings</a></code></li>
<li><code><a title="manimlib.animation.composition.LaggedStartMap.get_all_mobjects" href="../animation/animation.html#manimlib.animation.animation.Animation.get_all_mobjects">get_all_mobjects</a></code></li>
<li><code><a title="manimlib.animation.composition.LaggedStartMap.update" href="../animation/animation.html#manimlib.animation.animation.Animation.update">update</a></code></li>
<li><code><a title="manimlib.animation.composition.LaggedStartMap.update_mobjects" href="../animation/animation.html#manimlib.animation.animation.Animation.update_mobjects">update_mobjects</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.once_useful_constructs.light.SwitchOn"><code class="flex name class">
<span>class <span class="ident">SwitchOn</span></span>
<span>(</span><span>light, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwitchOn(LaggedStartMap):
    CONFIG = {
        &#34;lag_ratio&#34;: 0.2,
        &#34;run_time&#34;: SWITCH_ON_RUN_TIME
    }

    def __init__(self, light, **kwargs):
        if (not isinstance(light, AmbientLight) and not isinstance(light, Spotlight)):
            raise Exception(
                &#34;Only AmbientLights and Spotlights can be switched on&#34;)
        LaggedStartMap.__init__(
            self, FadeIn, light, **kwargs
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.animation.composition.LaggedStartMap" href="../animation/composition.html#manimlib.animation.composition.LaggedStartMap">LaggedStartMap</a></li>
<li><a title="manimlib.animation.composition.LaggedStart" href="../animation/composition.html#manimlib.animation.composition.LaggedStart">LaggedStart</a></li>
<li><a title="manimlib.animation.composition.AnimationGroup" href="../animation/composition.html#manimlib.animation.composition.AnimationGroup">AnimationGroup</a></li>
<li><a title="manimlib.animation.animation.Animation" href="../animation/animation.html#manimlib.animation.animation.Animation">Animation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.once_useful_constructs.light.SwitchOn.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.animation.composition.LaggedStartMap" href="../animation/composition.html#manimlib.animation.composition.LaggedStartMap">LaggedStartMap</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.animation.composition.LaggedStartMap.build_animations_with_timings" href="../animation/composition.html#manimlib.animation.composition.AnimationGroup.build_animations_with_timings">build_animations_with_timings</a></code></li>
<li><code><a title="manimlib.animation.composition.LaggedStartMap.get_all_mobjects" href="../animation/animation.html#manimlib.animation.animation.Animation.get_all_mobjects">get_all_mobjects</a></code></li>
<li><code><a title="manimlib.animation.composition.LaggedStartMap.update" href="../animation/animation.html#manimlib.animation.animation.Animation.update">update</a></code></li>
<li><code><a title="manimlib.animation.composition.LaggedStartMap.update_mobjects" href="../animation/animation.html#manimlib.animation.animation.Animation.update_mobjects">update_mobjects</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.once_useful_constructs" href="index.html">manimlib.once_useful_constructs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="manimlib.once_useful_constructs.light.ScreenTracker" href="#manimlib.once_useful_constructs.light.ScreenTracker">ScreenTracker</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.inverse_power_law" href="#manimlib.once_useful_constructs.light.inverse_power_law">inverse_power_law</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.inverse_quadratic" href="#manimlib.once_useful_constructs.light.inverse_quadratic">inverse_quadratic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.once_useful_constructs.light.AmbientLight" href="#manimlib.once_useful_constructs.light.AmbientLight">AmbientLight</a></code></h4>
<ul class="">
<li><code><a title="manimlib.once_useful_constructs.light.AmbientLight.CONFIG" href="#manimlib.once_useful_constructs.light.AmbientLight.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.AmbientLight.dimming" href="#manimlib.once_useful_constructs.light.AmbientLight.dimming">dimming</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.AmbientLight.generate_points" href="#manimlib.once_useful_constructs.light.AmbientLight.generate_points">generate_points</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.AmbientLight.get_source_point" href="#manimlib.once_useful_constructs.light.AmbientLight.get_source_point">get_source_point</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.AmbientLight.move_source_to" href="#manimlib.once_useful_constructs.light.AmbientLight.move_source_to">move_source_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.once_useful_constructs.light.LightSource" href="#manimlib.once_useful_constructs.light.LightSource">LightSource</a></code></h4>
<ul class="">
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.CONFIG" href="#manimlib.once_useful_constructs.light.LightSource.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.change_spotlight_opacity_function" href="#manimlib.once_useful_constructs.light.LightSource.change_spotlight_opacity_function">change_spotlight_opacity_function</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.dim_ambient" href="#manimlib.once_useful_constructs.light.LightSource.dim_ambient">dim_ambient</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.dim_spotlight" href="#manimlib.once_useful_constructs.light.LightSource.dim_spotlight">dim_spotlight</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.generate_points" href="#manimlib.once_useful_constructs.light.LightSource.generate_points">generate_points</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.get_source_point" href="#manimlib.once_useful_constructs.light.LightSource.get_source_point">get_source_point</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.has_screen" href="#manimlib.once_useful_constructs.light.LightSource.has_screen">has_screen</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.move_source_to" href="#manimlib.once_useful_constructs.light.LightSource.move_source_to">move_source_to</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.rotation_matrix" href="#manimlib.once_useful_constructs.light.LightSource.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.set_camera_mob" href="#manimlib.once_useful_constructs.light.LightSource.set_camera_mob">set_camera_mob</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.set_max_opacity_ambient" href="#manimlib.once_useful_constructs.light.LightSource.set_max_opacity_ambient">set_max_opacity_ambient</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.set_max_opacity_spotlight" href="#manimlib.once_useful_constructs.light.LightSource.set_max_opacity_spotlight">set_max_opacity_spotlight</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.set_radius" href="#manimlib.once_useful_constructs.light.LightSource.set_radius">set_radius</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.set_screen" href="#manimlib.once_useful_constructs.light.LightSource.set_screen">set_screen</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.update" href="#manimlib.once_useful_constructs.light.LightSource.update">update</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.update_ambient" href="#manimlib.once_useful_constructs.light.LightSource.update_ambient">update_ambient</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.update_lighthouse" href="#manimlib.once_useful_constructs.light.LightSource.update_lighthouse">update_lighthouse</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.LightSource.update_shadow" href="#manimlib.once_useful_constructs.light.LightSource.update_shadow">update_shadow</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.once_useful_constructs.light.Lighthouse" href="#manimlib.once_useful_constructs.light.Lighthouse">Lighthouse</a></code></h4>
<ul class="">
<li><code><a title="manimlib.once_useful_constructs.light.Lighthouse.CONFIG" href="#manimlib.once_useful_constructs.light.Lighthouse.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Lighthouse.move_to" href="#manimlib.once_useful_constructs.light.Lighthouse.move_to">move_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.once_useful_constructs.light.Spotlight" href="#manimlib.once_useful_constructs.light.Spotlight">Spotlight</a></code></h4>
<ul class="">
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.CONFIG" href="#manimlib.once_useful_constructs.light.Spotlight.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.change_opacity_function" href="#manimlib.once_useful_constructs.light.Spotlight.change_opacity_function">change_opacity_function</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.dimming" href="#manimlib.once_useful_constructs.light.Spotlight.dimming">dimming</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.generate_points" href="#manimlib.once_useful_constructs.light.Spotlight.generate_points">generate_points</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.get_source_point" href="#manimlib.once_useful_constructs.light.Spotlight.get_source_point">get_source_point</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.move_source_to" href="#manimlib.once_useful_constructs.light.Spotlight.move_source_to">move_source_to</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.new_sector" href="#manimlib.once_useful_constructs.light.Spotlight.new_sector">new_sector</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.opening_angle" href="#manimlib.once_useful_constructs.light.Spotlight.opening_angle">opening_angle</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.project" href="#manimlib.once_useful_constructs.light.Spotlight.project">project</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.projection_direction" href="#manimlib.once_useful_constructs.light.Spotlight.projection_direction">projection_direction</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.start_angle" href="#manimlib.once_useful_constructs.light.Spotlight.start_angle">start_angle</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.stop_angle" href="#manimlib.once_useful_constructs.light.Spotlight.stop_angle">stop_angle</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.update_sectors" href="#manimlib.once_useful_constructs.light.Spotlight.update_sectors">update_sectors</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.viewing_angle_of_point" href="#manimlib.once_useful_constructs.light.Spotlight.viewing_angle_of_point">viewing_angle_of_point</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.viewing_angles" href="#manimlib.once_useful_constructs.light.Spotlight.viewing_angles">viewing_angles</a></code></li>
<li><code><a title="manimlib.once_useful_constructs.light.Spotlight.viewing_rays" href="#manimlib.once_useful_constructs.light.Spotlight.viewing_rays">viewing_rays</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.once_useful_constructs.light.SwitchOff" href="#manimlib.once_useful_constructs.light.SwitchOff">SwitchOff</a></code></h4>
<ul class="">
<li><code><a title="manimlib.once_useful_constructs.light.SwitchOff.CONFIG" href="#manimlib.once_useful_constructs.light.SwitchOff.CONFIG">CONFIG</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.once_useful_constructs.light.SwitchOn" href="#manimlib.once_useful_constructs.light.SwitchOn">SwitchOn</a></code></h4>
<ul class="">
<li><code><a title="manimlib.once_useful_constructs.light.SwitchOn.CONFIG" href="#manimlib.once_useful_constructs.light.SwitchOn.CONFIG">CONFIG</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>