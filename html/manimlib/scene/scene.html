<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.scene.scene API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.scene.scene</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import inspect
import random
import warnings
import platform

from tqdm import tqdm as ProgressDisplay
import numpy as np

from manimlib.animation.animation import Animation
from manimlib.animation.transform import MoveToTarget, ApplyMethod
from manimlib.camera.camera import Camera
from manimlib.constants import *
from manimlib.container.container import Container
from manimlib.mobject.mobject import Mobject
from manimlib.scene.scene_file_writer import SceneFileWriter
from manimlib.utils.iterables import list_update


class Scene(Container):
    &#34;&#34;&#34;
    A Scene can be thought of as the Canvas of your animation.
    All of your own named Scenes will be subclasses of this Scene, or
    other named scenes.

    Use a construct() function to tell Manim what should go on in the Scene.
    
    E.G:
        
        class MyScene(Scene):
            def construct(self):
                self.play(
                    Write(Text(&#34;Hello World!&#34;))
                )

    Some important variables to note are:
        camera: The camera object to be used for the scene.
        file_writer : The object that writes the animations in the scene to a video file.
        mobjects : The list of mobjects present in the scene.
        foreground_mobjects : List of mobjects explicitly in the foreground.
        num_plays : Number of play() functions in the scene.
        time: time elapsed since initialisation of scene.
        random_seed: The seed with which all random operations are done.
    &#34;&#34;&#34;
    CONFIG = {
        &#34;camera_class&#34;: Camera,
        &#34;camera_config&#34;: {},
        &#34;file_writer_config&#34;: {},
        &#34;skip_animations&#34;: False,
        &#34;always_update_mobjects&#34;: False,
        &#34;random_seed&#34;: 0,
        &#34;start_at_animation_number&#34;: None,
        &#34;end_at_animation_number&#34;: None,
        &#34;leave_progress_bars&#34;: False,
    }

    def __init__(self, **kwargs):
        Container.__init__(self, **kwargs)
        self.camera = self.camera_class(**self.camera_config)
        self.file_writer = SceneFileWriter(
            self, **self.file_writer_config,
        )

        self.mobjects = []
        # TODO, remove need for foreground mobjects
        self.foreground_mobjects = []
        self.num_plays = 0
        self.time = 0
        self.original_skipping_status = self.skip_animations
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.setup()
        try:
            self.construct()
        except EndSceneEarlyException:
            pass
        self.tear_down()
        self.file_writer.finish()
        self.print_end_message()

    def setup(self):
        &#34;&#34;&#34;
        This is meant to be implemented by any scenes which
        are comonly subclassed, and have some common setup
        involved before the construct method is called.
        &#34;&#34;&#34;
        pass

    def tear_down(self):
        &#34;&#34;&#34;
        This is meant to be implemented by any scenes which
        are comonly subclassed, and have some common method
        to be invoked before the scene ends.
        &#34;&#34;&#34;
        pass

    def construct(self):
        &#34;&#34;&#34;
        The primary method for constructing (i.e adding content to)
        the Scene.
        &#34;&#34;&#34;
        pass  # To be implemented in subclasses

    def __str__(self):
        return self.__class__.__name__

    def print_end_message(self):
        &#34;&#34;&#34;
        Used internally to print the number of
        animations played after the scene ends.
        &#34;&#34;&#34;
        print(&#34;Played {} animations&#34;.format(self.num_plays))

    def set_variables_as_attrs(self, *objects, **newly_named_objects):
        &#34;&#34;&#34;
        This method is slightly hacky, making it a little easier
        for certain methods (typically subroutines of construct)
        to share local variables.
        &#34;&#34;&#34;
        caller_locals = inspect.currentframe().f_back.f_locals
        for key, value in list(caller_locals.items()):
            for o in objects:
                if value is o:
                    setattr(self, key, value)
        for key, value in list(newly_named_objects.items()):
            setattr(self, key, value)
        return self

    def get_attrs(self, *keys):
        &#34;&#34;&#34;
        Gets attributes of a scene given the attribute&#39;s identifier/name.
        
        Parameters
        ----------
        *args: (str)
            Name(s) of the argument(s) to return the attribute of.
        
        Returns
        -------
        list
            List of attributes of the passed identifiers.
        &#34;&#34;&#34;
        return [getattr(self, key) for key in keys]

    # Only these methods should touch the camera
    def set_camera(self, camera):
        &#34;&#34;&#34;
        Sets the scene&#39;s camera to be the passed Camera Object.
        Parameters
        ----------
        camera: Union[Camera, MappingCamera,MovingCamera,MultiCamera,ThreeDCamera]
            Camera object to use.
        &#34;&#34;&#34;
        self.camera = camera

    def get_frame(self):
        &#34;&#34;&#34;
        Gets current frame as NumPy array.
        
        Returns
        -------
        np.array
            NumPy array of pixel values of each pixel in screen
        &#34;&#34;&#34;
        return np.array(self.camera.get_pixel_array())

    def get_image(self):
        &#34;&#34;&#34;
        Gets current frame as PIL Image
        
        Returns
        -------
        PIL.Image
            PIL Image object of current frame.
        &#34;&#34;&#34;
        return self.camera.get_image()

    def set_camera_pixel_array(self, pixel_array):
        &#34;&#34;&#34;
        Sets the camera to display a Pixel Array
        
        Parameters
        ----------
        pixel_array: Union[np.ndarray,list,tuple]
            Pixel array to set the camera to display
        &#34;&#34;&#34;
        self.camera.set_pixel_array(pixel_array)

    def set_camera_background(self, background):
        &#34;&#34;&#34;
        Sets the camera to display a Pixel Array
        
        Parameters
        ----------
        background: Union[np.ndarray,list,tuple]
            
        &#34;&#34;&#34;
        self.camera.set_background(background)

    def reset_camera(self):
        &#34;&#34;&#34;
        Resets the Camera to its original configuration.
        &#34;&#34;&#34;
        self.camera.reset()

    def capture_mobjects_in_camera(self, mobjects, **kwargs): #TODO Add more detail to docstring.
        &#34;&#34;&#34;
        This method is used internally.
        &#34;&#34;&#34;
        self.camera.capture_mobjects(mobjects, **kwargs)

    def update_frame( #TODO Description in Docstring
            self,
            mobjects=None,
            background=None,
            include_submobjects=True,
            ignore_skipping=True,
            **kwargs):
        &#34;&#34;&#34;
        Parameters:
        -----------
        mobjects: list
            list of mobjects
        
        background: np.ndarray
            Pixel Array for Background
        
        include_submobjects: bool (True)
        
        ignore_skipping : bool (True)

        **kwargs

        &#34;&#34;&#34;
        if self.skip_animations and not ignore_skipping:
            return
        if mobjects is None:
            mobjects = list_update(
                self.mobjects,
                self.foreground_mobjects,
            )
        if background is not None:
            self.set_camera_pixel_array(background)
        else:
            self.reset_camera()

        kwargs[&#34;include_submobjects&#34;] = include_submobjects
        self.capture_mobjects_in_camera(mobjects, **kwargs)

    def freeze_background(self):
        self.update_frame()
        self.set_camera(Camera(self.get_frame()))
        self.clear()
    ###

    def update_mobjects(self, dt):
        &#34;&#34;&#34;
        Begins updating all mobjects in the Scene.
        
        Parameters
        ----------
        dt: Union[int,float]
            Change in time between updates. Defaults (mostly) to 1/frames_per_second
        &#34;&#34;&#34;
        for mobject in self.mobjects:
            mobject.update(dt)

    def should_update_mobjects(self):
        &#34;&#34;&#34;
        Returns True if any mobject in Scene is being updated
        or if the scene has always_update_mobjects set to true.
        
        Returns
        -------
            bool
        &#34;&#34;&#34;
        return self.always_update_mobjects or any([
            mob.has_time_based_updater()
            for mob in self.get_mobject_family_members()
        ])

    ###

    def get_time(self):
        &#34;&#34;&#34;
        Returns time in seconds elapsed after initialisation of scene
        
        Returns
        -------
        self.time : Union[int,float]
            Returns time in seconds elapsed after initialisation of scene
        &#34;&#34;&#34;
        return self.time

    def increment_time(self, d_time):
        &#34;&#34;&#34;
        Increments the time elapsed after intialisation of scene by
        passed &#34;d_time&#34;.
        
        Parameters
        ----------
        d_time : Union[int,float]
            Time in seconds to increment by.
        &#34;&#34;&#34;
        self.time += d_time

    ###

    def get_top_level_mobjects(self):
        &#34;&#34;&#34;
        Returns all mobjects which are not submobjects.

        Returns
        -------
        list
            List of top level mobjects.
        &#34;&#34;&#34;
        # Return only those which are not in the family
        # of another mobject from the scene
        mobjects = self.get_mobjects()
        families = [m.get_family() for m in mobjects]

        def is_top_level(mobject):
            num_families = sum([
                (mobject in family)
                for family in families
            ])
            return num_families == 1
        return list(filter(is_top_level, mobjects))

    def get_mobject_family_members(self):
        &#34;&#34;&#34;
        Returns list of family-members of all mobjects in scene.
        If a Circle() and a VGroup(Rectangle(),Triangle()) were added,
        it returns not only the Circle(), Rectangle() and Triangle(), but
        also the VGroup() object.

        Returns
        -------
        list
            List of mobject family members.
        &#34;&#34;&#34;
        return self.camera.extract_mobject_family_members(self.mobjects)

    def add(self, *mobjects):
        &#34;&#34;&#34;
        Mobjects will be displayed, from background to
        foreground in the order with which they are added.

        Parameters
        ---------
        *mobjects
            Mobjects to add.
        
        Returns
        -------
        Scene
            The same scene after adding the Mobjects in.

        &#34;&#34;&#34;
        mobjects = [*mobjects, *self.foreground_mobjects]
        self.restructure_mobjects(to_remove=mobjects)
        self.mobjects += mobjects
        return self

    def add_mobjects_among(self, values):
        &#34;&#34;&#34;
        This is meant mostly for quick prototyping,
        e.g. to add all mobjects defined up to a point,
        call self.add_mobjects_among(locals().values())
        &#34;&#34;&#34;
        self.add(*filter(
            lambda m: isinstance(m, Mobject),
            values
        ))
        return self

    def remove(self, *mobjects):
        &#34;&#34;&#34;
        Removes mobjects in the passed list of mobjects
        from the scene and the foreground, by removing them
        from &#34;mobjects&#34; and &#34;foreground_mobjects&#34;
        &#34;&#34;&#34;
        for list_name in &#34;mobjects&#34;, &#34;foreground_mobjects&#34;:
            self.restructure_mobjects(mobjects, list_name, False)
        return self

    def restructure_mobjects(self, to_remove,
                             mobject_list_name=&#34;mobjects&#34;,
                             extract_families=True):
        &#34;&#34;&#34;
        tl:wr
            If your scene has a Group(), and you removed a mobject from the Group,
            this dissolves the group and puts the rest of the mobjects directly 
            in self.mobjects or self.foreground_mobjects.
        
        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
        will be edited to contain other submobjects, but not m1, e.g. it will now
        insert m2 and m3 to where the group once was.

        Parameters
        ----------
        to_remove : Mobject
            The Mobject to remove.
        
        mobject_list_name : str
            The list of mobjects (&#34;mobjects&#34;, &#34;foreground_mobjects&#34; etc) to remove from.
        
        extract_families : bool
            Whether the mobject&#39;s families should be recursively extracted.
        
        Returns
        -------
        Scene
            The Scene mobject with restructured Mobjects.
        &#34;&#34;&#34;
        if extract_families:
            to_remove = self.camera.extract_mobject_family_members(to_remove)
        _list = getattr(self, mobject_list_name)
        new_list = self.get_restructured_mobject_list(_list, to_remove)
        setattr(self, mobject_list_name, new_list)
        return self

    def get_restructured_mobject_list(self, mobjects, to_remove):
        &#34;&#34;&#34;
        Given a list of mobjects and a list of mobjects to be removed, this
        filters out the removable mobjects from the list of mobjects.
        
        Parameters
        ----------

        mobjects : list
            The Mobjects to check.
        
        to_remove : list
            The list of mobjects to remove.
        
        Returns
        -------
        list
            The list of mobjects with the mobjects to remove removed.
        &#34;&#34;&#34;
        
        new_mobjects = []

        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
            for mob in list_to_examine:
                if mob in set_to_remove:
                    continue
                intersect = set_to_remove.intersection(mob.get_family())
                if intersect:
                    add_safe_mobjects_from_list(mob.submobjects, intersect)
                else:
                    new_mobjects.append(mob)
        add_safe_mobjects_from_list(mobjects, set(to_remove))
        return new_mobjects

    # TODO, remove this, and calls to this
    def add_foreground_mobjects(self, *mobjects):
        &#34;&#34;&#34;
        Adds mobjects to the foreground, and internally to the list 
        foreground_mobjects, and mobjects.

        Parameters
        ----------
        *mobjects : Mobject
            The Mobjects to add to the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobjects added.
        &#34;&#34;&#34;
        self.foreground_mobjects = list_update(
            self.foreground_mobjects,
            mobjects
        )
        self.add(*mobjects)
        return self

    def add_foreground_mobject(self, mobject):
        &#34;&#34;&#34;
        Adds a single mobject to the foreground, and internally to the list 
        foreground_mobjects, and mobjects.

        Parameters
        ----------
        mobject : Mobject
            The Mobject to add to the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobject added.
        &#34;&#34;&#34;
        return self.add_foreground_mobjects(mobject)

    def remove_foreground_mobjects(self, *to_remove):
        &#34;&#34;&#34;
        Removes mobjects from the foreground, and internally from the list 
        foreground_mobjects.

        Parameters
        ----------
        *to_remove : Mobject
            The mobject(s) to remove from the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobjects removed.
        &#34;&#34;&#34;
        self.restructure_mobjects(to_remove, &#34;foreground_mobjects&#34;)
        return self

    def remove_foreground_mobject(self, mobject):
        &#34;&#34;&#34;
        Removes a single mobject from the foreground, and internally from the list 
        foreground_mobjects.

        Parameters
        ----------
        mobject : Mobject
            The mobject to remove from the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobject removed.
        &#34;&#34;&#34;
        return self.remove_foreground_mobjects(mobject)

    def bring_to_front(self, *mobjects):
        &#34;&#34;&#34;
        Adds the passed mobjects to the scene again, 
        pushing them to he front of the scene.

        Parameters
        ----------
        *mobjects : Mobject
            The mobject(s) to bring to the front of the scene.
        
        Returns
        ------
        Scene
            The Scene, with the mobjects brought to the front
            of the scene.
        &#34;&#34;&#34;
        self.add(*mobjects)
        return self

    def bring_to_back(self, *mobjects):
        &#34;&#34;&#34;
        Removes the mobject from the scene and
        adds them to the back of the scene.

        Parameters
        ----------
        *mobjects : Mobject
            The mobject(s) to push to the back of the scene.
        
        Returns
        ------
        Scene
            The Scene, with the mobjects pushed to the back
            of the scene.
        &#34;&#34;&#34;
        self.remove(*mobjects)
        self.mobjects = list(mobjects) + self.mobjects
        return self

    def clear(self):
        &#34;&#34;&#34;
        Removes all mobjects present in self.mobjects
        and self.foreground_mobjects from the scene.

        Returns
        ------
        Scene
            The Scene, with all of its mobjects in 
            self.mobjects and self.foreground_mobjects
            removed.
        &#34;&#34;&#34;
        self.mobjects = []
        self.foreground_mobjects = []
        return self

    def get_mobjects(self):
        &#34;&#34;&#34;
        Returns all the mobjects in self.mobjects

        Returns
        ------
        list
            The list of self.mobjects .
        &#34;&#34;&#34;
        return list(self.mobjects)

    def get_mobject_copies(self):
        &#34;&#34;&#34;
        Returns a copy of all mobjects present in
        self.mobjects .

        Returns
        ------
        list
            A list of the copies of all the mobjects
            in self.mobjects
        &#34;&#34;&#34;
        return [m.copy() for m in self.mobjects]

    def get_moving_mobjects(self, *animations):
        &#34;&#34;&#34;
        Gets all moving mobjects in the passed animation(s).
        
        Parameters
        ----------
        *animations
            The animations to check for moving mobjects.

        Returns
        ------
        list
            The list of mobjects that could be moving in
            the Animation(s)
        &#34;&#34;&#34;
        # Go through mobjects from start to end, and
        # as soon as there&#39;s one that needs updating of
        # some kind per frame, return the list from that
        # point forward.
        animation_mobjects = [anim.mobject for anim in animations]
        mobjects = self.get_mobject_family_members()
        for i, mob in enumerate(mobjects):
            update_possibilities = [
                mob in animation_mobjects,
                len(mob.get_family_updaters()) &gt; 0,
                mob in self.foreground_mobjects
            ]
            if any(update_possibilities):
                return mobjects[i:]
        return []

    def get_time_progression(self, run_time, n_iterations=None, override_skip_animations=False):
        &#34;&#34;&#34;
        You will hardly use this when making your own animations.
        This method is for Manim&#39;s internal use.

        Returns a CommandLine ProgressBar whose fill_time
        is dependent on the run_time of an animation, 
        the iterations to perform in that animation
        and a bool saying whether or not to consider
        the skipped animations.

        Parameters
        ----------
        run_time: Union[int,float]
            The run_time of the animation.
        
        n_iterations: None, int
            The number of iterations in the animation.
        
        override_skip_animations: bool (True)
            Whether or not to show skipped animations in the progress bar.

        Returns
        ------
        ProgressDisplay
            The CommandLine Progress Bar.
        &#34;&#34;&#34;
        if self.skip_animations and not override_skip_animations:
            times = [run_time]
        else:
            step = 1 / self.camera.frame_rate
            times = np.arange(0, run_time, step)
        time_progression = ProgressDisplay(
            times, total=n_iterations,
            leave=self.leave_progress_bars,
            ascii=False if platform.system() != &#39;Windows&#39; else True
        )
        return time_progression

    def get_run_time(self, animations):
        &#34;&#34;&#34;
        Gets the total run time for a list of animations.

        Parameters
        ----------
        animations: list
            A list of the animations whose total 
            run_time is to be calculated.
        
        Returns
        ------
        float
            The total run_time of all of the animations in the list.
        &#34;&#34;&#34;

        return np.max([animation.run_time for animation in animations])

    def get_animation_time_progression(self, animations):
        &#34;&#34;&#34;
        You will hardly use this when making your own animations.
        This method is for Manim&#39;s internal use.

        Uses get_time_progression to obtaina
        CommandLine ProgressBar whose fill_time is
        dependent on the qualities of the passed animation, 

        Parameters
        ----------
        animations : list
            The list of animations to get
            the time progression for.

        Returns
        ------
        ProgressDisplay
            The CommandLine Progress Bar.
        &#34;&#34;&#34;
        run_time = self.get_run_time(animations)
        time_progression = self.get_time_progression(run_time)
        time_progression.set_description(&#34;&#34;.join([
            &#34;Animation {}: &#34;.format(self.num_plays),
            str(animations[0]),
            (&#34;, etc.&#34; if len(animations) &gt; 1 else &#34;&#34;),
        ]))
        return time_progression

    def compile_play_args_to_animation_list(self, *args, **kwargs):
        &#34;&#34;&#34;
        Each arg can either be an animation, or a mobject method
        followed by that methods arguments (and potentially follow
        by a dict of kwargs for that method).
        This animation list is built by going through the args list,
        and each animation is simply added, but when a mobject method
        s hit, a MoveToTarget animation is built using the args that
        follow up until either another animation is hit, another method
        is hit, or the args list runs out.
        
        Parameters
        ----------
        *args : Union[Animation, method(of a mobject, which is followed by that method&#39;s arguments)]
        **kwargs : any named arguments like run_time or lag_ratio.

        Returns
        -------
        list : list of animations with the parameters applied to them.
        &#34;&#34;&#34;
        animations = []
        state = {
            &#34;curr_method&#34;: None,
            &#34;last_method&#34;: None,
            &#34;method_args&#34;: [],
        }

        def compile_method(state):
            if state[&#34;curr_method&#34;] is None:
                return
            mobject = state[&#34;curr_method&#34;].__self__
            if state[&#34;last_method&#34;] and state[&#34;last_method&#34;].__self__ is mobject:
                animations.pop()
                # method should already have target then.
            else:
                mobject.generate_target()
            #
            if len(state[&#34;method_args&#34;]) &gt; 0 and isinstance(state[&#34;method_args&#34;][-1], dict):
                method_kwargs = state[&#34;method_args&#34;].pop()
            else:
                method_kwargs = {}
            state[&#34;curr_method&#34;].__func__(
                mobject.target,
                *state[&#34;method_args&#34;],
                **method_kwargs
            )
            animations.append(MoveToTarget(mobject))
            state[&#34;last_method&#34;] = state[&#34;curr_method&#34;]
            state[&#34;curr_method&#34;] = None
            state[&#34;method_args&#34;] = []

        for arg in args:
            if isinstance(arg, Animation):
                compile_method(state)
                animations.append(arg)
            elif inspect.ismethod(arg):
                compile_method(state)
                state[&#34;curr_method&#34;] = arg
            elif state[&#34;curr_method&#34;] is not None:
                state[&#34;method_args&#34;].append(arg)
            elif isinstance(arg, Mobject):
                raise Exception(&#34;&#34;&#34;
                    I think you may have invoked a method
                    you meant to pass in as a Scene.play argument
                &#34;&#34;&#34;)
            else:
                raise Exception(&#34;Invalid play arguments&#34;)
        compile_method(state)

        for animation in animations:
            # This is where kwargs to play like run_time and rate_func
            # get applied to all animations
            animation.update_config(**kwargs)

        return animations

    def update_skipping_status(self):
        &#34;&#34;&#34;
        This method is used internally to check if the current
        animation needs to be skipped or not. It also checks if
        the number of animations that were played correspond to
        the number of animations that need to be played, and 
        raises an EndSceneEarlyException if they don&#39;t correspond.
        &#34;&#34;&#34;
        
        if self.start_at_animation_number:
            if self.num_plays == self.start_at_animation_number:
                self.skip_animations = False
        if self.end_at_animation_number:
            if self.num_plays &gt;= self.end_at_animation_number:
                self.skip_animations = True
                raise EndSceneEarlyException()

    def handle_play_like_call(func):
        &#34;&#34;&#34;
        This method is used internally to wrap the
        passed function, into a function that
        actually writes to the video stream.
        Simultaneously, it also adds to the number 
        of animations played.

        Parameters
        ----------
        func: function object
            The play() like function that has to be
            written to the video file stream.

        Returns
        -------
        function object
            The play() like function that can now write
            to the video file stream.
        &#34;&#34;&#34;
        def wrapper(self, *args, **kwargs):
            self.update_skipping_status()
            allow_write = not self.skip_animations
            self.file_writer.begin_animation(allow_write)
            func(self, *args, **kwargs)
            self.file_writer.end_animation(allow_write)
            self.num_plays += 1
        return wrapper

    def begin_animations(self, animations):
        &#34;&#34;&#34;
        This method begins the list of animations that is passed,
        and adds any mobjects involved (if not already present)
        to the scene again.

        Parameters
        ----------
        animations: list
            List of involved animations.

        &#34;&#34;&#34;
        curr_mobjects = self.get_mobject_family_members()
        for animation in animations:
            # Begin animation
            animation.begin()
            # Anything animated that&#39;s not already in the
            # scene gets added to the scene
            mob = animation.mobject
            if mob not in curr_mobjects:
                self.add(mob)
                curr_mobjects += mob.get_family()

    def progress_through_animations(self, animations):
        &#34;&#34;&#34;
        This method progresses through each animation
        in the list passed and and updates the frames as required.

        Parameters
        ----------
        animations: list
            List of involved animations.
        &#34;&#34;&#34;
        # Paint all non-moving objects onto the screen, so they don&#39;t
        # have to be rendered every frame
        moving_mobjects = self.get_moving_mobjects(*animations)
        self.update_frame(excluded_mobjects=moving_mobjects)
        static_image = self.get_frame()
        last_t = 0
        for t in self.get_animation_time_progression(animations):
            dt = t - last_t
            last_t = t
            for animation in animations:
                animation.update_mobjects(dt)
                alpha = t / animation.run_time
                animation.interpolate(alpha)
            self.update_mobjects(dt)
            self.update_frame(moving_mobjects, static_image)
            self.add_frames(self.get_frame())

    def finish_animations(self, animations):
        &#34;&#34;&#34;
        This function cleans up after the end
        of each animation in the passed list.

        Parameters
        ----------
        animations: list
            list of animations to finish.
        &#34;&#34;&#34;
        for animation in animations:
            animation.finish()
            animation.clean_up_from_scene(self)
        self.mobjects_from_last_animation = [
            anim.mobject for anim in animations
        ]
        if self.skip_animations:
            # TODO, run this call in for each animation?
            self.update_mobjects(self.get_run_time(animations))
        else:
            self.update_mobjects(0)

    @handle_play_like_call
    def play(self, *args, **kwargs):
        &#34;&#34;&#34;
        This method is used to prep the animations for rendering,
        apply the arguments and parameters required to them,
        render them, and write them to the video file.

        Parameters
        ----------
        *args: Animation, mobject with mobject method and params
        **kwargs: named parameters affecting what was passed in *args e.g run_time, lag_ratio etc.
        &#34;&#34;&#34;
        if len(args) == 0:
            warnings.warn(&#34;Called Scene.play with no animations&#34;)
            return
        animations = self.compile_play_args_to_animation_list(
            *args, **kwargs
        )
        self.begin_animations(animations)
        self.progress_through_animations(animations)
        self.finish_animations(animations)

    def idle_stream(self):
        &#34;&#34;&#34;
        This method is used internally to 
        idle the vide file_writer until an
        animation etc needs to be written 
        to the video file.
        &#34;&#34;&#34;
        self.file_writer.idle_stream()

    def clean_up_animations(self, *animations):
        &#34;&#34;&#34;
        This method cleans up and removes from the
        scene all the animations that were passed

        Parameters
        ----------
        *animations: Animation
            Animation to clean up.

        Returns
        -------
        Scene
            The scene with the animations
            cleaned up.

        &#34;&#34;&#34;
        for animation in animations:
            animation.clean_up_from_scene(self)
        return self

    def get_mobjects_from_last_animation(self):
        &#34;&#34;&#34;
        This method returns the mobjects from the previous
        played animation, if any exist, and returns an empty
        list if not.

        Returns
        --------
        list
            The list of mobjects from the previous animation.

        &#34;&#34;&#34;
        if hasattr(self, &#34;mobjects_from_last_animation&#34;):
            return self.mobjects_from_last_animation
        return []

    def get_wait_time_progression(self, duration, stop_condition):
        &#34;&#34;&#34;
        This method is used internally to obtain the CommandLine
        Progressbar for when self.wait() is called in a scene.

        Parameters
        ----------
        duration: Union[list,float]
            duration of wait time
        
        stop_condition: function
            The function which determines whether to continue waiting.
        
        Returns
        -------
        ProgressBar
            The CommandLine ProgressBar of the wait time

        &#34;&#34;&#34;
        if stop_condition is not None:
            time_progression = self.get_time_progression(
                duration,
                n_iterations=-1,  # So it doesn&#39;t show % progress
                override_skip_animations=True
            )
            time_progression.set_description(
                &#34;Waiting for {}&#34;.format(stop_condition.__name__)
            )
        else:
            time_progression = self.get_time_progression(duration)
            time_progression.set_description(
                &#34;Waiting {}&#34;.format(self.num_plays)
            )
        return time_progression

    @handle_play_like_call
    def wait(self, duration=DEFAULT_WAIT_TIME, stop_condition=None):
        &#34;&#34;&#34;
        This method is used to wait, and do nothing to the scene, for some
        duration.
        Updaters stop updating, nothing happens.

        Parameters
        ----------
        duration : Union[float, int]
            The duration of wait time. Defaults to None.
        stop_condition : 
            A function that determines whether to stop waiting or not.
        
        Returns
        -------
        Scene
            The scene, after waiting.
        &#34;&#34;&#34;
        self.update_mobjects(dt=0)  # Any problems with this?
        if self.should_update_mobjects():
            time_progression = self.get_wait_time_progression(duration, stop_condition)
            # TODO, be smart about setting a static image
            # the same way Scene.play does
            last_t = 0
            for t in time_progression:
                dt = t - last_t
                last_t = t
                self.update_mobjects(dt)
                self.update_frame()
                self.add_frames(self.get_frame())
                if stop_condition is not None and stop_condition():
                    time_progression.close()
                    break
        elif self.skip_animations:
            # Do nothing
            return self
        else:
            self.update_frame()
            dt = 1 / self.camera.frame_rate
            n_frames = int(duration / dt)
            frame = self.get_frame()
            self.add_frames(*[frame] * n_frames)
        return self

    def wait_until(self, stop_condition, max_time=60):
        &#34;&#34;&#34;
        Like a wrapper for wait().
        You pass a function that determines whether to continue waiting,
        and a max wait time if that is never fulfilled.
        
        Parameters
        ----------
        stop_condition: function definition
            The function whose boolean return value determines whether to continue waiting
        
        max_time: Union[int,float]
            The maximum wait time in seconds, if the stop_condition is never fulfilled.
            Defaults to 60.
        &#34;&#34;&#34;
        self.wait(max_time, stop_condition=stop_condition)

    def force_skipping(self):
        &#34;&#34;&#34;
        This forces the skipping of animations,
        by setting original_skipping_status to
        whatever skip_animations was, and setting
        skip_animations to True.

        Returns
        -------
        Scene
            The Scene, with skipping turned on.
        &#34;&#34;&#34;
        self.original_skipping_status = self.skip_animations
        self.skip_animations = True
        return self

    def revert_to_original_skipping_status(self):
        &#34;&#34;&#34;
        Forces the scene to go back to its original skipping status,
        by setting skip_animations to whatever it reads 
        from original_skipping_status.

        Returns
        -------
        Scene
            The Scene, with the original skipping status.
        &#34;&#34;&#34;
        if hasattr(self, &#34;original_skipping_status&#34;):
            self.skip_animations = self.original_skipping_status
        return self

    def add_frames(self, *frames):
        &#34;&#34;&#34;
        Adds a frame to the video_file_stream

        Parameters
        ----------
        *frames : numpy.ndarray
            The frames to add, as pixel arrays.
        &#34;&#34;&#34;
        dt = 1 / self.camera.frame_rate
        self.increment_time(len(frames) * dt)
        if self.skip_animations:
            return
        for frame in frames:
            self.file_writer.write_frame(frame)

    def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):
        &#34;&#34;&#34;
        This method is used to add a sound to the animation.

        Parameters
        ----------
        sound_file: str
            The path to the sound file.
        
        time_offset: int,float = 0
            The offset in the sound file after which
            the sound can be played.
        gain:
            
        **kwargs : Present for excess? 

        &#34;&#34;&#34;
        if self.skip_animations:
            return
        time = self.get_time() + time_offset
        self.file_writer.add_sound(sound_file, time, gain, **kwargs)

    def show_frame(self):
        &#34;&#34;&#34;
        Opens the current frame in the Default Image Viewer
        of your system.
        &#34;&#34;&#34;
        self.update_frame(ignore_skipping=True)
        self.get_image().show()


class EndSceneEarlyException(Exception):
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.scene.scene.EndSceneEarlyException"><code class="flex name class">
<span>class <span class="ident">EndSceneEarlyException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EndSceneEarlyException(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="manimlib.scene.scene.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Scene can be thought of as the Canvas of your animation.
All of your own named Scenes will be subclasses of this Scene, or
other named scenes.</p>
<p>Use a construct() function to tell Manim what should go on in the Scene.</p>
<p>E.G:</p>
<pre><code>class MyScene(Scene):
    def construct(self):
        self.play(
            Write(Text("Hello World!"))
        )
</code></pre>
<p>Some important variables to note are:
camera: The camera object to be used for the scene.
file_writer : The object that writes the animations in the scene to a video file.
mobjects : The list of mobjects present in the scene.
foreground_mobjects : List of mobjects explicitly in the foreground.
num_plays : Number of play() functions in the scene.
time: time elapsed since initialisation of scene.
random_seed: The seed with which all random operations are done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scene(Container):
    &#34;&#34;&#34;
    A Scene can be thought of as the Canvas of your animation.
    All of your own named Scenes will be subclasses of this Scene, or
    other named scenes.

    Use a construct() function to tell Manim what should go on in the Scene.
    
    E.G:
        
        class MyScene(Scene):
            def construct(self):
                self.play(
                    Write(Text(&#34;Hello World!&#34;))
                )

    Some important variables to note are:
        camera: The camera object to be used for the scene.
        file_writer : The object that writes the animations in the scene to a video file.
        mobjects : The list of mobjects present in the scene.
        foreground_mobjects : List of mobjects explicitly in the foreground.
        num_plays : Number of play() functions in the scene.
        time: time elapsed since initialisation of scene.
        random_seed: The seed with which all random operations are done.
    &#34;&#34;&#34;
    CONFIG = {
        &#34;camera_class&#34;: Camera,
        &#34;camera_config&#34;: {},
        &#34;file_writer_config&#34;: {},
        &#34;skip_animations&#34;: False,
        &#34;always_update_mobjects&#34;: False,
        &#34;random_seed&#34;: 0,
        &#34;start_at_animation_number&#34;: None,
        &#34;end_at_animation_number&#34;: None,
        &#34;leave_progress_bars&#34;: False,
    }

    def __init__(self, **kwargs):
        Container.__init__(self, **kwargs)
        self.camera = self.camera_class(**self.camera_config)
        self.file_writer = SceneFileWriter(
            self, **self.file_writer_config,
        )

        self.mobjects = []
        # TODO, remove need for foreground mobjects
        self.foreground_mobjects = []
        self.num_plays = 0
        self.time = 0
        self.original_skipping_status = self.skip_animations
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.setup()
        try:
            self.construct()
        except EndSceneEarlyException:
            pass
        self.tear_down()
        self.file_writer.finish()
        self.print_end_message()

    def setup(self):
        &#34;&#34;&#34;
        This is meant to be implemented by any scenes which
        are comonly subclassed, and have some common setup
        involved before the construct method is called.
        &#34;&#34;&#34;
        pass

    def tear_down(self):
        &#34;&#34;&#34;
        This is meant to be implemented by any scenes which
        are comonly subclassed, and have some common method
        to be invoked before the scene ends.
        &#34;&#34;&#34;
        pass

    def construct(self):
        &#34;&#34;&#34;
        The primary method for constructing (i.e adding content to)
        the Scene.
        &#34;&#34;&#34;
        pass  # To be implemented in subclasses

    def __str__(self):
        return self.__class__.__name__

    def print_end_message(self):
        &#34;&#34;&#34;
        Used internally to print the number of
        animations played after the scene ends.
        &#34;&#34;&#34;
        print(&#34;Played {} animations&#34;.format(self.num_plays))

    def set_variables_as_attrs(self, *objects, **newly_named_objects):
        &#34;&#34;&#34;
        This method is slightly hacky, making it a little easier
        for certain methods (typically subroutines of construct)
        to share local variables.
        &#34;&#34;&#34;
        caller_locals = inspect.currentframe().f_back.f_locals
        for key, value in list(caller_locals.items()):
            for o in objects:
                if value is o:
                    setattr(self, key, value)
        for key, value in list(newly_named_objects.items()):
            setattr(self, key, value)
        return self

    def get_attrs(self, *keys):
        &#34;&#34;&#34;
        Gets attributes of a scene given the attribute&#39;s identifier/name.
        
        Parameters
        ----------
        *args: (str)
            Name(s) of the argument(s) to return the attribute of.
        
        Returns
        -------
        list
            List of attributes of the passed identifiers.
        &#34;&#34;&#34;
        return [getattr(self, key) for key in keys]

    # Only these methods should touch the camera
    def set_camera(self, camera):
        &#34;&#34;&#34;
        Sets the scene&#39;s camera to be the passed Camera Object.
        Parameters
        ----------
        camera: Union[Camera, MappingCamera,MovingCamera,MultiCamera,ThreeDCamera]
            Camera object to use.
        &#34;&#34;&#34;
        self.camera = camera

    def get_frame(self):
        &#34;&#34;&#34;
        Gets current frame as NumPy array.
        
        Returns
        -------
        np.array
            NumPy array of pixel values of each pixel in screen
        &#34;&#34;&#34;
        return np.array(self.camera.get_pixel_array())

    def get_image(self):
        &#34;&#34;&#34;
        Gets current frame as PIL Image
        
        Returns
        -------
        PIL.Image
            PIL Image object of current frame.
        &#34;&#34;&#34;
        return self.camera.get_image()

    def set_camera_pixel_array(self, pixel_array):
        &#34;&#34;&#34;
        Sets the camera to display a Pixel Array
        
        Parameters
        ----------
        pixel_array: Union[np.ndarray,list,tuple]
            Pixel array to set the camera to display
        &#34;&#34;&#34;
        self.camera.set_pixel_array(pixel_array)

    def set_camera_background(self, background):
        &#34;&#34;&#34;
        Sets the camera to display a Pixel Array
        
        Parameters
        ----------
        background: Union[np.ndarray,list,tuple]
            
        &#34;&#34;&#34;
        self.camera.set_background(background)

    def reset_camera(self):
        &#34;&#34;&#34;
        Resets the Camera to its original configuration.
        &#34;&#34;&#34;
        self.camera.reset()

    def capture_mobjects_in_camera(self, mobjects, **kwargs): #TODO Add more detail to docstring.
        &#34;&#34;&#34;
        This method is used internally.
        &#34;&#34;&#34;
        self.camera.capture_mobjects(mobjects, **kwargs)

    def update_frame( #TODO Description in Docstring
            self,
            mobjects=None,
            background=None,
            include_submobjects=True,
            ignore_skipping=True,
            **kwargs):
        &#34;&#34;&#34;
        Parameters:
        -----------
        mobjects: list
            list of mobjects
        
        background: np.ndarray
            Pixel Array for Background
        
        include_submobjects: bool (True)
        
        ignore_skipping : bool (True)

        **kwargs

        &#34;&#34;&#34;
        if self.skip_animations and not ignore_skipping:
            return
        if mobjects is None:
            mobjects = list_update(
                self.mobjects,
                self.foreground_mobjects,
            )
        if background is not None:
            self.set_camera_pixel_array(background)
        else:
            self.reset_camera()

        kwargs[&#34;include_submobjects&#34;] = include_submobjects
        self.capture_mobjects_in_camera(mobjects, **kwargs)

    def freeze_background(self):
        self.update_frame()
        self.set_camera(Camera(self.get_frame()))
        self.clear()
    ###

    def update_mobjects(self, dt):
        &#34;&#34;&#34;
        Begins updating all mobjects in the Scene.
        
        Parameters
        ----------
        dt: Union[int,float]
            Change in time between updates. Defaults (mostly) to 1/frames_per_second
        &#34;&#34;&#34;
        for mobject in self.mobjects:
            mobject.update(dt)

    def should_update_mobjects(self):
        &#34;&#34;&#34;
        Returns True if any mobject in Scene is being updated
        or if the scene has always_update_mobjects set to true.
        
        Returns
        -------
            bool
        &#34;&#34;&#34;
        return self.always_update_mobjects or any([
            mob.has_time_based_updater()
            for mob in self.get_mobject_family_members()
        ])

    ###

    def get_time(self):
        &#34;&#34;&#34;
        Returns time in seconds elapsed after initialisation of scene
        
        Returns
        -------
        self.time : Union[int,float]
            Returns time in seconds elapsed after initialisation of scene
        &#34;&#34;&#34;
        return self.time

    def increment_time(self, d_time):
        &#34;&#34;&#34;
        Increments the time elapsed after intialisation of scene by
        passed &#34;d_time&#34;.
        
        Parameters
        ----------
        d_time : Union[int,float]
            Time in seconds to increment by.
        &#34;&#34;&#34;
        self.time += d_time

    ###

    def get_top_level_mobjects(self):
        &#34;&#34;&#34;
        Returns all mobjects which are not submobjects.

        Returns
        -------
        list
            List of top level mobjects.
        &#34;&#34;&#34;
        # Return only those which are not in the family
        # of another mobject from the scene
        mobjects = self.get_mobjects()
        families = [m.get_family() for m in mobjects]

        def is_top_level(mobject):
            num_families = sum([
                (mobject in family)
                for family in families
            ])
            return num_families == 1
        return list(filter(is_top_level, mobjects))

    def get_mobject_family_members(self):
        &#34;&#34;&#34;
        Returns list of family-members of all mobjects in scene.
        If a Circle() and a VGroup(Rectangle(),Triangle()) were added,
        it returns not only the Circle(), Rectangle() and Triangle(), but
        also the VGroup() object.

        Returns
        -------
        list
            List of mobject family members.
        &#34;&#34;&#34;
        return self.camera.extract_mobject_family_members(self.mobjects)

    def add(self, *mobjects):
        &#34;&#34;&#34;
        Mobjects will be displayed, from background to
        foreground in the order with which they are added.

        Parameters
        ---------
        *mobjects
            Mobjects to add.
        
        Returns
        -------
        Scene
            The same scene after adding the Mobjects in.

        &#34;&#34;&#34;
        mobjects = [*mobjects, *self.foreground_mobjects]
        self.restructure_mobjects(to_remove=mobjects)
        self.mobjects += mobjects
        return self

    def add_mobjects_among(self, values):
        &#34;&#34;&#34;
        This is meant mostly for quick prototyping,
        e.g. to add all mobjects defined up to a point,
        call self.add_mobjects_among(locals().values())
        &#34;&#34;&#34;
        self.add(*filter(
            lambda m: isinstance(m, Mobject),
            values
        ))
        return self

    def remove(self, *mobjects):
        &#34;&#34;&#34;
        Removes mobjects in the passed list of mobjects
        from the scene and the foreground, by removing them
        from &#34;mobjects&#34; and &#34;foreground_mobjects&#34;
        &#34;&#34;&#34;
        for list_name in &#34;mobjects&#34;, &#34;foreground_mobjects&#34;:
            self.restructure_mobjects(mobjects, list_name, False)
        return self

    def restructure_mobjects(self, to_remove,
                             mobject_list_name=&#34;mobjects&#34;,
                             extract_families=True):
        &#34;&#34;&#34;
        tl:wr
            If your scene has a Group(), and you removed a mobject from the Group,
            this dissolves the group and puts the rest of the mobjects directly 
            in self.mobjects or self.foreground_mobjects.
        
        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
        will be edited to contain other submobjects, but not m1, e.g. it will now
        insert m2 and m3 to where the group once was.

        Parameters
        ----------
        to_remove : Mobject
            The Mobject to remove.
        
        mobject_list_name : str
            The list of mobjects (&#34;mobjects&#34;, &#34;foreground_mobjects&#34; etc) to remove from.
        
        extract_families : bool
            Whether the mobject&#39;s families should be recursively extracted.
        
        Returns
        -------
        Scene
            The Scene mobject with restructured Mobjects.
        &#34;&#34;&#34;
        if extract_families:
            to_remove = self.camera.extract_mobject_family_members(to_remove)
        _list = getattr(self, mobject_list_name)
        new_list = self.get_restructured_mobject_list(_list, to_remove)
        setattr(self, mobject_list_name, new_list)
        return self

    def get_restructured_mobject_list(self, mobjects, to_remove):
        &#34;&#34;&#34;
        Given a list of mobjects and a list of mobjects to be removed, this
        filters out the removable mobjects from the list of mobjects.
        
        Parameters
        ----------

        mobjects : list
            The Mobjects to check.
        
        to_remove : list
            The list of mobjects to remove.
        
        Returns
        -------
        list
            The list of mobjects with the mobjects to remove removed.
        &#34;&#34;&#34;
        
        new_mobjects = []

        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
            for mob in list_to_examine:
                if mob in set_to_remove:
                    continue
                intersect = set_to_remove.intersection(mob.get_family())
                if intersect:
                    add_safe_mobjects_from_list(mob.submobjects, intersect)
                else:
                    new_mobjects.append(mob)
        add_safe_mobjects_from_list(mobjects, set(to_remove))
        return new_mobjects

    # TODO, remove this, and calls to this
    def add_foreground_mobjects(self, *mobjects):
        &#34;&#34;&#34;
        Adds mobjects to the foreground, and internally to the list 
        foreground_mobjects, and mobjects.

        Parameters
        ----------
        *mobjects : Mobject
            The Mobjects to add to the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobjects added.
        &#34;&#34;&#34;
        self.foreground_mobjects = list_update(
            self.foreground_mobjects,
            mobjects
        )
        self.add(*mobjects)
        return self

    def add_foreground_mobject(self, mobject):
        &#34;&#34;&#34;
        Adds a single mobject to the foreground, and internally to the list 
        foreground_mobjects, and mobjects.

        Parameters
        ----------
        mobject : Mobject
            The Mobject to add to the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobject added.
        &#34;&#34;&#34;
        return self.add_foreground_mobjects(mobject)

    def remove_foreground_mobjects(self, *to_remove):
        &#34;&#34;&#34;
        Removes mobjects from the foreground, and internally from the list 
        foreground_mobjects.

        Parameters
        ----------
        *to_remove : Mobject
            The mobject(s) to remove from the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobjects removed.
        &#34;&#34;&#34;
        self.restructure_mobjects(to_remove, &#34;foreground_mobjects&#34;)
        return self

    def remove_foreground_mobject(self, mobject):
        &#34;&#34;&#34;
        Removes a single mobject from the foreground, and internally from the list 
        foreground_mobjects.

        Parameters
        ----------
        mobject : Mobject
            The mobject to remove from the foreground.
        
        Returns
        ------
        Scene
            The Scene, with the foreground mobject removed.
        &#34;&#34;&#34;
        return self.remove_foreground_mobjects(mobject)

    def bring_to_front(self, *mobjects):
        &#34;&#34;&#34;
        Adds the passed mobjects to the scene again, 
        pushing them to he front of the scene.

        Parameters
        ----------
        *mobjects : Mobject
            The mobject(s) to bring to the front of the scene.
        
        Returns
        ------
        Scene
            The Scene, with the mobjects brought to the front
            of the scene.
        &#34;&#34;&#34;
        self.add(*mobjects)
        return self

    def bring_to_back(self, *mobjects):
        &#34;&#34;&#34;
        Removes the mobject from the scene and
        adds them to the back of the scene.

        Parameters
        ----------
        *mobjects : Mobject
            The mobject(s) to push to the back of the scene.
        
        Returns
        ------
        Scene
            The Scene, with the mobjects pushed to the back
            of the scene.
        &#34;&#34;&#34;
        self.remove(*mobjects)
        self.mobjects = list(mobjects) + self.mobjects
        return self

    def clear(self):
        &#34;&#34;&#34;
        Removes all mobjects present in self.mobjects
        and self.foreground_mobjects from the scene.

        Returns
        ------
        Scene
            The Scene, with all of its mobjects in 
            self.mobjects and self.foreground_mobjects
            removed.
        &#34;&#34;&#34;
        self.mobjects = []
        self.foreground_mobjects = []
        return self

    def get_mobjects(self):
        &#34;&#34;&#34;
        Returns all the mobjects in self.mobjects

        Returns
        ------
        list
            The list of self.mobjects .
        &#34;&#34;&#34;
        return list(self.mobjects)

    def get_mobject_copies(self):
        &#34;&#34;&#34;
        Returns a copy of all mobjects present in
        self.mobjects .

        Returns
        ------
        list
            A list of the copies of all the mobjects
            in self.mobjects
        &#34;&#34;&#34;
        return [m.copy() for m in self.mobjects]

    def get_moving_mobjects(self, *animations):
        &#34;&#34;&#34;
        Gets all moving mobjects in the passed animation(s).
        
        Parameters
        ----------
        *animations
            The animations to check for moving mobjects.

        Returns
        ------
        list
            The list of mobjects that could be moving in
            the Animation(s)
        &#34;&#34;&#34;
        # Go through mobjects from start to end, and
        # as soon as there&#39;s one that needs updating of
        # some kind per frame, return the list from that
        # point forward.
        animation_mobjects = [anim.mobject for anim in animations]
        mobjects = self.get_mobject_family_members()
        for i, mob in enumerate(mobjects):
            update_possibilities = [
                mob in animation_mobjects,
                len(mob.get_family_updaters()) &gt; 0,
                mob in self.foreground_mobjects
            ]
            if any(update_possibilities):
                return mobjects[i:]
        return []

    def get_time_progression(self, run_time, n_iterations=None, override_skip_animations=False):
        &#34;&#34;&#34;
        You will hardly use this when making your own animations.
        This method is for Manim&#39;s internal use.

        Returns a CommandLine ProgressBar whose fill_time
        is dependent on the run_time of an animation, 
        the iterations to perform in that animation
        and a bool saying whether or not to consider
        the skipped animations.

        Parameters
        ----------
        run_time: Union[int,float]
            The run_time of the animation.
        
        n_iterations: None, int
            The number of iterations in the animation.
        
        override_skip_animations: bool (True)
            Whether or not to show skipped animations in the progress bar.

        Returns
        ------
        ProgressDisplay
            The CommandLine Progress Bar.
        &#34;&#34;&#34;
        if self.skip_animations and not override_skip_animations:
            times = [run_time]
        else:
            step = 1 / self.camera.frame_rate
            times = np.arange(0, run_time, step)
        time_progression = ProgressDisplay(
            times, total=n_iterations,
            leave=self.leave_progress_bars,
            ascii=False if platform.system() != &#39;Windows&#39; else True
        )
        return time_progression

    def get_run_time(self, animations):
        &#34;&#34;&#34;
        Gets the total run time for a list of animations.

        Parameters
        ----------
        animations: list
            A list of the animations whose total 
            run_time is to be calculated.
        
        Returns
        ------
        float
            The total run_time of all of the animations in the list.
        &#34;&#34;&#34;

        return np.max([animation.run_time for animation in animations])

    def get_animation_time_progression(self, animations):
        &#34;&#34;&#34;
        You will hardly use this when making your own animations.
        This method is for Manim&#39;s internal use.

        Uses get_time_progression to obtaina
        CommandLine ProgressBar whose fill_time is
        dependent on the qualities of the passed animation, 

        Parameters
        ----------
        animations : list
            The list of animations to get
            the time progression for.

        Returns
        ------
        ProgressDisplay
            The CommandLine Progress Bar.
        &#34;&#34;&#34;
        run_time = self.get_run_time(animations)
        time_progression = self.get_time_progression(run_time)
        time_progression.set_description(&#34;&#34;.join([
            &#34;Animation {}: &#34;.format(self.num_plays),
            str(animations[0]),
            (&#34;, etc.&#34; if len(animations) &gt; 1 else &#34;&#34;),
        ]))
        return time_progression

    def compile_play_args_to_animation_list(self, *args, **kwargs):
        &#34;&#34;&#34;
        Each arg can either be an animation, or a mobject method
        followed by that methods arguments (and potentially follow
        by a dict of kwargs for that method).
        This animation list is built by going through the args list,
        and each animation is simply added, but when a mobject method
        s hit, a MoveToTarget animation is built using the args that
        follow up until either another animation is hit, another method
        is hit, or the args list runs out.
        
        Parameters
        ----------
        *args : Union[Animation, method(of a mobject, which is followed by that method&#39;s arguments)]
        **kwargs : any named arguments like run_time or lag_ratio.

        Returns
        -------
        list : list of animations with the parameters applied to them.
        &#34;&#34;&#34;
        animations = []
        state = {
            &#34;curr_method&#34;: None,
            &#34;last_method&#34;: None,
            &#34;method_args&#34;: [],
        }

        def compile_method(state):
            if state[&#34;curr_method&#34;] is None:
                return
            mobject = state[&#34;curr_method&#34;].__self__
            if state[&#34;last_method&#34;] and state[&#34;last_method&#34;].__self__ is mobject:
                animations.pop()
                # method should already have target then.
            else:
                mobject.generate_target()
            #
            if len(state[&#34;method_args&#34;]) &gt; 0 and isinstance(state[&#34;method_args&#34;][-1], dict):
                method_kwargs = state[&#34;method_args&#34;].pop()
            else:
                method_kwargs = {}
            state[&#34;curr_method&#34;].__func__(
                mobject.target,
                *state[&#34;method_args&#34;],
                **method_kwargs
            )
            animations.append(MoveToTarget(mobject))
            state[&#34;last_method&#34;] = state[&#34;curr_method&#34;]
            state[&#34;curr_method&#34;] = None
            state[&#34;method_args&#34;] = []

        for arg in args:
            if isinstance(arg, Animation):
                compile_method(state)
                animations.append(arg)
            elif inspect.ismethod(arg):
                compile_method(state)
                state[&#34;curr_method&#34;] = arg
            elif state[&#34;curr_method&#34;] is not None:
                state[&#34;method_args&#34;].append(arg)
            elif isinstance(arg, Mobject):
                raise Exception(&#34;&#34;&#34;
                    I think you may have invoked a method
                    you meant to pass in as a Scene.play argument
                &#34;&#34;&#34;)
            else:
                raise Exception(&#34;Invalid play arguments&#34;)
        compile_method(state)

        for animation in animations:
            # This is where kwargs to play like run_time and rate_func
            # get applied to all animations
            animation.update_config(**kwargs)

        return animations

    def update_skipping_status(self):
        &#34;&#34;&#34;
        This method is used internally to check if the current
        animation needs to be skipped or not. It also checks if
        the number of animations that were played correspond to
        the number of animations that need to be played, and 
        raises an EndSceneEarlyException if they don&#39;t correspond.
        &#34;&#34;&#34;
        
        if self.start_at_animation_number:
            if self.num_plays == self.start_at_animation_number:
                self.skip_animations = False
        if self.end_at_animation_number:
            if self.num_plays &gt;= self.end_at_animation_number:
                self.skip_animations = True
                raise EndSceneEarlyException()

    def handle_play_like_call(func):
        &#34;&#34;&#34;
        This method is used internally to wrap the
        passed function, into a function that
        actually writes to the video stream.
        Simultaneously, it also adds to the number 
        of animations played.

        Parameters
        ----------
        func: function object
            The play() like function that has to be
            written to the video file stream.

        Returns
        -------
        function object
            The play() like function that can now write
            to the video file stream.
        &#34;&#34;&#34;
        def wrapper(self, *args, **kwargs):
            self.update_skipping_status()
            allow_write = not self.skip_animations
            self.file_writer.begin_animation(allow_write)
            func(self, *args, **kwargs)
            self.file_writer.end_animation(allow_write)
            self.num_plays += 1
        return wrapper

    def begin_animations(self, animations):
        &#34;&#34;&#34;
        This method begins the list of animations that is passed,
        and adds any mobjects involved (if not already present)
        to the scene again.

        Parameters
        ----------
        animations: list
            List of involved animations.

        &#34;&#34;&#34;
        curr_mobjects = self.get_mobject_family_members()
        for animation in animations:
            # Begin animation
            animation.begin()
            # Anything animated that&#39;s not already in the
            # scene gets added to the scene
            mob = animation.mobject
            if mob not in curr_mobjects:
                self.add(mob)
                curr_mobjects += mob.get_family()

    def progress_through_animations(self, animations):
        &#34;&#34;&#34;
        This method progresses through each animation
        in the list passed and and updates the frames as required.

        Parameters
        ----------
        animations: list
            List of involved animations.
        &#34;&#34;&#34;
        # Paint all non-moving objects onto the screen, so they don&#39;t
        # have to be rendered every frame
        moving_mobjects = self.get_moving_mobjects(*animations)
        self.update_frame(excluded_mobjects=moving_mobjects)
        static_image = self.get_frame()
        last_t = 0
        for t in self.get_animation_time_progression(animations):
            dt = t - last_t
            last_t = t
            for animation in animations:
                animation.update_mobjects(dt)
                alpha = t / animation.run_time
                animation.interpolate(alpha)
            self.update_mobjects(dt)
            self.update_frame(moving_mobjects, static_image)
            self.add_frames(self.get_frame())

    def finish_animations(self, animations):
        &#34;&#34;&#34;
        This function cleans up after the end
        of each animation in the passed list.

        Parameters
        ----------
        animations: list
            list of animations to finish.
        &#34;&#34;&#34;
        for animation in animations:
            animation.finish()
            animation.clean_up_from_scene(self)
        self.mobjects_from_last_animation = [
            anim.mobject for anim in animations
        ]
        if self.skip_animations:
            # TODO, run this call in for each animation?
            self.update_mobjects(self.get_run_time(animations))
        else:
            self.update_mobjects(0)

    @handle_play_like_call
    def play(self, *args, **kwargs):
        &#34;&#34;&#34;
        This method is used to prep the animations for rendering,
        apply the arguments and parameters required to them,
        render them, and write them to the video file.

        Parameters
        ----------
        *args: Animation, mobject with mobject method and params
        **kwargs: named parameters affecting what was passed in *args e.g run_time, lag_ratio etc.
        &#34;&#34;&#34;
        if len(args) == 0:
            warnings.warn(&#34;Called Scene.play with no animations&#34;)
            return
        animations = self.compile_play_args_to_animation_list(
            *args, **kwargs
        )
        self.begin_animations(animations)
        self.progress_through_animations(animations)
        self.finish_animations(animations)

    def idle_stream(self):
        &#34;&#34;&#34;
        This method is used internally to 
        idle the vide file_writer until an
        animation etc needs to be written 
        to the video file.
        &#34;&#34;&#34;
        self.file_writer.idle_stream()

    def clean_up_animations(self, *animations):
        &#34;&#34;&#34;
        This method cleans up and removes from the
        scene all the animations that were passed

        Parameters
        ----------
        *animations: Animation
            Animation to clean up.

        Returns
        -------
        Scene
            The scene with the animations
            cleaned up.

        &#34;&#34;&#34;
        for animation in animations:
            animation.clean_up_from_scene(self)
        return self

    def get_mobjects_from_last_animation(self):
        &#34;&#34;&#34;
        This method returns the mobjects from the previous
        played animation, if any exist, and returns an empty
        list if not.

        Returns
        --------
        list
            The list of mobjects from the previous animation.

        &#34;&#34;&#34;
        if hasattr(self, &#34;mobjects_from_last_animation&#34;):
            return self.mobjects_from_last_animation
        return []

    def get_wait_time_progression(self, duration, stop_condition):
        &#34;&#34;&#34;
        This method is used internally to obtain the CommandLine
        Progressbar for when self.wait() is called in a scene.

        Parameters
        ----------
        duration: Union[list,float]
            duration of wait time
        
        stop_condition: function
            The function which determines whether to continue waiting.
        
        Returns
        -------
        ProgressBar
            The CommandLine ProgressBar of the wait time

        &#34;&#34;&#34;
        if stop_condition is not None:
            time_progression = self.get_time_progression(
                duration,
                n_iterations=-1,  # So it doesn&#39;t show % progress
                override_skip_animations=True
            )
            time_progression.set_description(
                &#34;Waiting for {}&#34;.format(stop_condition.__name__)
            )
        else:
            time_progression = self.get_time_progression(duration)
            time_progression.set_description(
                &#34;Waiting {}&#34;.format(self.num_plays)
            )
        return time_progression

    @handle_play_like_call
    def wait(self, duration=DEFAULT_WAIT_TIME, stop_condition=None):
        &#34;&#34;&#34;
        This method is used to wait, and do nothing to the scene, for some
        duration.
        Updaters stop updating, nothing happens.

        Parameters
        ----------
        duration : Union[float, int]
            The duration of wait time. Defaults to None.
        stop_condition : 
            A function that determines whether to stop waiting or not.
        
        Returns
        -------
        Scene
            The scene, after waiting.
        &#34;&#34;&#34;
        self.update_mobjects(dt=0)  # Any problems with this?
        if self.should_update_mobjects():
            time_progression = self.get_wait_time_progression(duration, stop_condition)
            # TODO, be smart about setting a static image
            # the same way Scene.play does
            last_t = 0
            for t in time_progression:
                dt = t - last_t
                last_t = t
                self.update_mobjects(dt)
                self.update_frame()
                self.add_frames(self.get_frame())
                if stop_condition is not None and stop_condition():
                    time_progression.close()
                    break
        elif self.skip_animations:
            # Do nothing
            return self
        else:
            self.update_frame()
            dt = 1 / self.camera.frame_rate
            n_frames = int(duration / dt)
            frame = self.get_frame()
            self.add_frames(*[frame] * n_frames)
        return self

    def wait_until(self, stop_condition, max_time=60):
        &#34;&#34;&#34;
        Like a wrapper for wait().
        You pass a function that determines whether to continue waiting,
        and a max wait time if that is never fulfilled.
        
        Parameters
        ----------
        stop_condition: function definition
            The function whose boolean return value determines whether to continue waiting
        
        max_time: Union[int,float]
            The maximum wait time in seconds, if the stop_condition is never fulfilled.
            Defaults to 60.
        &#34;&#34;&#34;
        self.wait(max_time, stop_condition=stop_condition)

    def force_skipping(self):
        &#34;&#34;&#34;
        This forces the skipping of animations,
        by setting original_skipping_status to
        whatever skip_animations was, and setting
        skip_animations to True.

        Returns
        -------
        Scene
            The Scene, with skipping turned on.
        &#34;&#34;&#34;
        self.original_skipping_status = self.skip_animations
        self.skip_animations = True
        return self

    def revert_to_original_skipping_status(self):
        &#34;&#34;&#34;
        Forces the scene to go back to its original skipping status,
        by setting skip_animations to whatever it reads 
        from original_skipping_status.

        Returns
        -------
        Scene
            The Scene, with the original skipping status.
        &#34;&#34;&#34;
        if hasattr(self, &#34;original_skipping_status&#34;):
            self.skip_animations = self.original_skipping_status
        return self

    def add_frames(self, *frames):
        &#34;&#34;&#34;
        Adds a frame to the video_file_stream

        Parameters
        ----------
        *frames : numpy.ndarray
            The frames to add, as pixel arrays.
        &#34;&#34;&#34;
        dt = 1 / self.camera.frame_rate
        self.increment_time(len(frames) * dt)
        if self.skip_animations:
            return
        for frame in frames:
            self.file_writer.write_frame(frame)

    def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):
        &#34;&#34;&#34;
        This method is used to add a sound to the animation.

        Parameters
        ----------
        sound_file: str
            The path to the sound file.
        
        time_offset: int,float = 0
            The offset in the sound file after which
            the sound can be played.
        gain:
            
        **kwargs : Present for excess? 

        &#34;&#34;&#34;
        if self.skip_animations:
            return
        time = self.get_time() + time_offset
        self.file_writer.add_sound(sound_file, time, gain, **kwargs)

    def show_frame(self):
        &#34;&#34;&#34;
        Opens the current frame in the Default Image Viewer
        of your system.
        &#34;&#34;&#34;
        self.update_frame(ignore_skipping=True)
        self.get_image().show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.for_3b1b_videos.common_scenes.Banner" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.Banner">Banner</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.ExternallyAnimatedScene" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.ExternallyAnimatedScene">ExternallyAnimatedScene</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.OpeningQuote" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.OpeningQuote">OpeningQuote</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.PatreonThanks" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.PatreonThanks">PatreonThanks</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.TODOStub" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.TODOStub">TODOStub</a></li>
<li><a title="manimlib.for_3b1b_videos.pi_creature_scene.PiCreatureScene" href="../for_3b1b_videos/pi_creature_scene.html#manimlib.for_3b1b_videos.pi_creature_scene.PiCreatureScene">PiCreatureScene</a></li>
<li><a title="manimlib.once_useful_constructs.arithmetic.RearrangeEquation" href="../once_useful_constructs/arithmetic.html#manimlib.once_useful_constructs.arithmetic.RearrangeEquation">RearrangeEquation</a></li>
<li><a title="manimlib.once_useful_constructs.combinatorics.CountingScene" href="../once_useful_constructs/combinatorics.html#manimlib.once_useful_constructs.combinatorics.CountingScene">CountingScene</a></li>
<li><a title="manimlib.once_useful_constructs.complex_transformation_scene.ComplexTransformationScene" href="../once_useful_constructs/complex_transformation_scene.html#manimlib.once_useful_constructs.complex_transformation_scene.ComplexTransformationScene">ComplexTransformationScene</a></li>
<li><a title="manimlib.once_useful_constructs.counting.CountingScene" href="../once_useful_constructs/counting.html#manimlib.once_useful_constructs.counting.CountingScene">CountingScene</a></li>
<li><a title="manimlib.once_useful_constructs.graph_theory.DiscreteGraphScene" href="../once_useful_constructs/graph_theory.html#manimlib.once_useful_constructs.graph_theory.DiscreteGraphScene">DiscreteGraphScene</a></li>
<li><a title="manimlib.once_useful_constructs.matrix_multiplication.NumericalMatrixMultiplication" href="../once_useful_constructs/matrix_multiplication.html#manimlib.once_useful_constructs.matrix_multiplication.NumericalMatrixMultiplication">NumericalMatrixMultiplication</a></li>
<li><a title="manimlib.scene.graph_scene.GraphScene" href="graph_scene.html#manimlib.scene.graph_scene.GraphScene">GraphScene</a></li>
<li><a title="manimlib.scene.moving_camera_scene.MovingCameraScene" href="moving_camera_scene.html#manimlib.scene.moving_camera_scene.MovingCameraScene">MovingCameraScene</a></li>
<li><a title="manimlib.scene.reconfigurable_scene.ReconfigurableScene" href="reconfigurable_scene.html#manimlib.scene.reconfigurable_scene.ReconfigurableScene">ReconfigurableScene</a></li>
<li><a title="manimlib.scene.sample_space_scene.SampleSpaceScene" href="sample_space_scene.html#manimlib.scene.sample_space_scene.SampleSpaceScene">SampleSpaceScene</a></li>
<li><a title="manimlib.scene.scene_from_video.SceneFromVideo" href="scene_from_video.html#manimlib.scene.scene_from_video.SceneFromVideo">SceneFromVideo</a></li>
<li><a title="manimlib.scene.three_d_scene.ThreeDScene" href="three_d_scene.html#manimlib.scene.three_d_scene.ThreeDScene">ThreeDScene</a></li>
<li><a title="manimlib.scene.vector_space_scene.VectorScene" href="vector_space_scene.html#manimlib.scene.vector_space_scene.VectorScene">VectorScene</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.scene.scene.Scene.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.scene.scene.Scene.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Mobjects will be displayed, from background to
foreground in the order with which they are added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*mobjects</code></strong></dt>
<dd>Mobjects to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The same scene after adding the Mobjects in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, *mobjects):
    &#34;&#34;&#34;
    Mobjects will be displayed, from background to
    foreground in the order with which they are added.

    Parameters
    ---------
    *mobjects
        Mobjects to add.
    
    Returns
    -------
    Scene
        The same scene after adding the Mobjects in.

    &#34;&#34;&#34;
    mobjects = [*mobjects, *self.foreground_mobjects]
    self.restructure_mobjects(to_remove=mobjects)
    self.mobjects += mobjects
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_foreground_mobject"><code class="name flex">
<span>def <span class="ident">add_foreground_mobject</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a single mobject to the foreground, and internally to the list
foreground_mobjects, and mobjects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mobject</code></strong> :&ensp;<code>Mobject</code></dt>
<dd>The Mobject to add to the foreground.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with the foreground mobject added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_foreground_mobject(self, mobject):
    &#34;&#34;&#34;
    Adds a single mobject to the foreground, and internally to the list 
    foreground_mobjects, and mobjects.

    Parameters
    ----------
    mobject : Mobject
        The Mobject to add to the foreground.
    
    Returns
    ------
    Scene
        The Scene, with the foreground mobject added.
    &#34;&#34;&#34;
    return self.add_foreground_mobjects(mobject)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_foreground_mobjects"><code class="name flex">
<span>def <span class="ident">add_foreground_mobjects</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds mobjects to the foreground, and internally to the list
foreground_mobjects, and mobjects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*mobjects</code></strong> :&ensp;<code>Mobject</code></dt>
<dd>The Mobjects to add to the foreground.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with the foreground mobjects added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_foreground_mobjects(self, *mobjects):
    &#34;&#34;&#34;
    Adds mobjects to the foreground, and internally to the list 
    foreground_mobjects, and mobjects.

    Parameters
    ----------
    *mobjects : Mobject
        The Mobjects to add to the foreground.
    
    Returns
    ------
    Scene
        The Scene, with the foreground mobjects added.
    &#34;&#34;&#34;
    self.foreground_mobjects = list_update(
        self.foreground_mobjects,
        mobjects
    )
    self.add(*mobjects)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_frames"><code class="name flex">
<span>def <span class="ident">add_frames</span></span>(<span>self, *frames)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a frame to the video_file_stream</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*frames</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The frames to add, as pixel arrays.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_frames(self, *frames):
    &#34;&#34;&#34;
    Adds a frame to the video_file_stream

    Parameters
    ----------
    *frames : numpy.ndarray
        The frames to add, as pixel arrays.
    &#34;&#34;&#34;
    dt = 1 / self.camera.frame_rate
    self.increment_time(len(frames) * dt)
    if self.skip_animations:
        return
    for frame in frames:
        self.file_writer.write_frame(frame)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_mobjects_among"><code class="name flex">
<span>def <span class="ident">add_mobjects_among</span></span>(<span>self, values)</span>
</code></dt>
<dd>
<div class="desc"><p>This is meant mostly for quick prototyping,
e.g. to add all mobjects defined up to a point,
call self.add_mobjects_among(locals().values())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_mobjects_among(self, values):
    &#34;&#34;&#34;
    This is meant mostly for quick prototyping,
    e.g. to add all mobjects defined up to a point,
    call self.add_mobjects_among(locals().values())
    &#34;&#34;&#34;
    self.add(*filter(
        lambda m: isinstance(m, Mobject),
        values
    ))
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_sound"><code class="name flex">
<span>def <span class="ident">add_sound</span></span>(<span>self, sound_file, time_offset=0, gain=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used to add a sound to the animation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sound_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the sound file.</dd>
<dt><strong><code>time_offset</code></strong> :&ensp;<code>int,float = 0</code></dt>
<dd>The offset in the sound file after which
the sound can be played.</dd>
</dl>
<p>gain:</p>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Present for excess?</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):
    &#34;&#34;&#34;
    This method is used to add a sound to the animation.

    Parameters
    ----------
    sound_file: str
        The path to the sound file.
    
    time_offset: int,float = 0
        The offset in the sound file after which
        the sound can be played.
    gain:
        
    **kwargs : Present for excess? 

    &#34;&#34;&#34;
    if self.skip_animations:
        return
    time = self.get_time() + time_offset
    self.file_writer.add_sound(sound_file, time, gain, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.begin_animations"><code class="name flex">
<span>def <span class="ident">begin_animations</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"><p>This method begins the list of animations that is passed,
and adds any mobjects involved (if not already present)
to the scene again.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>animations</code></strong> :&ensp;<code>list</code></dt>
<dd>List of involved animations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_animations(self, animations):
    &#34;&#34;&#34;
    This method begins the list of animations that is passed,
    and adds any mobjects involved (if not already present)
    to the scene again.

    Parameters
    ----------
    animations: list
        List of involved animations.

    &#34;&#34;&#34;
    curr_mobjects = self.get_mobject_family_members()
    for animation in animations:
        # Begin animation
        animation.begin()
        # Anything animated that&#39;s not already in the
        # scene gets added to the scene
        mob = animation.mobject
        if mob not in curr_mobjects:
            self.add(mob)
            curr_mobjects += mob.get_family()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.bring_to_back"><code class="name flex">
<span>def <span class="ident">bring_to_back</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the mobject from the scene and
adds them to the back of the scene.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*mobjects</code></strong> :&ensp;<code>Mobject</code></dt>
<dd>The mobject(s) to push to the back of the scene.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with the mobjects pushed to the back
of the scene.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bring_to_back(self, *mobjects):
    &#34;&#34;&#34;
    Removes the mobject from the scene and
    adds them to the back of the scene.

    Parameters
    ----------
    *mobjects : Mobject
        The mobject(s) to push to the back of the scene.
    
    Returns
    ------
    Scene
        The Scene, with the mobjects pushed to the back
        of the scene.
    &#34;&#34;&#34;
    self.remove(*mobjects)
    self.mobjects = list(mobjects) + self.mobjects
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.bring_to_front"><code class="name flex">
<span>def <span class="ident">bring_to_front</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the passed mobjects to the scene again,
pushing them to he front of the scene.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*mobjects</code></strong> :&ensp;<code>Mobject</code></dt>
<dd>The mobject(s) to bring to the front of the scene.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with the mobjects brought to the front
of the scene.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bring_to_front(self, *mobjects):
    &#34;&#34;&#34;
    Adds the passed mobjects to the scene again, 
    pushing them to he front of the scene.

    Parameters
    ----------
    *mobjects : Mobject
        The mobject(s) to bring to the front of the scene.
    
    Returns
    ------
    Scene
        The Scene, with the mobjects brought to the front
        of the scene.
    &#34;&#34;&#34;
    self.add(*mobjects)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.capture_mobjects_in_camera"><code class="name flex">
<span>def <span class="ident">capture_mobjects_in_camera</span></span>(<span>self, mobjects, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used internally.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_mobjects_in_camera(self, mobjects, **kwargs): #TODO Add more detail to docstring.
    &#34;&#34;&#34;
    This method is used internally.
    &#34;&#34;&#34;
    self.camera.capture_mobjects(mobjects, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.clean_up_animations"><code class="name flex">
<span>def <span class="ident">clean_up_animations</span></span>(<span>self, *animations)</span>
</code></dt>
<dd>
<div class="desc"><p>This method cleans up and removes from the
scene all the animations that were passed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*animations</code></strong> :&ensp;<code>Animation</code></dt>
<dd>Animation to clean up.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The scene with the animations
cleaned up.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up_animations(self, *animations):
    &#34;&#34;&#34;
    This method cleans up and removes from the
    scene all the animations that were passed

    Parameters
    ----------
    *animations: Animation
        Animation to clean up.

    Returns
    -------
    Scene
        The scene with the animations
        cleaned up.

    &#34;&#34;&#34;
    for animation in animations:
        animation.clean_up_from_scene(self)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all mobjects present in self.mobjects
and self.foreground_mobjects from the scene.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with all of its mobjects in
self.mobjects and self.foreground_mobjects
removed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Removes all mobjects present in self.mobjects
    and self.foreground_mobjects from the scene.

    Returns
    ------
    Scene
        The Scene, with all of its mobjects in 
        self.mobjects and self.foreground_mobjects
        removed.
    &#34;&#34;&#34;
    self.mobjects = []
    self.foreground_mobjects = []
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.compile_play_args_to_animation_list"><code class="name flex">
<span>def <span class="ident">compile_play_args_to_animation_list</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Each arg can either be an animation, or a mobject method
followed by that methods arguments (and potentially follow
by a dict of kwargs for that method).
This animation list is built by going through the args list,
and each animation is simply added, but when a mobject method
s hit, a MoveToTarget animation is built using the args that
follow up until either another animation is hit, another method
is hit, or the args list runs out.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>Union[Animation, method(of a mobject, which is followed by that method's arguments)]</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>**kwargs : any named arguments like run_time or lag_ratio.</p>
<h2 id="returns">Returns</h2>
<p>list : list of animations with the parameters applied to them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_play_args_to_animation_list(self, *args, **kwargs):
    &#34;&#34;&#34;
    Each arg can either be an animation, or a mobject method
    followed by that methods arguments (and potentially follow
    by a dict of kwargs for that method).
    This animation list is built by going through the args list,
    and each animation is simply added, but when a mobject method
    s hit, a MoveToTarget animation is built using the args that
    follow up until either another animation is hit, another method
    is hit, or the args list runs out.
    
    Parameters
    ----------
    *args : Union[Animation, method(of a mobject, which is followed by that method&#39;s arguments)]
    **kwargs : any named arguments like run_time or lag_ratio.

    Returns
    -------
    list : list of animations with the parameters applied to them.
    &#34;&#34;&#34;
    animations = []
    state = {
        &#34;curr_method&#34;: None,
        &#34;last_method&#34;: None,
        &#34;method_args&#34;: [],
    }

    def compile_method(state):
        if state[&#34;curr_method&#34;] is None:
            return
        mobject = state[&#34;curr_method&#34;].__self__
        if state[&#34;last_method&#34;] and state[&#34;last_method&#34;].__self__ is mobject:
            animations.pop()
            # method should already have target then.
        else:
            mobject.generate_target()
        #
        if len(state[&#34;method_args&#34;]) &gt; 0 and isinstance(state[&#34;method_args&#34;][-1], dict):
            method_kwargs = state[&#34;method_args&#34;].pop()
        else:
            method_kwargs = {}
        state[&#34;curr_method&#34;].__func__(
            mobject.target,
            *state[&#34;method_args&#34;],
            **method_kwargs
        )
        animations.append(MoveToTarget(mobject))
        state[&#34;last_method&#34;] = state[&#34;curr_method&#34;]
        state[&#34;curr_method&#34;] = None
        state[&#34;method_args&#34;] = []

    for arg in args:
        if isinstance(arg, Animation):
            compile_method(state)
            animations.append(arg)
        elif inspect.ismethod(arg):
            compile_method(state)
            state[&#34;curr_method&#34;] = arg
        elif state[&#34;curr_method&#34;] is not None:
            state[&#34;method_args&#34;].append(arg)
        elif isinstance(arg, Mobject):
            raise Exception(&#34;&#34;&#34;
                I think you may have invoked a method
                you meant to pass in as a Scene.play argument
            &#34;&#34;&#34;)
        else:
            raise Exception(&#34;Invalid play arguments&#34;)
    compile_method(state)

    for animation in animations:
        # This is where kwargs to play like run_time and rate_func
        # get applied to all animations
        animation.update_config(**kwargs)

    return animations</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.construct"><code class="name flex">
<span>def <span class="ident">construct</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The primary method for constructing (i.e adding content to)
the Scene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct(self):
    &#34;&#34;&#34;
    The primary method for constructing (i.e adding content to)
    the Scene.
    &#34;&#34;&#34;
    pass  # To be implemented in subclasses</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.finish_animations"><code class="name flex">
<span>def <span class="ident">finish_animations</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"><p>This function cleans up after the end
of each animation in the passed list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>animations</code></strong> :&ensp;<code>list</code></dt>
<dd>list of animations to finish.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_animations(self, animations):
    &#34;&#34;&#34;
    This function cleans up after the end
    of each animation in the passed list.

    Parameters
    ----------
    animations: list
        list of animations to finish.
    &#34;&#34;&#34;
    for animation in animations:
        animation.finish()
        animation.clean_up_from_scene(self)
    self.mobjects_from_last_animation = [
        anim.mobject for anim in animations
    ]
    if self.skip_animations:
        # TODO, run this call in for each animation?
        self.update_mobjects(self.get_run_time(animations))
    else:
        self.update_mobjects(0)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.force_skipping"><code class="name flex">
<span>def <span class="ident">force_skipping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This forces the skipping of animations,
by setting original_skipping_status to
whatever skip_animations was, and setting
skip_animations to True.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with skipping turned on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_skipping(self):
    &#34;&#34;&#34;
    This forces the skipping of animations,
    by setting original_skipping_status to
    whatever skip_animations was, and setting
    skip_animations to True.

    Returns
    -------
    Scene
        The Scene, with skipping turned on.
    &#34;&#34;&#34;
    self.original_skipping_status = self.skip_animations
    self.skip_animations = True
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.freeze_background"><code class="name flex">
<span>def <span class="ident">freeze_background</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freeze_background(self):
    self.update_frame()
    self.set_camera(Camera(self.get_frame()))
    self.clear()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_animation_time_progression"><code class="name flex">
<span>def <span class="ident">get_animation_time_progression</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"><p>You will hardly use this when making your own animations.
This method is for Manim's internal use.</p>
<p>Uses get_time_progression to obtaina
CommandLine ProgressBar whose fill_time is
dependent on the qualities of the passed animation, </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>animations</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of animations to get
the time progression for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgressDisplay</code></dt>
<dd>The CommandLine Progress Bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_animation_time_progression(self, animations):
    &#34;&#34;&#34;
    You will hardly use this when making your own animations.
    This method is for Manim&#39;s internal use.

    Uses get_time_progression to obtaina
    CommandLine ProgressBar whose fill_time is
    dependent on the qualities of the passed animation, 

    Parameters
    ----------
    animations : list
        The list of animations to get
        the time progression for.

    Returns
    ------
    ProgressDisplay
        The CommandLine Progress Bar.
    &#34;&#34;&#34;
    run_time = self.get_run_time(animations)
    time_progression = self.get_time_progression(run_time)
    time_progression.set_description(&#34;&#34;.join([
        &#34;Animation {}: &#34;.format(self.num_plays),
        str(animations[0]),
        (&#34;, etc.&#34; if len(animations) &gt; 1 else &#34;&#34;),
    ]))
    return time_progression</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_attrs"><code class="name flex">
<span>def <span class="ident">get_attrs</span></span>(<span>self, *keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets attributes of a scene given the attribute's identifier/name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>(str)</code></dt>
<dd>Name(s) of the argument(s) to return the attribute of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of attributes of the passed identifiers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attrs(self, *keys):
    &#34;&#34;&#34;
    Gets attributes of a scene given the attribute&#39;s identifier/name.
    
    Parameters
    ----------
    *args: (str)
        Name(s) of the argument(s) to return the attribute of.
    
    Returns
    -------
    list
        List of attributes of the passed identifiers.
    &#34;&#34;&#34;
    return [getattr(self, key) for key in keys]</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_frame"><code class="name flex">
<span>def <span class="ident">get_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets current frame as NumPy array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>NumPy array of pixel values of each pixel in screen</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame(self):
    &#34;&#34;&#34;
    Gets current frame as NumPy array.
    
    Returns
    -------
    np.array
        NumPy array of pixel values of each pixel in screen
    &#34;&#34;&#34;
    return np.array(self.camera.get_pixel_array())</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets current frame as PIL Image</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>PIL Image object of current frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image(self):
    &#34;&#34;&#34;
    Gets current frame as PIL Image
    
    Returns
    -------
    PIL.Image
        PIL Image object of current frame.
    &#34;&#34;&#34;
    return self.camera.get_image()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobject_copies"><code class="name flex">
<span>def <span class="ident">get_mobject_copies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of all mobjects present in
self.mobjects .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of the copies of all the mobjects
in self.mobjects</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobject_copies(self):
    &#34;&#34;&#34;
    Returns a copy of all mobjects present in
    self.mobjects .

    Returns
    ------
    list
        A list of the copies of all the mobjects
        in self.mobjects
    &#34;&#34;&#34;
    return [m.copy() for m in self.mobjects]</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobject_family_members"><code class="name flex">
<span>def <span class="ident">get_mobject_family_members</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of family-members of all mobjects in scene.
If a Circle() and a VGroup(Rectangle(),Triangle()) were added,
it returns not only the Circle(), Rectangle() and Triangle(), but
also the VGroup() object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of mobject family members.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobject_family_members(self):
    &#34;&#34;&#34;
    Returns list of family-members of all mobjects in scene.
    If a Circle() and a VGroup(Rectangle(),Triangle()) were added,
    it returns not only the Circle(), Rectangle() and Triangle(), but
    also the VGroup() object.

    Returns
    -------
    list
        List of mobject family members.
    &#34;&#34;&#34;
    return self.camera.extract_mobject_family_members(self.mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobjects"><code class="name flex">
<span>def <span class="ident">get_mobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all the mobjects in self.mobjects</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The list of self.mobjects .</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobjects(self):
    &#34;&#34;&#34;
    Returns all the mobjects in self.mobjects

    Returns
    ------
    list
        The list of self.mobjects .
    &#34;&#34;&#34;
    return list(self.mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobjects_from_last_animation"><code class="name flex">
<span>def <span class="ident">get_mobjects_from_last_animation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the mobjects from the previous
played animation, if any exist, and returns an empty
list if not.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The list of mobjects from the previous animation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobjects_from_last_animation(self):
    &#34;&#34;&#34;
    This method returns the mobjects from the previous
    played animation, if any exist, and returns an empty
    list if not.

    Returns
    --------
    list
        The list of mobjects from the previous animation.

    &#34;&#34;&#34;
    if hasattr(self, &#34;mobjects_from_last_animation&#34;):
        return self.mobjects_from_last_animation
    return []</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_moving_mobjects"><code class="name flex">
<span>def <span class="ident">get_moving_mobjects</span></span>(<span>self, *animations)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all moving mobjects in the passed animation(s).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*animations</code></strong></dt>
<dd>The animations to check for moving mobjects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The list of mobjects that could be moving in
the Animation(s)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_moving_mobjects(self, *animations):
    &#34;&#34;&#34;
    Gets all moving mobjects in the passed animation(s).
    
    Parameters
    ----------
    *animations
        The animations to check for moving mobjects.

    Returns
    ------
    list
        The list of mobjects that could be moving in
        the Animation(s)
    &#34;&#34;&#34;
    # Go through mobjects from start to end, and
    # as soon as there&#39;s one that needs updating of
    # some kind per frame, return the list from that
    # point forward.
    animation_mobjects = [anim.mobject for anim in animations]
    mobjects = self.get_mobject_family_members()
    for i, mob in enumerate(mobjects):
        update_possibilities = [
            mob in animation_mobjects,
            len(mob.get_family_updaters()) &gt; 0,
            mob in self.foreground_mobjects
        ]
        if any(update_possibilities):
            return mobjects[i:]
    return []</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_restructured_mobject_list"><code class="name flex">
<span>def <span class="ident">get_restructured_mobject_list</span></span>(<span>self, mobjects, to_remove)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a list of mobjects and a list of mobjects to be removed, this
filters out the removable mobjects from the list of mobjects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mobjects</code></strong> :&ensp;<code>list</code></dt>
<dd>The Mobjects to check.</dd>
<dt><strong><code>to_remove</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of mobjects to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The list of mobjects with the mobjects to remove removed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_restructured_mobject_list(self, mobjects, to_remove):
    &#34;&#34;&#34;
    Given a list of mobjects and a list of mobjects to be removed, this
    filters out the removable mobjects from the list of mobjects.
    
    Parameters
    ----------

    mobjects : list
        The Mobjects to check.
    
    to_remove : list
        The list of mobjects to remove.
    
    Returns
    -------
    list
        The list of mobjects with the mobjects to remove removed.
    &#34;&#34;&#34;
    
    new_mobjects = []

    def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
        for mob in list_to_examine:
            if mob in set_to_remove:
                continue
            intersect = set_to_remove.intersection(mob.get_family())
            if intersect:
                add_safe_mobjects_from_list(mob.submobjects, intersect)
            else:
                new_mobjects.append(mob)
    add_safe_mobjects_from_list(mobjects, set(to_remove))
    return new_mobjects</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_run_time"><code class="name flex">
<span>def <span class="ident">get_run_time</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the total run time for a list of animations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>animations</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of the animations whose total
run_time is to be calculated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The total run_time of all of the animations in the list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_run_time(self, animations):
    &#34;&#34;&#34;
    Gets the total run time for a list of animations.

    Parameters
    ----------
    animations: list
        A list of the animations whose total 
        run_time is to be calculated.
    
    Returns
    ------
    float
        The total run_time of all of the animations in the list.
    &#34;&#34;&#34;

    return np.max([animation.run_time for animation in animations])</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns time in seconds elapsed after initialisation of scene</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.time : Union[int,float]</code></dt>
<dd>Returns time in seconds elapsed after initialisation of scene</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self):
    &#34;&#34;&#34;
    Returns time in seconds elapsed after initialisation of scene
    
    Returns
    -------
    self.time : Union[int,float]
        Returns time in seconds elapsed after initialisation of scene
    &#34;&#34;&#34;
    return self.time</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_time_progression"><code class="name flex">
<span>def <span class="ident">get_time_progression</span></span>(<span>self, run_time, n_iterations=None, override_skip_animations=False)</span>
</code></dt>
<dd>
<div class="desc"><p>You will hardly use this when making your own animations.
This method is for Manim's internal use.</p>
<p>Returns a CommandLine ProgressBar whose fill_time
is dependent on the run_time of an animation,
the iterations to perform in that animation
and a bool saying whether or not to consider
the skipped animations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>run_time</code></strong> :&ensp;<code>Union[int,float]</code></dt>
<dd>The run_time of the animation.</dd>
<dt><strong><code>n_iterations</code></strong> :&ensp;<code>None, int</code></dt>
<dd>The number of iterations in the animation.</dd>
<dt><strong><code>override_skip_animations</code></strong> :&ensp;<code>bool (True)</code></dt>
<dd>Whether or not to show skipped animations in the progress bar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgressDisplay</code></dt>
<dd>The CommandLine Progress Bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_progression(self, run_time, n_iterations=None, override_skip_animations=False):
    &#34;&#34;&#34;
    You will hardly use this when making your own animations.
    This method is for Manim&#39;s internal use.

    Returns a CommandLine ProgressBar whose fill_time
    is dependent on the run_time of an animation, 
    the iterations to perform in that animation
    and a bool saying whether or not to consider
    the skipped animations.

    Parameters
    ----------
    run_time: Union[int,float]
        The run_time of the animation.
    
    n_iterations: None, int
        The number of iterations in the animation.
    
    override_skip_animations: bool (True)
        Whether or not to show skipped animations in the progress bar.

    Returns
    ------
    ProgressDisplay
        The CommandLine Progress Bar.
    &#34;&#34;&#34;
    if self.skip_animations and not override_skip_animations:
        times = [run_time]
    else:
        step = 1 / self.camera.frame_rate
        times = np.arange(0, run_time, step)
    time_progression = ProgressDisplay(
        times, total=n_iterations,
        leave=self.leave_progress_bars,
        ascii=False if platform.system() != &#39;Windows&#39; else True
    )
    return time_progression</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_top_level_mobjects"><code class="name flex">
<span>def <span class="ident">get_top_level_mobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all mobjects which are not submobjects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of top level mobjects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_top_level_mobjects(self):
    &#34;&#34;&#34;
    Returns all mobjects which are not submobjects.

    Returns
    -------
    list
        List of top level mobjects.
    &#34;&#34;&#34;
    # Return only those which are not in the family
    # of another mobject from the scene
    mobjects = self.get_mobjects()
    families = [m.get_family() for m in mobjects]

    def is_top_level(mobject):
        num_families = sum([
            (mobject in family)
            for family in families
        ])
        return num_families == 1
    return list(filter(is_top_level, mobjects))</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_wait_time_progression"><code class="name flex">
<span>def <span class="ident">get_wait_time_progression</span></span>(<span>self, duration, stop_condition)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used internally to obtain the CommandLine
Progressbar for when self.wait() is called in a scene.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>duration</code></strong> :&ensp;<code>Union[list,float]</code></dt>
<dd>duration of wait time</dd>
<dt><strong><code>stop_condition</code></strong> :&ensp;<code>function</code></dt>
<dd>The function which determines whether to continue waiting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgressBar</code></dt>
<dd>The CommandLine ProgressBar of the wait time</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wait_time_progression(self, duration, stop_condition):
    &#34;&#34;&#34;
    This method is used internally to obtain the CommandLine
    Progressbar for when self.wait() is called in a scene.

    Parameters
    ----------
    duration: Union[list,float]
        duration of wait time
    
    stop_condition: function
        The function which determines whether to continue waiting.
    
    Returns
    -------
    ProgressBar
        The CommandLine ProgressBar of the wait time

    &#34;&#34;&#34;
    if stop_condition is not None:
        time_progression = self.get_time_progression(
            duration,
            n_iterations=-1,  # So it doesn&#39;t show % progress
            override_skip_animations=True
        )
        time_progression.set_description(
            &#34;Waiting for {}&#34;.format(stop_condition.__name__)
        )
    else:
        time_progression = self.get_time_progression(duration)
        time_progression.set_description(
            &#34;Waiting {}&#34;.format(self.num_plays)
        )
    return time_progression</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.handle_play_like_call"><code class="name flex">
<span>def <span class="ident">handle_play_like_call</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used internally to wrap the
passed function, into a function that
actually writes to the video stream.
Simultaneously, it also adds to the number
of animations played.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>function object</code></dt>
<dd>The play() like function that has to be
written to the video file stream.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function object</code></dt>
<dd>The play() like function that can now write
to the video file stream.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_play_like_call(func):
    &#34;&#34;&#34;
    This method is used internally to wrap the
    passed function, into a function that
    actually writes to the video stream.
    Simultaneously, it also adds to the number 
    of animations played.

    Parameters
    ----------
    func: function object
        The play() like function that has to be
        written to the video file stream.

    Returns
    -------
    function object
        The play() like function that can now write
        to the video file stream.
    &#34;&#34;&#34;
    def wrapper(self, *args, **kwargs):
        self.update_skipping_status()
        allow_write = not self.skip_animations
        self.file_writer.begin_animation(allow_write)
        func(self, *args, **kwargs)
        self.file_writer.end_animation(allow_write)
        self.num_plays += 1
    return wrapper</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.idle_stream"><code class="name flex">
<span>def <span class="ident">idle_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used internally to
idle the vide file_writer until an
animation etc needs to be written
to the video file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_stream(self):
    &#34;&#34;&#34;
    This method is used internally to 
    idle the vide file_writer until an
    animation etc needs to be written 
    to the video file.
    &#34;&#34;&#34;
    self.file_writer.idle_stream()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.increment_time"><code class="name flex">
<span>def <span class="ident">increment_time</span></span>(<span>self, d_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Increments the time elapsed after intialisation of scene by
passed "d_time".</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>d_time</code></strong> :&ensp;<code>Union[int,float]</code></dt>
<dd>Time in seconds to increment by.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_time(self, d_time):
    &#34;&#34;&#34;
    Increments the time elapsed after intialisation of scene by
    passed &#34;d_time&#34;.
    
    Parameters
    ----------
    d_time : Union[int,float]
        Time in seconds to increment by.
    &#34;&#34;&#34;
    self.time += d_time</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, *args, **kwargs):
    self.update_skipping_status()
    allow_write = not self.skip_animations
    self.file_writer.begin_animation(allow_write)
    func(self, *args, **kwargs)
    self.file_writer.end_animation(allow_write)
    self.num_plays += 1</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.print_end_message"><code class="name flex">
<span>def <span class="ident">print_end_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Used internally to print the number of
animations played after the scene ends.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_end_message(self):
    &#34;&#34;&#34;
    Used internally to print the number of
    animations played after the scene ends.
    &#34;&#34;&#34;
    print(&#34;Played {} animations&#34;.format(self.num_plays))</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.progress_through_animations"><code class="name flex">
<span>def <span class="ident">progress_through_animations</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"><p>This method progresses through each animation
in the list passed and and updates the frames as required.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>animations</code></strong> :&ensp;<code>list</code></dt>
<dd>List of involved animations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_through_animations(self, animations):
    &#34;&#34;&#34;
    This method progresses through each animation
    in the list passed and and updates the frames as required.

    Parameters
    ----------
    animations: list
        List of involved animations.
    &#34;&#34;&#34;
    # Paint all non-moving objects onto the screen, so they don&#39;t
    # have to be rendered every frame
    moving_mobjects = self.get_moving_mobjects(*animations)
    self.update_frame(excluded_mobjects=moving_mobjects)
    static_image = self.get_frame()
    last_t = 0
    for t in self.get_animation_time_progression(animations):
        dt = t - last_t
        last_t = t
        for animation in animations:
            animation.update_mobjects(dt)
            alpha = t / animation.run_time
            animation.interpolate(alpha)
        self.update_mobjects(dt)
        self.update_frame(moving_mobjects, static_image)
        self.add_frames(self.get_frame())</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes mobjects in the passed list of mobjects
from the scene and the foreground, by removing them
from "mobjects" and "foreground_mobjects"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, *mobjects):
    &#34;&#34;&#34;
    Removes mobjects in the passed list of mobjects
    from the scene and the foreground, by removing them
    from &#34;mobjects&#34; and &#34;foreground_mobjects&#34;
    &#34;&#34;&#34;
    for list_name in &#34;mobjects&#34;, &#34;foreground_mobjects&#34;:
        self.restructure_mobjects(mobjects, list_name, False)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.remove_foreground_mobject"><code class="name flex">
<span>def <span class="ident">remove_foreground_mobject</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a single mobject from the foreground, and internally from the list
foreground_mobjects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mobject</code></strong> :&ensp;<code>Mobject</code></dt>
<dd>The mobject to remove from the foreground.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with the foreground mobject removed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_foreground_mobject(self, mobject):
    &#34;&#34;&#34;
    Removes a single mobject from the foreground, and internally from the list 
    foreground_mobjects.

    Parameters
    ----------
    mobject : Mobject
        The mobject to remove from the foreground.
    
    Returns
    ------
    Scene
        The Scene, with the foreground mobject removed.
    &#34;&#34;&#34;
    return self.remove_foreground_mobjects(mobject)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.remove_foreground_mobjects"><code class="name flex">
<span>def <span class="ident">remove_foreground_mobjects</span></span>(<span>self, *to_remove)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes mobjects from the foreground, and internally from the list
foreground_mobjects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*to_remove</code></strong> :&ensp;<code>Mobject</code></dt>
<dd>The mobject(s) to remove from the foreground.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with the foreground mobjects removed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_foreground_mobjects(self, *to_remove):
    &#34;&#34;&#34;
    Removes mobjects from the foreground, and internally from the list 
    foreground_mobjects.

    Parameters
    ----------
    *to_remove : Mobject
        The mobject(s) to remove from the foreground.
    
    Returns
    ------
    Scene
        The Scene, with the foreground mobjects removed.
    &#34;&#34;&#34;
    self.restructure_mobjects(to_remove, &#34;foreground_mobjects&#34;)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.reset_camera"><code class="name flex">
<span>def <span class="ident">reset_camera</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the Camera to its original configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_camera(self):
    &#34;&#34;&#34;
    Resets the Camera to its original configuration.
    &#34;&#34;&#34;
    self.camera.reset()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.restructure_mobjects"><code class="name flex">
<span>def <span class="ident">restructure_mobjects</span></span>(<span>self, to_remove, mobject_list_name='mobjects', extract_families=True)</span>
</code></dt>
<dd>
<div class="desc"><p>tl:wr
If your scene has a Group(), and you removed a mobject from the Group,
this dissolves the group and puts the rest of the mobjects directly
in self.mobjects or self.foreground_mobjects.</p>
<p>In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
will be edited to contain other submobjects, but not m1, e.g. it will now
insert m2 and m3 to where the group once was.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>to_remove</code></strong> :&ensp;<code>Mobject</code></dt>
<dd>The Mobject to remove.</dd>
<dt><strong><code>mobject_list_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The list of mobjects ("mobjects", "foreground_mobjects" etc) to remove from.</dd>
<dt><strong><code>extract_families</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the mobject's families should be recursively extracted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene mobject with restructured Mobjects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restructure_mobjects(self, to_remove,
                         mobject_list_name=&#34;mobjects&#34;,
                         extract_families=True):
    &#34;&#34;&#34;
    tl:wr
        If your scene has a Group(), and you removed a mobject from the Group,
        this dissolves the group and puts the rest of the mobjects directly 
        in self.mobjects or self.foreground_mobjects.
    
    In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
    of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
    will be edited to contain other submobjects, but not m1, e.g. it will now
    insert m2 and m3 to where the group once was.

    Parameters
    ----------
    to_remove : Mobject
        The Mobject to remove.
    
    mobject_list_name : str
        The list of mobjects (&#34;mobjects&#34;, &#34;foreground_mobjects&#34; etc) to remove from.
    
    extract_families : bool
        Whether the mobject&#39;s families should be recursively extracted.
    
    Returns
    -------
    Scene
        The Scene mobject with restructured Mobjects.
    &#34;&#34;&#34;
    if extract_families:
        to_remove = self.camera.extract_mobject_family_members(to_remove)
    _list = getattr(self, mobject_list_name)
    new_list = self.get_restructured_mobject_list(_list, to_remove)
    setattr(self, mobject_list_name, new_list)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.revert_to_original_skipping_status"><code class="name flex">
<span>def <span class="ident">revert_to_original_skipping_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Forces the scene to go back to its original skipping status,
by setting skip_animations to whatever it reads
from original_skipping_status.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></dt>
<dd>The Scene, with the original skipping status.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revert_to_original_skipping_status(self):
    &#34;&#34;&#34;
    Forces the scene to go back to its original skipping status,
    by setting skip_animations to whatever it reads 
    from original_skipping_status.

    Returns
    -------
    Scene
        The Scene, with the original skipping status.
    &#34;&#34;&#34;
    if hasattr(self, &#34;original_skipping_status&#34;):
        self.skip_animations = self.original_skipping_status
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_camera"><code class="name flex">
<span>def <span class="ident">set_camera</span></span>(<span>self, camera)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the scene's camera to be the passed Camera Object.
Parameters</p>
<hr>
<dl>
<dt><strong><code>camera</code></strong> :&ensp;<code>Union[Camera, MappingCamera,MovingCamera,MultiCamera,ThreeDCamera]</code></dt>
<dd>Camera object to use.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_camera(self, camera):
    &#34;&#34;&#34;
    Sets the scene&#39;s camera to be the passed Camera Object.
    Parameters
    ----------
    camera: Union[Camera, MappingCamera,MovingCamera,MultiCamera,ThreeDCamera]
        Camera object to use.
    &#34;&#34;&#34;
    self.camera = camera</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_camera_background"><code class="name flex">
<span>def <span class="ident">set_camera_background</span></span>(<span>self, background)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the camera to display a Pixel Array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>background</code></strong> :&ensp;<code>Union[np.ndarray,list,tuple]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_camera_background(self, background):
    &#34;&#34;&#34;
    Sets the camera to display a Pixel Array
    
    Parameters
    ----------
    background: Union[np.ndarray,list,tuple]
        
    &#34;&#34;&#34;
    self.camera.set_background(background)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_camera_pixel_array"><code class="name flex">
<span>def <span class="ident">set_camera_pixel_array</span></span>(<span>self, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the camera to display a Pixel Array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>Union[np.ndarray,list,tuple]</code></dt>
<dd>Pixel array to set the camera to display</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_camera_pixel_array(self, pixel_array):
    &#34;&#34;&#34;
    Sets the camera to display a Pixel Array
    
    Parameters
    ----------
    pixel_array: Union[np.ndarray,list,tuple]
        Pixel array to set the camera to display
    &#34;&#34;&#34;
    self.camera.set_pixel_array(pixel_array)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_variables_as_attrs"><code class="name flex">
<span>def <span class="ident">set_variables_as_attrs</span></span>(<span>self, *objects, **newly_named_objects)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is slightly hacky, making it a little easier
for certain methods (typically subroutines of construct)
to share local variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variables_as_attrs(self, *objects, **newly_named_objects):
    &#34;&#34;&#34;
    This method is slightly hacky, making it a little easier
    for certain methods (typically subroutines of construct)
    to share local variables.
    &#34;&#34;&#34;
    caller_locals = inspect.currentframe().f_back.f_locals
    for key, value in list(caller_locals.items()):
        for o in objects:
            if value is o:
                setattr(self, key, value)
    for key, value in list(newly_named_objects.items()):
        setattr(self, key, value)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is meant to be implemented by any scenes which
are comonly subclassed, and have some common setup
involved before the construct method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self):
    &#34;&#34;&#34;
    This is meant to be implemented by any scenes which
    are comonly subclassed, and have some common setup
    involved before the construct method is called.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.should_update_mobjects"><code class="name flex">
<span>def <span class="ident">should_update_mobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if any mobject in Scene is being updated
or if the scene has always_update_mobjects set to true.</p>
<h2 id="returns">Returns</h2>
<pre><code>bool
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_update_mobjects(self):
    &#34;&#34;&#34;
    Returns True if any mobject in Scene is being updated
    or if the scene has always_update_mobjects set to true.
    
    Returns
    -------
        bool
    &#34;&#34;&#34;
    return self.always_update_mobjects or any([
        mob.has_time_based_updater()
        for mob in self.get_mobject_family_members()
    ])</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.show_frame"><code class="name flex">
<span>def <span class="ident">show_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens the current frame in the Default Image Viewer
of your system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_frame(self):
    &#34;&#34;&#34;
    Opens the current frame in the Default Image Viewer
    of your system.
    &#34;&#34;&#34;
    self.update_frame(ignore_skipping=True)
    self.get_image().show()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.tear_down"><code class="name flex">
<span>def <span class="ident">tear_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is meant to be implemented by any scenes which
are comonly subclassed, and have some common method
to be invoked before the scene ends.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tear_down(self):
    &#34;&#34;&#34;
    This is meant to be implemented by any scenes which
    are comonly subclassed, and have some common method
    to be invoked before the scene ends.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.update_frame"><code class="name flex">
<span>def <span class="ident">update_frame</span></span>(<span>self, mobjects=None, background=None, include_submobjects=True, ignore_skipping=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters:</h2>
<p>mobjects: list
list of mobjects</p>
<p>background: np.ndarray
Pixel Array for Background</p>
<p>include_submobjects: bool (True)</p>
<p>ignore_skipping : bool (True)</p>
<p>**kwargs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_frame( #TODO Description in Docstring
        self,
        mobjects=None,
        background=None,
        include_submobjects=True,
        ignore_skipping=True,
        **kwargs):
    &#34;&#34;&#34;
    Parameters:
    -----------
    mobjects: list
        list of mobjects
    
    background: np.ndarray
        Pixel Array for Background
    
    include_submobjects: bool (True)
    
    ignore_skipping : bool (True)

    **kwargs

    &#34;&#34;&#34;
    if self.skip_animations and not ignore_skipping:
        return
    if mobjects is None:
        mobjects = list_update(
            self.mobjects,
            self.foreground_mobjects,
        )
    if background is not None:
        self.set_camera_pixel_array(background)
    else:
        self.reset_camera()

    kwargs[&#34;include_submobjects&#34;] = include_submobjects
    self.capture_mobjects_in_camera(mobjects, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.update_mobjects"><code class="name flex">
<span>def <span class="ident">update_mobjects</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>Begins updating all mobjects in the Scene.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>Union[int,float]</code></dt>
<dd>Change in time between updates. Defaults (mostly) to 1/frames_per_second</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_mobjects(self, dt):
    &#34;&#34;&#34;
    Begins updating all mobjects in the Scene.
    
    Parameters
    ----------
    dt: Union[int,float]
        Change in time between updates. Defaults (mostly) to 1/frames_per_second
    &#34;&#34;&#34;
    for mobject in self.mobjects:
        mobject.update(dt)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.update_skipping_status"><code class="name flex">
<span>def <span class="ident">update_skipping_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used internally to check if the current
animation needs to be skipped or not. It also checks if
the number of animations that were played correspond to
the number of animations that need to be played, and
raises an EndSceneEarlyException if they don't correspond.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_skipping_status(self):
    &#34;&#34;&#34;
    This method is used internally to check if the current
    animation needs to be skipped or not. It also checks if
    the number of animations that were played correspond to
    the number of animations that need to be played, and 
    raises an EndSceneEarlyException if they don&#39;t correspond.
    &#34;&#34;&#34;
    
    if self.start_at_animation_number:
        if self.num_plays == self.start_at_animation_number:
            self.skip_animations = False
    if self.end_at_animation_number:
        if self.num_plays &gt;= self.end_at_animation_number:
            self.skip_animations = True
            raise EndSceneEarlyException()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, *args, **kwargs):
    self.update_skipping_status()
    allow_write = not self.skip_animations
    self.file_writer.begin_animation(allow_write)
    func(self, *args, **kwargs)
    self.file_writer.end_animation(allow_write)
    self.num_plays += 1</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.wait_until"><code class="name flex">
<span>def <span class="ident">wait_until</span></span>(<span>self, stop_condition, max_time=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Like a wrapper for wait().
You pass a function that determines whether to continue waiting,
and a max wait time if that is never fulfilled.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stop_condition</code></strong> :&ensp;<code>function definition</code></dt>
<dd>The function whose boolean return value determines whether to continue waiting</dd>
<dt><strong><code>max_time</code></strong> :&ensp;<code>Union[int,float]</code></dt>
<dd>The maximum wait time in seconds, if the stop_condition is never fulfilled.
Defaults to 60.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until(self, stop_condition, max_time=60):
    &#34;&#34;&#34;
    Like a wrapper for wait().
    You pass a function that determines whether to continue waiting,
    and a max wait time if that is never fulfilled.
    
    Parameters
    ----------
    stop_condition: function definition
        The function whose boolean return value determines whether to continue waiting
    
    max_time: Union[int,float]
        The maximum wait time in seconds, if the stop_condition is never fulfilled.
        Defaults to 60.
    &#34;&#34;&#34;
    self.wait(max_time, stop_condition=stop_condition)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.scene" href="index.html">manimlib.scene</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.scene.scene.EndSceneEarlyException" href="#manimlib.scene.scene.EndSceneEarlyException">EndSceneEarlyException</a></code></h4>
</li>
<li>
<h4><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></h4>
<ul class="">
<li><code><a title="manimlib.scene.scene.Scene.CONFIG" href="#manimlib.scene.scene.Scene.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add" href="#manimlib.scene.scene.Scene.add">add</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_foreground_mobject" href="#manimlib.scene.scene.Scene.add_foreground_mobject">add_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_foreground_mobjects" href="#manimlib.scene.scene.Scene.add_foreground_mobjects">add_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_frames" href="#manimlib.scene.scene.Scene.add_frames">add_frames</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_mobjects_among" href="#manimlib.scene.scene.Scene.add_mobjects_among">add_mobjects_among</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_sound" href="#manimlib.scene.scene.Scene.add_sound">add_sound</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.begin_animations" href="#manimlib.scene.scene.Scene.begin_animations">begin_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.bring_to_back" href="#manimlib.scene.scene.Scene.bring_to_back">bring_to_back</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.bring_to_front" href="#manimlib.scene.scene.Scene.bring_to_front">bring_to_front</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.capture_mobjects_in_camera" href="#manimlib.scene.scene.Scene.capture_mobjects_in_camera">capture_mobjects_in_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.clean_up_animations" href="#manimlib.scene.scene.Scene.clean_up_animations">clean_up_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.clear" href="#manimlib.scene.scene.Scene.clear">clear</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.compile_play_args_to_animation_list" href="#manimlib.scene.scene.Scene.compile_play_args_to_animation_list">compile_play_args_to_animation_list</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.construct" href="#manimlib.scene.scene.Scene.construct">construct</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.finish_animations" href="#manimlib.scene.scene.Scene.finish_animations">finish_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.force_skipping" href="#manimlib.scene.scene.Scene.force_skipping">force_skipping</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.freeze_background" href="#manimlib.scene.scene.Scene.freeze_background">freeze_background</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_animation_time_progression" href="#manimlib.scene.scene.Scene.get_animation_time_progression">get_animation_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_attrs" href="#manimlib.scene.scene.Scene.get_attrs">get_attrs</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_frame" href="#manimlib.scene.scene.Scene.get_frame">get_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_image" href="#manimlib.scene.scene.Scene.get_image">get_image</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobject_copies" href="#manimlib.scene.scene.Scene.get_mobject_copies">get_mobject_copies</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobject_family_members" href="#manimlib.scene.scene.Scene.get_mobject_family_members">get_mobject_family_members</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobjects" href="#manimlib.scene.scene.Scene.get_mobjects">get_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobjects_from_last_animation" href="#manimlib.scene.scene.Scene.get_mobjects_from_last_animation">get_mobjects_from_last_animation</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_moving_mobjects" href="#manimlib.scene.scene.Scene.get_moving_mobjects">get_moving_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_restructured_mobject_list" href="#manimlib.scene.scene.Scene.get_restructured_mobject_list">get_restructured_mobject_list</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_run_time" href="#manimlib.scene.scene.Scene.get_run_time">get_run_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_time" href="#manimlib.scene.scene.Scene.get_time">get_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_time_progression" href="#manimlib.scene.scene.Scene.get_time_progression">get_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_top_level_mobjects" href="#manimlib.scene.scene.Scene.get_top_level_mobjects">get_top_level_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_wait_time_progression" href="#manimlib.scene.scene.Scene.get_wait_time_progression">get_wait_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.handle_play_like_call" href="#manimlib.scene.scene.Scene.handle_play_like_call">handle_play_like_call</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.idle_stream" href="#manimlib.scene.scene.Scene.idle_stream">idle_stream</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.increment_time" href="#manimlib.scene.scene.Scene.increment_time">increment_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.play" href="#manimlib.scene.scene.Scene.play">play</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.print_end_message" href="#manimlib.scene.scene.Scene.print_end_message">print_end_message</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.progress_through_animations" href="#manimlib.scene.scene.Scene.progress_through_animations">progress_through_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove" href="#manimlib.scene.scene.Scene.remove">remove</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove_foreground_mobject" href="#manimlib.scene.scene.Scene.remove_foreground_mobject">remove_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove_foreground_mobjects" href="#manimlib.scene.scene.Scene.remove_foreground_mobjects">remove_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.reset_camera" href="#manimlib.scene.scene.Scene.reset_camera">reset_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.restructure_mobjects" href="#manimlib.scene.scene.Scene.restructure_mobjects">restructure_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.revert_to_original_skipping_status" href="#manimlib.scene.scene.Scene.revert_to_original_skipping_status">revert_to_original_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera" href="#manimlib.scene.scene.Scene.set_camera">set_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera_background" href="#manimlib.scene.scene.Scene.set_camera_background">set_camera_background</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera_pixel_array" href="#manimlib.scene.scene.Scene.set_camera_pixel_array">set_camera_pixel_array</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_variables_as_attrs" href="#manimlib.scene.scene.Scene.set_variables_as_attrs">set_variables_as_attrs</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.setup" href="#manimlib.scene.scene.Scene.setup">setup</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.should_update_mobjects" href="#manimlib.scene.scene.Scene.should_update_mobjects">should_update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.show_frame" href="#manimlib.scene.scene.Scene.show_frame">show_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.tear_down" href="#manimlib.scene.scene.Scene.tear_down">tear_down</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_frame" href="#manimlib.scene.scene.Scene.update_frame">update_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_mobjects" href="#manimlib.scene.scene.Scene.update_mobjects">update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_skipping_status" href="#manimlib.scene.scene.Scene.update_skipping_status">update_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.wait" href="#manimlib.scene.scene.Scene.wait">wait</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.wait_until" href="#manimlib.scene.scene.Scene.wait_until">wait_until</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>