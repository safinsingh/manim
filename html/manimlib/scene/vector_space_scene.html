<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.scene.vector_space_scene API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.scene.vector_space_scene</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

from manimlib.animation.animation import Animation
from manimlib.animation.creation import ShowCreation
from manimlib.animation.creation import Write
from manimlib.animation.fading import FadeOut
from manimlib.animation.growing import GrowArrow
from manimlib.animation.transform import ApplyFunction
from manimlib.animation.transform import ApplyPointwiseFunction
from manimlib.animation.transform import Transform
from manimlib.constants import *
from manimlib.mobject.coordinate_systems import Axes
from manimlib.mobject.coordinate_systems import NumberPlane
from manimlib.mobject.geometry import Arrow
from manimlib.mobject.geometry import Dot
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.geometry import Vector
from manimlib.mobject.matrix import Matrix
from manimlib.mobject.matrix import VECTOR_LABEL_SCALE_FACTOR
from manimlib.mobject.matrix import vector_coordinate_label
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.svg.tex_mobject import TexMobject
from manimlib.mobject.svg.tex_mobject import TextMobject
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.scene.scene import Scene
from manimlib.utils.rate_functions import rush_from
from manimlib.utils.rate_functions import rush_into
from manimlib.utils.space_ops import angle_of_vector
from manimlib.utils.space_ops import get_norm

X_COLOR = GREEN_C
Y_COLOR = RED_C
Z_COLOR = BLUE_D


# TODO: Much of this scene type seems dependent on the coordinate system chosen.
# That is, being centered at the origin with grid units corresponding to the
# arbitrary space units.  Change it!
#
# Also, methods I would have thought of as getters, like coords_to_vector, are
# actually doing a lot of animating.
class VectorScene(Scene):
    CONFIG = {
        &#34;basis_vector_stroke_width&#34;: 6
    }

    def add_plane(self, animate=False, **kwargs):
        &#34;&#34;&#34;
        Adds a NumberPlane object to the background.

        Parameters
        ----------
        animate : (bool=False)
            Whether or not to animate the addition of the plane via ShowCreation.
        **kwargs
            Any valid keyword arguments accepted by NumberPlane.
        
        Returns
        -------
        NumberPlane
            The NumberPlane object.
        &#34;&#34;&#34;
        plane = NumberPlane(**kwargs)
        if animate:
            self.play(ShowCreation(plane, lag_ratio=0.5))
        self.add(plane)
        return plane

    def add_axes(self, animate=False, color=WHITE, **kwargs):
        &#34;&#34;&#34;
        Adds a pair of Axes to the Scene.

        Parameters
        ----------
        animate (bool=False)
            Whether or not to animate the addition of the axes through ShowCreation.
        color (str)
            The color of the axes. Defaults to WHITE.
        &#34;&#34;&#34;
        axes = Axes(color=color, tick_frequency=1)
        if animate:
            self.play(ShowCreation(axes))
        self.add(axes)
        return axes

    def lock_in_faded_grid(self, dimness=0.7, axes_dimness=0.5):
        &#34;&#34;&#34;
        This method freezes the NumberPlane and Axes that were already
        in the background, and adds new, manipulatable ones to the foreground.
        
        Parameters
        ----------
        dimness (Union[int,float=0.7])
            The required dimness of the NumberPlane
        
        axes_dimness (Union[int,float=0.5])
            The required dimness of the Axes.
        &#34;&#34;&#34;
        plane = self.add_plane()
        axes = plane.get_axes()
        plane.fade(dimness)
        axes.set_color(WHITE)
        axes.fade(axes_dimness)
        self.add(axes)
        self.freeze_background()

    def get_vector(self, numerical_vector, **kwargs):
        &#34;&#34;&#34;
        Returns an arrow on the Plane given an input numerical vector.
        
        Parameters
        ----------
        numerical_vector : Union(np.ndarray, list, tuple)
            The Vector to plot.
        **kwargs
            Any valid keyword argument of Arrow.
        
        Returns
        -------
        Arrow
            The Arrow representing the Vector.
        &#34;&#34;&#34;
        return Arrow(
            self.plane.coords_to_point(0, 0),
            self.plane.coords_to_point(*numerical_vector[:2]),
            buff=0,
            **kwargs
        )

    def add_vector(self, vector, color=YELLOW, animate=True, **kwargs):
        &#34;&#34;&#34;
        Returns the Vector after adding it to the Plane.

        Parameters
        ----------
        vector Union(Arrow,list,tuple,np.ndarray)
            It can be a pre-made graphical vector, or the
            coordinates of one.
        
        color (str)
            The string of the hex color of the vector.
            This is only taken into consideration if
            &#39;vector&#39; is not an Arrow. Defaults to YELLOW.
        
        animate (bool=True)
            Whether or not to animate the addition of the vector
            by using GrowArrow
        
        **kwargs
            Any valid keyword argument of Arrow.
            These are only considered if vector is not
            an Arrow.
        
        Returns
        -------
        Arrow
            The arrow representing the vector.
        &#34;&#34;&#34;
        if not isinstance(vector, Arrow):
            vector = Vector(vector, color=color, **kwargs)
        if animate:
            self.play(GrowArrow(vector))
        self.add(vector)
        return vector

    def write_vector_coordinates(self, vector, **kwargs):
        &#34;&#34;&#34;
        Returns a column matrix indicating the vector coordinates,
        after writing them to the screen.

        Parameters
        ----------
        vector (Arrow)
            The arrow representing the vector.
        
        **kwargs
            Any valid keyword arguments of matrix.vector_coordinate_label
            
            integer_labels (True) : Whether or not to round the coordinates
                                    to integers.
            n_dim (2) : The number of dimensions of the vector.
            color (WHITE) : The color of the label.

        Returns
        -------
        Matrix
            The column matrix representing the vector.
        &#34;&#34;&#34;
        coords = vector_coordinate_label(vector, **kwargs)
        self.play(Write(coords))
        return coords

    def get_basis_vectors(self, i_hat_color=X_COLOR, j_hat_color=Y_COLOR):
        &#34;&#34;&#34;
        Returns a VGroup of the Basis Vectors (1,0) and (0,1)

        Parameters
        ----------
        i_hat_color (str)
            The hex colour to use for the basis vector in the x direction
        
        j_hat_color (str)
            The hex colour to use for the basis vector in the y direction
        
        Returns
        -------
        VGroup
            VGroup of the Vector Mobjects representing the basis vectors.
        &#34;&#34;&#34;
        return VGroup(*[
            Vector(
                vect,
                color=color,
                stroke_width=self.basis_vector_stroke_width
            )
            for vect, color in [
                ([1, 0], i_hat_color),
                ([0, 1], j_hat_color)
            ]
        ])

    def get_basis_vector_labels(self, **kwargs):
        &#34;&#34;&#34;
        Returns naming labels for the basis vectors.

        Parameters
        ----------
        **kwargs
            Any valid keyword arguments of get_vector_label:
                vector,
                label (str,TexMobject)
                at_tip (bool=False),
                direction (str=&#34;left&#34;),
                rotate (bool),
                color (str),
                label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),
        &#34;&#34;&#34;
        i_hat, j_hat = self.get_basis_vectors()
        return VGroup(*[
            self.get_vector_label(
                vect, label, color=color,
                label_scale_factor=1,
                **kwargs
            )
            for vect, label, color in [
                (i_hat, &#34;\\hat{\\imath}&#34;, X_COLOR),
                (j_hat, &#34;\\hat{\\jmath}&#34;, Y_COLOR),
            ]
        ])

    def get_vector_label(self, vector, label,
                         at_tip=False,
                         direction=&#34;left&#34;,
                         rotate=False,
                         color=None,
                         label_scale_factor=VECTOR_LABEL_SCALE_FACTOR):
        &#34;&#34;&#34;
        Returns naming labels for the passed vector.

        Parameters
        ----------
        vector
            Vector Object for which to get the label.
        at_tip (bool)
            Whether or not to place the label at the tip of the vector.
        direction (str=&#34;left&#34;)
            If the label should be on the &#34;left&#34; or right of the vector.
        rotate (bool=False)
            Whether or not to rotate it to align it with the vector.
        color (str)
            The color to give the label.
        label_scale_factor (Union[int,float])
            How much to scale the label by.
        
        Returns
        -------
        TexMobject
            The TexMobject of the label.
        &#34;&#34;&#34;
        if not isinstance(label, TexMobject):
            if len(label) == 1:
                label = &#34;\\vec{\\textbf{%s}}&#34; % label
            label = TexMobject(label)
            if color is None:
                color = vector.get_color()
            label.set_color(color)
        label.scale(label_scale_factor)
        label.add_background_rectangle()

        if at_tip:
            vect = vector.get_vector()
            vect /= get_norm(vect)
            label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)
        else:
            angle = vector.get_angle()
            if not rotate:
                label.rotate(-angle, about_point=ORIGIN)
            if direction == &#34;left&#34;:
                label.shift(-label.get_bottom() + 0.1 * UP)
            else:
                label.shift(-label.get_top() + 0.1 * DOWN)
            label.rotate(angle, about_point=ORIGIN)
            label.shift((vector.get_end() - vector.get_start()) / 2)
        return label

    def label_vector(self, vector, label, animate=True, **kwargs):
        &#34;&#34;&#34;
        Shortcut method for creating, and animating the addition of
        a label for the vector.

        Parameters
        ----------
        vector (Vector)
            The vector for which the label must be added.
        label (TexMobject,str)
            The TexMobject/string of the label.
        animate (bool=True)
            Whether or not to animate the labelling w/ Write
        **kwargs
            Any valid keyword argument of get_vector_label
        
        Returns
        -------
        TexMobject
            The TexMobject of the label.
        &#34;&#34;&#34;
        label = self.get_vector_label(vector, label, **kwargs)
        if animate:
            self.play(Write(label, run_time=1))
        self.add(label)
        return label

    def position_x_coordinate(self, x_coord, x_line, vector): #TODO Write DocStrings for this.
        x_coord.next_to(x_line, -np.sign(vector[1]) * UP)
        x_coord.set_color(X_COLOR)
        return x_coord

    def position_y_coordinate(self, y_coord, y_line, vector): #TODO Write DocStrings for this.
        y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)
        y_coord.set_color(Y_COLOR)
        return y_coord

    def coords_to_vector(self, vector, coords_start=2 * RIGHT + 2 * UP, clean_up=True):
        &#34;&#34;&#34;
        This method writes the vector as a column matrix (henceforth called the label),
        takes the values in it one by one, and form the corresponding
        lines that make up the x and y components of the vector. Then, an
        Vector() based vector is created between the lines on the Screen.

        Parameters
        ----------
        vector Union(np.ndarray, list, tuple)
            The vector to show.
        
        coords_start Union(np.ndarray,list,tuple)
            The starting point of the location of 
            the label of the vector that shows it 
            numerically.
            Defaults to 2 * RIGHT + 2 * UP or (2,2)
        
        clean_up (bool=True)
            Whether or not to remove whatever
            this method did after it&#39;s done.

        &#34;&#34;&#34;
        starting_mobjects = list(self.mobjects)
        array = Matrix(vector)
        array.shift(coords_start)
        arrow = Vector(vector)
        x_line = Line(ORIGIN, vector[0] * RIGHT)
        y_line = Line(x_line.get_end(), arrow.get_end())
        x_line.set_color(X_COLOR)
        y_line.set_color(Y_COLOR)
        x_coord, y_coord = array.get_mob_matrix().flatten()

        self.play(Write(array, run_time=1))
        self.wait()
        self.play(ApplyFunction(
            lambda x: self.position_x_coordinate(x, x_line, vector),
            x_coord
        ))
        self.play(ShowCreation(x_line))
        self.play(
            ApplyFunction(
                lambda y: self.position_y_coordinate(y, y_line, vector),
                y_coord
            ),
            FadeOut(array.get_brackets())
        )
        y_coord, brackets = self.get_mobjects_from_last_animation()
        self.play(ShowCreation(y_line))
        self.play(ShowCreation(arrow))
        self.wait()
        if clean_up:
            self.clear()
            self.add(*starting_mobjects)

    def vector_to_coords(self, vector, integer_labels=True, clean_up=True):
        &#34;&#34;&#34;
        This method displays vector as a Vector() based vector, and then shows 
        the corresponding lines that make up the x and y components of the vector. 
        Then, a column matrix (henceforth called the label) is created near the 
        head of the Vector.

        Parameters
        ----------
        vector Union(np.ndarray, list, tuple)
            The vector to show.
        
        integer_label (bool=True)
            Whether or not to round the value displayed.
            in the vector&#39;s label to the nearest integer
        
        clean_up (bool=True)
            Whether or not to remove whatever
            this method did after it&#39;s done.

        &#34;&#34;&#34;
        starting_mobjects = list(self.mobjects)
        show_creation = False
        if isinstance(vector, Arrow):
            arrow = vector
            vector = arrow.get_end()[:2]
        else:
            arrow = Vector(vector)
            show_creation = True
        array = vector_coordinate_label(arrow, integer_labels=integer_labels)
        x_line = Line(ORIGIN, vector[0] * RIGHT)
        y_line = Line(x_line.get_end(), arrow.get_end())
        x_line.set_color(X_COLOR)
        y_line.set_color(Y_COLOR)
        x_coord, y_coord = array.get_mob_matrix().flatten()
        x_coord_start = self.position_x_coordinate(
            x_coord.copy(), x_line, vector
        )
        y_coord_start = self.position_y_coordinate(
            y_coord.copy(), y_line, vector
        )
        brackets = array.get_brackets()

        if show_creation:
            self.play(ShowCreation(arrow))
        self.play(
            ShowCreation(x_line),
            Write(x_coord_start),
            run_time=1
        )
        self.play(
            ShowCreation(y_line),
            Write(y_coord_start),
            run_time=1
        )
        self.wait()
        self.play(
            Transform(x_coord_start, x_coord, lag_ratio=0),
            Transform(y_coord_start, y_coord, lag_ratio=0),
            Write(brackets, run_time=1),
        )
        self.wait()

        self.remove(x_coord_start, y_coord_start, brackets)
        self.add(array)
        if clean_up:
            self.clear()
            self.add(*starting_mobjects)
        return array, x_line, y_line

    def show_ghost_movement(self, vector):
        &#34;&#34;&#34;
        This method plays an animation that partially shows the entire plane moving
        in the direction of a particular vector. This is useful when you wish to 
        convey the idea of mentally moving the entire plane in a direction, without
        actually moving the plane.

        Parameters
        ----------
        vector (Union[Arrow, list, tuple, np.ndarray])
            The vector which indicates the direction of movement.
        &#34;&#34;&#34;
        if isinstance(vector, Arrow):
            vector = vector.get_end() - vector.get_start()
        elif len(vector) == 2:
            vector = np.append(np.array(vector), 0.0)
        x_max = int(FRAME_X_RADIUS + abs(vector[0]))
        y_max = int(FRAME_Y_RADIUS + abs(vector[1]))
        dots = VMobject(*[
            Dot(x * RIGHT + y * UP)
            for x in range(-x_max, x_max)
            for y in range(-y_max, y_max)
        ])
        dots.set_fill(BLACK, opacity=0)
        dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)
        dots_end = dots.copy().shift(vector)

        self.play(Transform(
            dots, dots_halfway, rate_func=rush_into
        ))
        self.play(Transform(
            dots, dots_end, rate_func=rush_from
        ))
        self.remove(dots)


class LinearTransformationScene(VectorScene):
    &#34;&#34;&#34;
    This scene contains special methods that make it
    especially suitable for showing Linear Transformations.
    &#34;&#34;&#34;
    CONFIG = {
        &#34;include_background_plane&#34;: True,
        &#34;include_foreground_plane&#34;: True,
        &#34;foreground_plane_kwargs&#34;: {
            &#34;x_max&#34;: FRAME_WIDTH / 2,
            &#34;x_min&#34;: -FRAME_WIDTH / 2,
            &#34;y_max&#34;: FRAME_WIDTH / 2,
            &#34;y_min&#34;: -FRAME_WIDTH / 2,
            &#34;faded_line_ratio&#34;: 0
        },
        &#34;background_plane_kwargs&#34;: {
            &#34;color&#34;: GREY,
            &#34;axis_config&#34;: {
                &#34;stroke_color&#34;: LIGHT_GREY,
            },
            &#34;axis_config&#34;: {
                &#34;color&#34;: GREY,
            },
            &#34;background_line_style&#34;: {
                &#34;stroke_color&#34;: GREY,
                &#34;stroke_width&#34;: 1,
            },
        },
        &#34;show_coordinates&#34;: False,
        &#34;show_basis_vectors&#34;: True,
        &#34;basis_vector_stroke_width&#34;: 6,
        &#34;i_hat_color&#34;: X_COLOR,
        &#34;j_hat_color&#34;: Y_COLOR,
        &#34;leave_ghost_vectors&#34;: False,
        &#34;t_matrix&#34;: [[3, 0], [1, 2]],
    }

    def setup(self):
        # The has_already_setup attr is to not break all the old Scenes
        if hasattr(self, &#34;has_already_setup&#34;):
            return
        self.has_already_setup = True
        self.background_mobjects = []
        self.foreground_mobjects = []
        self.transformable_mobjects = []
        self.moving_vectors = []
        self.transformable_labels = []
        self.moving_mobjects = []

        self.t_matrix = np.array(self.t_matrix)
        self.background_plane = NumberPlane(
            **self.background_plane_kwargs
        )

        if self.show_coordinates:
            self.background_plane.add_coordinates()
        if self.include_background_plane:
            self.add_background_mobject(self.background_plane)
        if self.include_foreground_plane:
            self.plane = NumberPlane(**self.foreground_plane_kwargs)
            self.add_transformable_mobject(self.plane)
        if self.show_basis_vectors:
            self.basis_vectors = self.get_basis_vectors(
                i_hat_color=self.i_hat_color,
                j_hat_color=self.j_hat_color,
            )
            self.moving_vectors += list(self.basis_vectors)
            self.i_hat, self.j_hat = self.basis_vectors
            self.add(self.basis_vectors)

    def add_special_mobjects(self, mob_list, *mobs_to_add):
        &#34;&#34;&#34;
        Adds mobjects to a separate list that can be tracked,
        if these mobjects have some extra importance.

        Parameters
        ----------
        mob_list (list)
            The special list to which you want to add
            these mobjects.
        
        *mobs_to_add (Mobject)
            The mobjects to add.

        &#34;&#34;&#34;
        for mobject in mobs_to_add:
            if mobject not in mob_list:
                mob_list.append(mobject)
                self.add(mobject)

    def add_background_mobject(self, *mobjects):
        &#34;&#34;&#34;
        Adds the mobjects to the special list
        self.background_mobjects.

        Parameters
        ----------
        *mobjects (Mobject)
            The mobjects to add to the list.
        &#34;&#34;&#34;
        self.add_special_mobjects(self.background_mobjects, *mobjects)

    # TODO, this conflicts with Scene.add_fore
    def add_foreground_mobject(self, *mobjects):
        &#34;&#34;&#34;
        Adds the mobjects to the special list
        self.foreground_mobjects.

        Parameters
        ----------
        *mobjects (Mobject)
            The mobjects to add to the list
        &#34;&#34;&#34;
        self.add_special_mobjects(self.foreground_mobjects, *mobjects)

    def add_transformable_mobject(self, *mobjects):
        &#34;&#34;&#34;
        Adds the mobjects to the special list
        self.transformable_mobjects.

        Parameters
        ----------
        *mobjects (Mobject)
            The mobjects to add to the list.
        &#34;&#34;&#34;
        self.add_special_mobjects(self.transformable_mobjects, *mobjects)

    def add_moving_mobject(self, mobject, target_mobject=None):
        &#34;&#34;&#34;
        Adds the mobject to the special list
        self.moving_mobject, and adds a property
        to the mobject called mobject.target, which
        keeps track of what the mobject will move to
        or become etc.

        Parameters
        ----------
        mobject (Mobject)
            The mobjects to add to the list
        
        target_mobject (Mobject)
            What the moving_mobject goes to, etc.
        &#34;&#34;&#34;
        mobject.target = target_mobject
        self.add_special_mobjects(self.moving_mobjects, mobject)

    def get_unit_square(self, color=YELLOW, opacity=0.3, stroke_width=3):
        &#34;&#34;&#34;
        Returns a unit square for the current NumberPlane.
        &#34;&#34;&#34;
        square = self.square = Rectangle(
            color=color,
            width=self.plane.get_x_unit_size(),
            height=self.plane.get_y_unit_size(),
            stroke_color=color,
            stroke_width=stroke_width,
            fill_color=color,
            fill_opacity=opacity
        )
        square.move_to(self.plane.coords_to_point(0, 0), DL)
        return square

    def add_unit_square(self, animate=False, **kwargs):
        &#34;&#34;&#34;
        Adds a unit square to the scene via
        self.get_unit_square.

        Parameters
        ----------
        animate (bool)
            Whether or not to animate the addition
            with DrawBorderThenFill.
        **kwargs
            Any valid keyword arguments of
            self.get_unit_square()
        
        Returns
        -------
        Square
            The unit square.
        &#34;&#34;&#34;
        square = self.get_unit_square(**kwargs)
        if animate:
            self.play(
                DrawBorderThenFill(square),
                Animation(Group(*self.moving_vectors))
            )
        self.add_transformable_mobject(square)
        self.bring_to_front(*self.moving_vectors)
        self.square = square
        return self

    def add_vector(self, vector, color=YELLOW, **kwargs):
        &#34;&#34;&#34;
        Adds a vector to the scene, and puts it in the special
        list self.moving_vectors.

        Parameters
        ----------
        vector Union(Arrow,list,tuple,np.ndarray)
            It can be a pre-made graphical vector, or the
            coordinates of one.
        
        color (str)
            The string of the hex color of the vector.
            This is only taken into consideration if
            &#39;vector&#39; is not an Arrow. Defaults to YELLOW.
        
        **kwargs
            Any valid keyword argument of VectorScene.add_vector.
        
        Returns
        -------
        Arrow
            The arrow representing the vector.
        &#34;&#34;&#34;
        vector = VectorScene.add_vector(
            self, vector, color=color, **kwargs
        )
        self.moving_vectors.append(vector)
        return vector

    def write_vector_coordinates(self, vector, **kwargs):
        &#34;&#34;&#34;
        Returns a column matrix indicating the vector coordinates,
        after writing them to the screen, and adding them to the
        special list self.foreground_mobjects

        Parameters
        ----------
        vector (Arrow)
            The arrow representing the vector.
        
        **kwargs
            Any valid keyword arguments of VectorScene.write_vector_coordinates

        Returns
        -------
        Matrix
            The column matrix representing the vector.
        &#34;&#34;&#34;
        coords = VectorScene.write_vector_coordinates(self, vector, **kwargs)
        self.add_foreground_mobject(coords)
        return coords

    def add_transformable_label(
            self, vector, label,
            transformation_name=&#34;L&#34;,
            new_label=None,
            **kwargs):
        &#34;&#34;&#34;
        Method for creating, and animating the addition of
        a transformable label for the vector.

        Parameters
        ----------
        vector (Vector)
            The vector for which the label must be added.
        label (TexMobject,str)
            The TexMobject/string of the label.
        new_label (TexMobject,str,None)
            What the label should display after a Linear Transformation
        **kwargs
            Any valid keyword argument of get_vector_label

        Returns
        -------
        TexMobject
            The TexMobject of the label.
        &#34;&#34;&#34;
        label_mob = self.label_vector(vector, label, **kwargs)
        if new_label:
            label_mob.target_text = new_label
        else:
            label_mob.target_text = &#34;%s(%s)&#34; % (
                transformation_name,
                label_mob.get_tex_string()
            )
        label_mob.vector = vector
        label_mob.kwargs = kwargs
        if &#34;animate&#34; in label_mob.kwargs:
            label_mob.kwargs.pop(&#34;animate&#34;)
        self.transformable_labels.append(label_mob)
        return label_mob

    def add_title(self, title, scale_factor=1.5, animate=False):
        &#34;&#34;&#34;
        Adds a title, after scaling it, adding a background rectangle,
        moving it to the top and adding it to foreground_mobjects adding
        it as a local variable of self. Returns the Scene.

        Parameters
        ----------
        title (str,TexMobject,TextMobject)
            What the title should be.
        
        scale_factor (int,float=1.5)
            How much the title should be scaled by.
        
        animate (bool=False)
            Whether or not to animate the addition.
        
        Returns
        -------
        LinearTransformationScene
            The scene with the title added to it.
        &#34;&#34;&#34;
        if not isinstance(title, Mobject):
            title = TextMobject(title).scale(scale_factor)
        title.to_edge(UP)
        title.add_background_rectangle()
        if animate:
            self.play(Write(title))
        self.add_foreground_mobject(title)
        self.title = title
        return self

    def get_matrix_transformation(self, matrix):
        &#34;&#34;&#34;
        Returns a function corresponding to the linear
        transformation represented by the matrix passed.

        Parameters
        ----------
        matrix (np.ndarray, list, tuple)
            The matrix.
        &#34;&#34;&#34;
        return self.get_transposed_matrix_transformation(np.array(matrix).T)

    def get_transposed_matrix_transformation(self, transposed_matrix):
        &#34;&#34;&#34;
        Returns a function corresponding to the linear
        transformation represented by the transposed 
        matrix passed.

        Parameters
        ----------
        matrix (np.ndarray, list, tuple)
            The matrix.
        &#34;&#34;&#34;
        transposed_matrix = np.array(transposed_matrix)
        if transposed_matrix.shape == (2, 2):
            new_matrix = np.identity(3)
            new_matrix[:2, :2] = transposed_matrix
            transposed_matrix = new_matrix
        elif transposed_matrix.shape != (3, 3):
            raise Exception(&#34;Matrix has bad dimensions&#34;)
        return lambda point: np.dot(point, transposed_matrix)

    def get_piece_movement(self, pieces):
        &#34;&#34;&#34;
        This method returns an animation that moves an arbitrary 
        mobject in &#34;pieces&#34; to its corresponding .target value.
        If self.leave_ghost_vectors is True, ghosts of the original
        positions/mobjects are left on screen

        Parameters
        ----------
        pieces (Union[list, tuple, np.array])
            The pieces for which the movement must be shown.
        
        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        start = VGroup(*pieces)
        target = VGroup(*[mob.target for mob in pieces])
        if self.leave_ghost_vectors:
            self.add(start.copy().fade(0.7))
        return Transform(start, target, lag_ratio=0)

    def get_moving_mobject_movement(self, func):
        &#34;&#34;&#34;
        This method returns an animation that moves a mobject
        in &#34;self.moving_mobjects&#34;  to its corresponding .target value.
        func is a function that determines where the .target goes.

        Parameters
        ----------

        func (function)
            The function that determines where the .target of
            the moving mobject goes.
        
        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        for m in self.moving_mobjects:
            if m.target is None:
                m.target = m.copy()
            target_point = func(m.get_center())
            m.target.move_to(target_point)
        return self.get_piece_movement(self.moving_mobjects)

    def get_vector_movement(self, func):
        &#34;&#34;&#34;
        This method returns an animation that moves a mobject
        in &#34;self.moving_vectors&#34;  to its corresponding .target value.
        func is a function that determines where the .target goes.

        Parameters
        ----------

        func (function)
            The function that determines where the .target of
            the moving mobject goes.
        
        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        for v in self.moving_vectors:
            v.target = Vector(func(v.get_end()), color=v.get_color())
            norm = get_norm(v.target.get_end())
            if norm &lt; 0.1:
                v.target.get_tip().scale_in_place(norm)
        return self.get_piece_movement(self.moving_vectors)

    def get_transformable_label_movement(self):
        &#34;&#34;&#34;
        This method returns an animation that moves all labels
        in &#34;self.transformable_labels&#34; to its corresponding .target .

        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        for l in self.transformable_labels:
            l.target = self.get_vector_label(
                l.vector.target, l.target_text, **l.kwargs
            )
        return self.get_piece_movement(self.transformable_labels)

    def apply_matrix(self, matrix, **kwargs):
        &#34;&#34;&#34;
        Applies the transformation represented by the
        given matrix to the number plane, and each vector/similar
        mobject on it.

        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix.
        **kwargs
            Any valid keyword argument of self.apply_transposed_matrix()
        &#34;&#34;&#34;
        self.apply_transposed_matrix(np.array(matrix).T, **kwargs)

    def apply_inverse(self, matrix, **kwargs):
        &#34;&#34;&#34;
        This method applies the linear transformation
        represented by the inverse of the passed matrix
        to the number plane, and each vector/similar mobject on it.
        
        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix whose inverse is to be applied.
        **kwargs
            Any valid keyword argument of self.apply_matrix()
        &#34;&#34;&#34;
        self.apply_matrix(np.linalg.inv(matrix), **kwargs)

    def apply_transposed_matrix(self, transposed_matrix, **kwargs):
        &#34;&#34;&#34;
        Applies the transformation represented by the
        given transposed matrix to the number plane,
        and each vector/similar mobject on it.

        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix.
        **kwargs
            Any valid keyword argument of self.apply_function()
        &#34;&#34;&#34;
        func = self.get_transposed_matrix_transformation(transposed_matrix)
        if &#34;path_arc&#34; not in kwargs:
            net_rotation = np.mean([
                angle_of_vector(func(RIGHT)),
                angle_of_vector(func(UP)) - np.pi / 2
            ])
            kwargs[&#34;path_arc&#34;] = net_rotation
        self.apply_function(func, **kwargs)

    def apply_inverse_transpose(self, t_matrix, **kwargs):
        &#34;&#34;&#34;
        Applies the inverse of the transformation represented
        by the given transposed matrix to the number plane and each 
        vector/similar mobject on it.

        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix.
        **kwargs
            Any valid keyword argument of self.apply_transposed_matrix()
        &#34;&#34;&#34;
        t_inv = np.linalg.inv(np.array(t_matrix).T).T
        self.apply_transposed_matrix(t_inv, **kwargs)

    def apply_nonlinear_transformation(self, function, **kwargs):
        &#34;&#34;&#34;
        Applies the non-linear transformation represented
        by the given function to the number plane and each
        vector/similar mobject on it.

        Parameters
        ----------
        function (Function)
            The function.
        **kwargs
            Any valid keyword argument of self.apply_function()
        &#34;&#34;&#34;
        self.plane.prepare_for_nonlinear_transform()
        self.apply_function(function, **kwargs)

    def apply_function(self, function, added_anims=[], **kwargs):
        &#34;&#34;&#34;
        Applies the given function to each of the mobjects in
        self.transformable_mobjects, and plays the animation showing
        this.

        Parameters
        ----------
        function (Function)
            The function that affects each point
            of each mobject in self.transformable_mobjects.
        
        added_anims (list)
            Any other animations that need to be played
            simulataneously with this.
        
        **kwargs
            Any valid keyword argument of a self.play() call.
        &#34;&#34;&#34;
        if &#34;run_time&#34; not in kwargs:
            kwargs[&#34;run_time&#34;] = 3
        anims = [
            ApplyPointwiseFunction(function, t_mob)
            for t_mob in self.transformable_mobjects
        ] + [
            self.get_vector_movement(function),
            self.get_transformable_label_movement(),
            self.get_moving_mobject_movement(function),
        ] + [
            Animation(f_mob)
            for f_mob in self.foreground_mobjects
        ] + added_anims
        self.play(*anims, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene"><code class="flex name class">
<span>class <span class="ident">LinearTransformationScene</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This scene contains special methods that make it
especially suitable for showing Linear Transformations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearTransformationScene(VectorScene):
    &#34;&#34;&#34;
    This scene contains special methods that make it
    especially suitable for showing Linear Transformations.
    &#34;&#34;&#34;
    CONFIG = {
        &#34;include_background_plane&#34;: True,
        &#34;include_foreground_plane&#34;: True,
        &#34;foreground_plane_kwargs&#34;: {
            &#34;x_max&#34;: FRAME_WIDTH / 2,
            &#34;x_min&#34;: -FRAME_WIDTH / 2,
            &#34;y_max&#34;: FRAME_WIDTH / 2,
            &#34;y_min&#34;: -FRAME_WIDTH / 2,
            &#34;faded_line_ratio&#34;: 0
        },
        &#34;background_plane_kwargs&#34;: {
            &#34;color&#34;: GREY,
            &#34;axis_config&#34;: {
                &#34;stroke_color&#34;: LIGHT_GREY,
            },
            &#34;axis_config&#34;: {
                &#34;color&#34;: GREY,
            },
            &#34;background_line_style&#34;: {
                &#34;stroke_color&#34;: GREY,
                &#34;stroke_width&#34;: 1,
            },
        },
        &#34;show_coordinates&#34;: False,
        &#34;show_basis_vectors&#34;: True,
        &#34;basis_vector_stroke_width&#34;: 6,
        &#34;i_hat_color&#34;: X_COLOR,
        &#34;j_hat_color&#34;: Y_COLOR,
        &#34;leave_ghost_vectors&#34;: False,
        &#34;t_matrix&#34;: [[3, 0], [1, 2]],
    }

    def setup(self):
        # The has_already_setup attr is to not break all the old Scenes
        if hasattr(self, &#34;has_already_setup&#34;):
            return
        self.has_already_setup = True
        self.background_mobjects = []
        self.foreground_mobjects = []
        self.transformable_mobjects = []
        self.moving_vectors = []
        self.transformable_labels = []
        self.moving_mobjects = []

        self.t_matrix = np.array(self.t_matrix)
        self.background_plane = NumberPlane(
            **self.background_plane_kwargs
        )

        if self.show_coordinates:
            self.background_plane.add_coordinates()
        if self.include_background_plane:
            self.add_background_mobject(self.background_plane)
        if self.include_foreground_plane:
            self.plane = NumberPlane(**self.foreground_plane_kwargs)
            self.add_transformable_mobject(self.plane)
        if self.show_basis_vectors:
            self.basis_vectors = self.get_basis_vectors(
                i_hat_color=self.i_hat_color,
                j_hat_color=self.j_hat_color,
            )
            self.moving_vectors += list(self.basis_vectors)
            self.i_hat, self.j_hat = self.basis_vectors
            self.add(self.basis_vectors)

    def add_special_mobjects(self, mob_list, *mobs_to_add):
        &#34;&#34;&#34;
        Adds mobjects to a separate list that can be tracked,
        if these mobjects have some extra importance.

        Parameters
        ----------
        mob_list (list)
            The special list to which you want to add
            these mobjects.
        
        *mobs_to_add (Mobject)
            The mobjects to add.

        &#34;&#34;&#34;
        for mobject in mobs_to_add:
            if mobject not in mob_list:
                mob_list.append(mobject)
                self.add(mobject)

    def add_background_mobject(self, *mobjects):
        &#34;&#34;&#34;
        Adds the mobjects to the special list
        self.background_mobjects.

        Parameters
        ----------
        *mobjects (Mobject)
            The mobjects to add to the list.
        &#34;&#34;&#34;
        self.add_special_mobjects(self.background_mobjects, *mobjects)

    # TODO, this conflicts with Scene.add_fore
    def add_foreground_mobject(self, *mobjects):
        &#34;&#34;&#34;
        Adds the mobjects to the special list
        self.foreground_mobjects.

        Parameters
        ----------
        *mobjects (Mobject)
            The mobjects to add to the list
        &#34;&#34;&#34;
        self.add_special_mobjects(self.foreground_mobjects, *mobjects)

    def add_transformable_mobject(self, *mobjects):
        &#34;&#34;&#34;
        Adds the mobjects to the special list
        self.transformable_mobjects.

        Parameters
        ----------
        *mobjects (Mobject)
            The mobjects to add to the list.
        &#34;&#34;&#34;
        self.add_special_mobjects(self.transformable_mobjects, *mobjects)

    def add_moving_mobject(self, mobject, target_mobject=None):
        &#34;&#34;&#34;
        Adds the mobject to the special list
        self.moving_mobject, and adds a property
        to the mobject called mobject.target, which
        keeps track of what the mobject will move to
        or become etc.

        Parameters
        ----------
        mobject (Mobject)
            The mobjects to add to the list
        
        target_mobject (Mobject)
            What the moving_mobject goes to, etc.
        &#34;&#34;&#34;
        mobject.target = target_mobject
        self.add_special_mobjects(self.moving_mobjects, mobject)

    def get_unit_square(self, color=YELLOW, opacity=0.3, stroke_width=3):
        &#34;&#34;&#34;
        Returns a unit square for the current NumberPlane.
        &#34;&#34;&#34;
        square = self.square = Rectangle(
            color=color,
            width=self.plane.get_x_unit_size(),
            height=self.plane.get_y_unit_size(),
            stroke_color=color,
            stroke_width=stroke_width,
            fill_color=color,
            fill_opacity=opacity
        )
        square.move_to(self.plane.coords_to_point(0, 0), DL)
        return square

    def add_unit_square(self, animate=False, **kwargs):
        &#34;&#34;&#34;
        Adds a unit square to the scene via
        self.get_unit_square.

        Parameters
        ----------
        animate (bool)
            Whether or not to animate the addition
            with DrawBorderThenFill.
        **kwargs
            Any valid keyword arguments of
            self.get_unit_square()
        
        Returns
        -------
        Square
            The unit square.
        &#34;&#34;&#34;
        square = self.get_unit_square(**kwargs)
        if animate:
            self.play(
                DrawBorderThenFill(square),
                Animation(Group(*self.moving_vectors))
            )
        self.add_transformable_mobject(square)
        self.bring_to_front(*self.moving_vectors)
        self.square = square
        return self

    def add_vector(self, vector, color=YELLOW, **kwargs):
        &#34;&#34;&#34;
        Adds a vector to the scene, and puts it in the special
        list self.moving_vectors.

        Parameters
        ----------
        vector Union(Arrow,list,tuple,np.ndarray)
            It can be a pre-made graphical vector, or the
            coordinates of one.
        
        color (str)
            The string of the hex color of the vector.
            This is only taken into consideration if
            &#39;vector&#39; is not an Arrow. Defaults to YELLOW.
        
        **kwargs
            Any valid keyword argument of VectorScene.add_vector.
        
        Returns
        -------
        Arrow
            The arrow representing the vector.
        &#34;&#34;&#34;
        vector = VectorScene.add_vector(
            self, vector, color=color, **kwargs
        )
        self.moving_vectors.append(vector)
        return vector

    def write_vector_coordinates(self, vector, **kwargs):
        &#34;&#34;&#34;
        Returns a column matrix indicating the vector coordinates,
        after writing them to the screen, and adding them to the
        special list self.foreground_mobjects

        Parameters
        ----------
        vector (Arrow)
            The arrow representing the vector.
        
        **kwargs
            Any valid keyword arguments of VectorScene.write_vector_coordinates

        Returns
        -------
        Matrix
            The column matrix representing the vector.
        &#34;&#34;&#34;
        coords = VectorScene.write_vector_coordinates(self, vector, **kwargs)
        self.add_foreground_mobject(coords)
        return coords

    def add_transformable_label(
            self, vector, label,
            transformation_name=&#34;L&#34;,
            new_label=None,
            **kwargs):
        &#34;&#34;&#34;
        Method for creating, and animating the addition of
        a transformable label for the vector.

        Parameters
        ----------
        vector (Vector)
            The vector for which the label must be added.
        label (TexMobject,str)
            The TexMobject/string of the label.
        new_label (TexMobject,str,None)
            What the label should display after a Linear Transformation
        **kwargs
            Any valid keyword argument of get_vector_label

        Returns
        -------
        TexMobject
            The TexMobject of the label.
        &#34;&#34;&#34;
        label_mob = self.label_vector(vector, label, **kwargs)
        if new_label:
            label_mob.target_text = new_label
        else:
            label_mob.target_text = &#34;%s(%s)&#34; % (
                transformation_name,
                label_mob.get_tex_string()
            )
        label_mob.vector = vector
        label_mob.kwargs = kwargs
        if &#34;animate&#34; in label_mob.kwargs:
            label_mob.kwargs.pop(&#34;animate&#34;)
        self.transformable_labels.append(label_mob)
        return label_mob

    def add_title(self, title, scale_factor=1.5, animate=False):
        &#34;&#34;&#34;
        Adds a title, after scaling it, adding a background rectangle,
        moving it to the top and adding it to foreground_mobjects adding
        it as a local variable of self. Returns the Scene.

        Parameters
        ----------
        title (str,TexMobject,TextMobject)
            What the title should be.
        
        scale_factor (int,float=1.5)
            How much the title should be scaled by.
        
        animate (bool=False)
            Whether or not to animate the addition.
        
        Returns
        -------
        LinearTransformationScene
            The scene with the title added to it.
        &#34;&#34;&#34;
        if not isinstance(title, Mobject):
            title = TextMobject(title).scale(scale_factor)
        title.to_edge(UP)
        title.add_background_rectangle()
        if animate:
            self.play(Write(title))
        self.add_foreground_mobject(title)
        self.title = title
        return self

    def get_matrix_transformation(self, matrix):
        &#34;&#34;&#34;
        Returns a function corresponding to the linear
        transformation represented by the matrix passed.

        Parameters
        ----------
        matrix (np.ndarray, list, tuple)
            The matrix.
        &#34;&#34;&#34;
        return self.get_transposed_matrix_transformation(np.array(matrix).T)

    def get_transposed_matrix_transformation(self, transposed_matrix):
        &#34;&#34;&#34;
        Returns a function corresponding to the linear
        transformation represented by the transposed 
        matrix passed.

        Parameters
        ----------
        matrix (np.ndarray, list, tuple)
            The matrix.
        &#34;&#34;&#34;
        transposed_matrix = np.array(transposed_matrix)
        if transposed_matrix.shape == (2, 2):
            new_matrix = np.identity(3)
            new_matrix[:2, :2] = transposed_matrix
            transposed_matrix = new_matrix
        elif transposed_matrix.shape != (3, 3):
            raise Exception(&#34;Matrix has bad dimensions&#34;)
        return lambda point: np.dot(point, transposed_matrix)

    def get_piece_movement(self, pieces):
        &#34;&#34;&#34;
        This method returns an animation that moves an arbitrary 
        mobject in &#34;pieces&#34; to its corresponding .target value.
        If self.leave_ghost_vectors is True, ghosts of the original
        positions/mobjects are left on screen

        Parameters
        ----------
        pieces (Union[list, tuple, np.array])
            The pieces for which the movement must be shown.
        
        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        start = VGroup(*pieces)
        target = VGroup(*[mob.target for mob in pieces])
        if self.leave_ghost_vectors:
            self.add(start.copy().fade(0.7))
        return Transform(start, target, lag_ratio=0)

    def get_moving_mobject_movement(self, func):
        &#34;&#34;&#34;
        This method returns an animation that moves a mobject
        in &#34;self.moving_mobjects&#34;  to its corresponding .target value.
        func is a function that determines where the .target goes.

        Parameters
        ----------

        func (function)
            The function that determines where the .target of
            the moving mobject goes.
        
        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        for m in self.moving_mobjects:
            if m.target is None:
                m.target = m.copy()
            target_point = func(m.get_center())
            m.target.move_to(target_point)
        return self.get_piece_movement(self.moving_mobjects)

    def get_vector_movement(self, func):
        &#34;&#34;&#34;
        This method returns an animation that moves a mobject
        in &#34;self.moving_vectors&#34;  to its corresponding .target value.
        func is a function that determines where the .target goes.

        Parameters
        ----------

        func (function)
            The function that determines where the .target of
            the moving mobject goes.
        
        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        for v in self.moving_vectors:
            v.target = Vector(func(v.get_end()), color=v.get_color())
            norm = get_norm(v.target.get_end())
            if norm &lt; 0.1:
                v.target.get_tip().scale_in_place(norm)
        return self.get_piece_movement(self.moving_vectors)

    def get_transformable_label_movement(self):
        &#34;&#34;&#34;
        This method returns an animation that moves all labels
        in &#34;self.transformable_labels&#34; to its corresponding .target .

        Returns
        -------
        Animation
            The animation of the movement.
        &#34;&#34;&#34;
        for l in self.transformable_labels:
            l.target = self.get_vector_label(
                l.vector.target, l.target_text, **l.kwargs
            )
        return self.get_piece_movement(self.transformable_labels)

    def apply_matrix(self, matrix, **kwargs):
        &#34;&#34;&#34;
        Applies the transformation represented by the
        given matrix to the number plane, and each vector/similar
        mobject on it.

        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix.
        **kwargs
            Any valid keyword argument of self.apply_transposed_matrix()
        &#34;&#34;&#34;
        self.apply_transposed_matrix(np.array(matrix).T, **kwargs)

    def apply_inverse(self, matrix, **kwargs):
        &#34;&#34;&#34;
        This method applies the linear transformation
        represented by the inverse of the passed matrix
        to the number plane, and each vector/similar mobject on it.
        
        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix whose inverse is to be applied.
        **kwargs
            Any valid keyword argument of self.apply_matrix()
        &#34;&#34;&#34;
        self.apply_matrix(np.linalg.inv(matrix), **kwargs)

    def apply_transposed_matrix(self, transposed_matrix, **kwargs):
        &#34;&#34;&#34;
        Applies the transformation represented by the
        given transposed matrix to the number plane,
        and each vector/similar mobject on it.

        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix.
        **kwargs
            Any valid keyword argument of self.apply_function()
        &#34;&#34;&#34;
        func = self.get_transposed_matrix_transformation(transposed_matrix)
        if &#34;path_arc&#34; not in kwargs:
            net_rotation = np.mean([
                angle_of_vector(func(RIGHT)),
                angle_of_vector(func(UP)) - np.pi / 2
            ])
            kwargs[&#34;path_arc&#34;] = net_rotation
        self.apply_function(func, **kwargs)

    def apply_inverse_transpose(self, t_matrix, **kwargs):
        &#34;&#34;&#34;
        Applies the inverse of the transformation represented
        by the given transposed matrix to the number plane and each 
        vector/similar mobject on it.

        Parameters
        ----------
        matrix (Union[np.ndarray, list, tuple])
            The matrix.
        **kwargs
            Any valid keyword argument of self.apply_transposed_matrix()
        &#34;&#34;&#34;
        t_inv = np.linalg.inv(np.array(t_matrix).T).T
        self.apply_transposed_matrix(t_inv, **kwargs)

    def apply_nonlinear_transformation(self, function, **kwargs):
        &#34;&#34;&#34;
        Applies the non-linear transformation represented
        by the given function to the number plane and each
        vector/similar mobject on it.

        Parameters
        ----------
        function (Function)
            The function.
        **kwargs
            Any valid keyword argument of self.apply_function()
        &#34;&#34;&#34;
        self.plane.prepare_for_nonlinear_transform()
        self.apply_function(function, **kwargs)

    def apply_function(self, function, added_anims=[], **kwargs):
        &#34;&#34;&#34;
        Applies the given function to each of the mobjects in
        self.transformable_mobjects, and plays the animation showing
        this.

        Parameters
        ----------
        function (Function)
            The function that affects each point
            of each mobject in self.transformable_mobjects.
        
        added_anims (list)
            Any other animations that need to be played
            simulataneously with this.
        
        **kwargs
            Any valid keyword argument of a self.play() call.
        &#34;&#34;&#34;
        if &#34;run_time&#34; not in kwargs:
            kwargs[&#34;run_time&#34;] = 3
        anims = [
            ApplyPointwiseFunction(function, t_mob)
            for t_mob in self.transformable_mobjects
        ] + [
            self.get_vector_movement(function),
            self.get_transformable_label_movement(),
            self.get_moving_mobject_movement(function),
        ] + [
            Animation(f_mob)
            for f_mob in self.foreground_mobjects
        ] + added_anims
        self.play(*anims, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.scene.vector_space_scene.VectorScene" href="#manimlib.scene.vector_space_scene.VectorScene">VectorScene</a></li>
<li><a title="manimlib.scene.scene.Scene" href="scene.html#manimlib.scene.scene.Scene">Scene</a></li>
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_background_mobject"><code class="name flex">
<span>def <span class="ident">add_background_mobject</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the mobjects to the special list
self.background_mobjects.</p>
<h2 id="parameters">Parameters</h2>
<p>*mobjects (Mobject)
The mobjects to add to the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_background_mobject(self, *mobjects):
    &#34;&#34;&#34;
    Adds the mobjects to the special list
    self.background_mobjects.

    Parameters
    ----------
    *mobjects (Mobject)
        The mobjects to add to the list.
    &#34;&#34;&#34;
    self.add_special_mobjects(self.background_mobjects, *mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_foreground_mobject"><code class="name flex">
<span>def <span class="ident">add_foreground_mobject</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the mobjects to the special list
self.foreground_mobjects.</p>
<h2 id="parameters">Parameters</h2>
<p>*mobjects (Mobject)
The mobjects to add to the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_foreground_mobject(self, *mobjects):
    &#34;&#34;&#34;
    Adds the mobjects to the special list
    self.foreground_mobjects.

    Parameters
    ----------
    *mobjects (Mobject)
        The mobjects to add to the list
    &#34;&#34;&#34;
    self.add_special_mobjects(self.foreground_mobjects, *mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_moving_mobject"><code class="name flex">
<span>def <span class="ident">add_moving_mobject</span></span>(<span>self, mobject, target_mobject=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the mobject to the special list
self.moving_mobject, and adds a property
to the mobject called mobject.target, which
keeps track of what the mobject will move to
or become etc.</p>
<h2 id="parameters">Parameters</h2>
<p>mobject (Mobject)
The mobjects to add to the list</p>
<p>target_mobject (Mobject)
What the moving_mobject goes to, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_moving_mobject(self, mobject, target_mobject=None):
    &#34;&#34;&#34;
    Adds the mobject to the special list
    self.moving_mobject, and adds a property
    to the mobject called mobject.target, which
    keeps track of what the mobject will move to
    or become etc.

    Parameters
    ----------
    mobject (Mobject)
        The mobjects to add to the list
    
    target_mobject (Mobject)
        What the moving_mobject goes to, etc.
    &#34;&#34;&#34;
    mobject.target = target_mobject
    self.add_special_mobjects(self.moving_mobjects, mobject)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_special_mobjects"><code class="name flex">
<span>def <span class="ident">add_special_mobjects</span></span>(<span>self, mob_list, *mobs_to_add)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds mobjects to a separate list that can be tracked,
if these mobjects have some extra importance.</p>
<h2 id="parameters">Parameters</h2>
<p>mob_list (list)
The special list to which you want to add
these mobjects.</p>
<p>*mobs_to_add (Mobject)
The mobjects to add.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_special_mobjects(self, mob_list, *mobs_to_add):
    &#34;&#34;&#34;
    Adds mobjects to a separate list that can be tracked,
    if these mobjects have some extra importance.

    Parameters
    ----------
    mob_list (list)
        The special list to which you want to add
        these mobjects.
    
    *mobs_to_add (Mobject)
        The mobjects to add.

    &#34;&#34;&#34;
    for mobject in mobs_to_add:
        if mobject not in mob_list:
            mob_list.append(mobject)
            self.add(mobject)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_title"><code class="name flex">
<span>def <span class="ident">add_title</span></span>(<span>self, title, scale_factor=1.5, animate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a title, after scaling it, adding a background rectangle,
moving it to the top and adding it to foreground_mobjects adding
it as a local variable of self. Returns the Scene.</p>
<h2 id="parameters">Parameters</h2>
<p>title (str,TexMobject,TextMobject)
What the title should be.</p>
<p>scale_factor (int,float=1.5)
How much the title should be scaled by.</p>
<p>animate (bool=False)
Whether or not to animate the addition.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene" href="#manimlib.scene.vector_space_scene.LinearTransformationScene">LinearTransformationScene</a></code></dt>
<dd>The scene with the title added to it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_title(self, title, scale_factor=1.5, animate=False):
    &#34;&#34;&#34;
    Adds a title, after scaling it, adding a background rectangle,
    moving it to the top and adding it to foreground_mobjects adding
    it as a local variable of self. Returns the Scene.

    Parameters
    ----------
    title (str,TexMobject,TextMobject)
        What the title should be.
    
    scale_factor (int,float=1.5)
        How much the title should be scaled by.
    
    animate (bool=False)
        Whether or not to animate the addition.
    
    Returns
    -------
    LinearTransformationScene
        The scene with the title added to it.
    &#34;&#34;&#34;
    if not isinstance(title, Mobject):
        title = TextMobject(title).scale(scale_factor)
    title.to_edge(UP)
    title.add_background_rectangle()
    if animate:
        self.play(Write(title))
    self.add_foreground_mobject(title)
    self.title = title
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_transformable_label"><code class="name flex">
<span>def <span class="ident">add_transformable_label</span></span>(<span>self, vector, label, transformation_name='L', new_label=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for creating, and animating the addition of
a transformable label for the vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>vector (Vector)</dt>
<dt>The vector for which the label must be added.</dt>
<dt>label (TexMobject,str)</dt>
<dt>The TexMobject/string of the label.</dt>
<dt>new_label (TexMobject,str,None)</dt>
<dt>What the label should display after a Linear Transformation</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of get_vector_label</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TexMobject</code></dt>
<dd>The TexMobject of the label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_transformable_label(
        self, vector, label,
        transformation_name=&#34;L&#34;,
        new_label=None,
        **kwargs):
    &#34;&#34;&#34;
    Method for creating, and animating the addition of
    a transformable label for the vector.

    Parameters
    ----------
    vector (Vector)
        The vector for which the label must be added.
    label (TexMobject,str)
        The TexMobject/string of the label.
    new_label (TexMobject,str,None)
        What the label should display after a Linear Transformation
    **kwargs
        Any valid keyword argument of get_vector_label

    Returns
    -------
    TexMobject
        The TexMobject of the label.
    &#34;&#34;&#34;
    label_mob = self.label_vector(vector, label, **kwargs)
    if new_label:
        label_mob.target_text = new_label
    else:
        label_mob.target_text = &#34;%s(%s)&#34; % (
            transformation_name,
            label_mob.get_tex_string()
        )
    label_mob.vector = vector
    label_mob.kwargs = kwargs
    if &#34;animate&#34; in label_mob.kwargs:
        label_mob.kwargs.pop(&#34;animate&#34;)
    self.transformable_labels.append(label_mob)
    return label_mob</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_transformable_mobject"><code class="name flex">
<span>def <span class="ident">add_transformable_mobject</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the mobjects to the special list
self.transformable_mobjects.</p>
<h2 id="parameters">Parameters</h2>
<p>*mobjects (Mobject)
The mobjects to add to the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_transformable_mobject(self, *mobjects):
    &#34;&#34;&#34;
    Adds the mobjects to the special list
    self.transformable_mobjects.

    Parameters
    ----------
    *mobjects (Mobject)
        The mobjects to add to the list.
    &#34;&#34;&#34;
    self.add_special_mobjects(self.transformable_mobjects, *mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_unit_square"><code class="name flex">
<span>def <span class="ident">add_unit_square</span></span>(<span>self, animate=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a unit square to the scene via
self.get_unit_square.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>animate (bool)</dt>
<dt>Whether or not to animate the addition</dt>
<dt>with DrawBorderThenFill.</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword arguments of
self.get_unit_square()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Square</code></dt>
<dd>The unit square.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_unit_square(self, animate=False, **kwargs):
    &#34;&#34;&#34;
    Adds a unit square to the scene via
    self.get_unit_square.

    Parameters
    ----------
    animate (bool)
        Whether or not to animate the addition
        with DrawBorderThenFill.
    **kwargs
        Any valid keyword arguments of
        self.get_unit_square()
    
    Returns
    -------
    Square
        The unit square.
    &#34;&#34;&#34;
    square = self.get_unit_square(**kwargs)
    if animate:
        self.play(
            DrawBorderThenFill(square),
            Animation(Group(*self.moving_vectors))
        )
    self.add_transformable_mobject(square)
    self.bring_to_front(*self.moving_vectors)
    self.square = square
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.add_vector"><code class="name flex">
<span>def <span class="ident">add_vector</span></span>(<span>self, vector, color='#FFFF00', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a vector to the scene, and puts it in the special
list self.moving_vectors.</p>
<h2 id="parameters">Parameters</h2>
<p>vector Union(Arrow,list,tuple,np.ndarray)
It can be a pre-made graphical vector, or the
coordinates of one.</p>
<p>color (str)
The string of the hex color of the vector.
This is only taken into consideration if
'vector' is not an Arrow. Defaults to YELLOW.</p>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of VectorScene.add_vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Arrow</code></dt>
<dd>The arrow representing the vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vector(self, vector, color=YELLOW, **kwargs):
    &#34;&#34;&#34;
    Adds a vector to the scene, and puts it in the special
    list self.moving_vectors.

    Parameters
    ----------
    vector Union(Arrow,list,tuple,np.ndarray)
        It can be a pre-made graphical vector, or the
        coordinates of one.
    
    color (str)
        The string of the hex color of the vector.
        This is only taken into consideration if
        &#39;vector&#39; is not an Arrow. Defaults to YELLOW.
    
    **kwargs
        Any valid keyword argument of VectorScene.add_vector.
    
    Returns
    -------
    Arrow
        The arrow representing the vector.
    &#34;&#34;&#34;
    vector = VectorScene.add_vector(
        self, vector, color=color, **kwargs
    )
    self.moving_vectors.append(vector)
    return vector</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_function"><code class="name flex">
<span>def <span class="ident">apply_function</span></span>(<span>self, function, added_anims=[], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the given function to each of the mobjects in
self.transformable_mobjects, and plays the animation showing
this.</p>
<h2 id="parameters">Parameters</h2>
<p>function (Function)
The function that affects each point
of each mobject in self.transformable_mobjects.</p>
<p>added_anims (list)
Any other animations that need to be played
simulataneously with this.</p>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of a self.play() call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_function(self, function, added_anims=[], **kwargs):
    &#34;&#34;&#34;
    Applies the given function to each of the mobjects in
    self.transformable_mobjects, and plays the animation showing
    this.

    Parameters
    ----------
    function (Function)
        The function that affects each point
        of each mobject in self.transformable_mobjects.
    
    added_anims (list)
        Any other animations that need to be played
        simulataneously with this.
    
    **kwargs
        Any valid keyword argument of a self.play() call.
    &#34;&#34;&#34;
    if &#34;run_time&#34; not in kwargs:
        kwargs[&#34;run_time&#34;] = 3
    anims = [
        ApplyPointwiseFunction(function, t_mob)
        for t_mob in self.transformable_mobjects
    ] + [
        self.get_vector_movement(function),
        self.get_transformable_label_movement(),
        self.get_moving_mobject_movement(function),
    ] + [
        Animation(f_mob)
        for f_mob in self.foreground_mobjects
    ] + added_anims
    self.play(*anims, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_inverse"><code class="name flex">
<span>def <span class="ident">apply_inverse</span></span>(<span>self, matrix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method applies the linear transformation
represented by the inverse of the passed matrix
to the number plane, and each vector/similar mobject on it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>matrix (Union[np.ndarray, list, tuple])</dt>
<dt>The matrix whose inverse is to be applied.</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of self.apply_matrix()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_inverse(self, matrix, **kwargs):
    &#34;&#34;&#34;
    This method applies the linear transformation
    represented by the inverse of the passed matrix
    to the number plane, and each vector/similar mobject on it.
    
    Parameters
    ----------
    matrix (Union[np.ndarray, list, tuple])
        The matrix whose inverse is to be applied.
    **kwargs
        Any valid keyword argument of self.apply_matrix()
    &#34;&#34;&#34;
    self.apply_matrix(np.linalg.inv(matrix), **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_inverse_transpose"><code class="name flex">
<span>def <span class="ident">apply_inverse_transpose</span></span>(<span>self, t_matrix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the inverse of the transformation represented
by the given transposed matrix to the number plane and each
vector/similar mobject on it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>matrix (Union[np.ndarray, list, tuple])</dt>
<dt>The matrix.</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of self.apply_transposed_matrix()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_inverse_transpose(self, t_matrix, **kwargs):
    &#34;&#34;&#34;
    Applies the inverse of the transformation represented
    by the given transposed matrix to the number plane and each 
    vector/similar mobject on it.

    Parameters
    ----------
    matrix (Union[np.ndarray, list, tuple])
        The matrix.
    **kwargs
        Any valid keyword argument of self.apply_transposed_matrix()
    &#34;&#34;&#34;
    t_inv = np.linalg.inv(np.array(t_matrix).T).T
    self.apply_transposed_matrix(t_inv, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_matrix"><code class="name flex">
<span>def <span class="ident">apply_matrix</span></span>(<span>self, matrix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the transformation represented by the
given matrix to the number plane, and each vector/similar
mobject on it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>matrix (Union[np.ndarray, list, tuple])</dt>
<dt>The matrix.</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of self.apply_transposed_matrix()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_matrix(self, matrix, **kwargs):
    &#34;&#34;&#34;
    Applies the transformation represented by the
    given matrix to the number plane, and each vector/similar
    mobject on it.

    Parameters
    ----------
    matrix (Union[np.ndarray, list, tuple])
        The matrix.
    **kwargs
        Any valid keyword argument of self.apply_transposed_matrix()
    &#34;&#34;&#34;
    self.apply_transposed_matrix(np.array(matrix).T, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_nonlinear_transformation"><code class="name flex">
<span>def <span class="ident">apply_nonlinear_transformation</span></span>(<span>self, function, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the non-linear transformation represented
by the given function to the number plane and each
vector/similar mobject on it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>function (Function)</dt>
<dt>The function.</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of self.apply_function()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_nonlinear_transformation(self, function, **kwargs):
    &#34;&#34;&#34;
    Applies the non-linear transformation represented
    by the given function to the number plane and each
    vector/similar mobject on it.

    Parameters
    ----------
    function (Function)
        The function.
    **kwargs
        Any valid keyword argument of self.apply_function()
    &#34;&#34;&#34;
    self.plane.prepare_for_nonlinear_transform()
    self.apply_function(function, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_transposed_matrix"><code class="name flex">
<span>def <span class="ident">apply_transposed_matrix</span></span>(<span>self, transposed_matrix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the transformation represented by the
given transposed matrix to the number plane,
and each vector/similar mobject on it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>matrix (Union[np.ndarray, list, tuple])</dt>
<dt>The matrix.</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of self.apply_function()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_transposed_matrix(self, transposed_matrix, **kwargs):
    &#34;&#34;&#34;
    Applies the transformation represented by the
    given transposed matrix to the number plane,
    and each vector/similar mobject on it.

    Parameters
    ----------
    matrix (Union[np.ndarray, list, tuple])
        The matrix.
    **kwargs
        Any valid keyword argument of self.apply_function()
    &#34;&#34;&#34;
    func = self.get_transposed_matrix_transformation(transposed_matrix)
    if &#34;path_arc&#34; not in kwargs:
        net_rotation = np.mean([
            angle_of_vector(func(RIGHT)),
            angle_of_vector(func(UP)) - np.pi / 2
        ])
        kwargs[&#34;path_arc&#34;] = net_rotation
    self.apply_function(func, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.get_matrix_transformation"><code class="name flex">
<span>def <span class="ident">get_matrix_transformation</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a function corresponding to the linear
transformation represented by the matrix passed.</p>
<h2 id="parameters">Parameters</h2>
<p>matrix (np.ndarray, list, tuple)
The matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrix_transformation(self, matrix):
    &#34;&#34;&#34;
    Returns a function corresponding to the linear
    transformation represented by the matrix passed.

    Parameters
    ----------
    matrix (np.ndarray, list, tuple)
        The matrix.
    &#34;&#34;&#34;
    return self.get_transposed_matrix_transformation(np.array(matrix).T)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.get_moving_mobject_movement"><code class="name flex">
<span>def <span class="ident">get_moving_mobject_movement</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns an animation that moves a mobject
in "self.moving_mobjects"
to its corresponding .target value.
func is a function that determines where the .target goes.</p>
<h2 id="parameters">Parameters</h2>
<p>func (function)
The function that determines where the .target of
the moving mobject goes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Animation</code></dt>
<dd>The animation of the movement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_moving_mobject_movement(self, func):
    &#34;&#34;&#34;
    This method returns an animation that moves a mobject
    in &#34;self.moving_mobjects&#34;  to its corresponding .target value.
    func is a function that determines where the .target goes.

    Parameters
    ----------

    func (function)
        The function that determines where the .target of
        the moving mobject goes.
    
    Returns
    -------
    Animation
        The animation of the movement.
    &#34;&#34;&#34;
    for m in self.moving_mobjects:
        if m.target is None:
            m.target = m.copy()
        target_point = func(m.get_center())
        m.target.move_to(target_point)
    return self.get_piece_movement(self.moving_mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.get_piece_movement"><code class="name flex">
<span>def <span class="ident">get_piece_movement</span></span>(<span>self, pieces)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns an animation that moves an arbitrary
mobject in "pieces" to its corresponding .target value.
If self.leave_ghost_vectors is True, ghosts of the original
positions/mobjects are left on screen</p>
<h2 id="parameters">Parameters</h2>
<p>pieces (Union[list, tuple, np.array])
The pieces for which the movement must be shown.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Animation</code></dt>
<dd>The animation of the movement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_piece_movement(self, pieces):
    &#34;&#34;&#34;
    This method returns an animation that moves an arbitrary 
    mobject in &#34;pieces&#34; to its corresponding .target value.
    If self.leave_ghost_vectors is True, ghosts of the original
    positions/mobjects are left on screen

    Parameters
    ----------
    pieces (Union[list, tuple, np.array])
        The pieces for which the movement must be shown.
    
    Returns
    -------
    Animation
        The animation of the movement.
    &#34;&#34;&#34;
    start = VGroup(*pieces)
    target = VGroup(*[mob.target for mob in pieces])
    if self.leave_ghost_vectors:
        self.add(start.copy().fade(0.7))
    return Transform(start, target, lag_ratio=0)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.get_transformable_label_movement"><code class="name flex">
<span>def <span class="ident">get_transformable_label_movement</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns an animation that moves all labels
in "self.transformable_labels" to its corresponding .target .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Animation</code></dt>
<dd>The animation of the movement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transformable_label_movement(self):
    &#34;&#34;&#34;
    This method returns an animation that moves all labels
    in &#34;self.transformable_labels&#34; to its corresponding .target .

    Returns
    -------
    Animation
        The animation of the movement.
    &#34;&#34;&#34;
    for l in self.transformable_labels:
        l.target = self.get_vector_label(
            l.vector.target, l.target_text, **l.kwargs
        )
    return self.get_piece_movement(self.transformable_labels)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.get_transposed_matrix_transformation"><code class="name flex">
<span>def <span class="ident">get_transposed_matrix_transformation</span></span>(<span>self, transposed_matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a function corresponding to the linear
transformation represented by the transposed
matrix passed.</p>
<h2 id="parameters">Parameters</h2>
<p>matrix (np.ndarray, list, tuple)
The matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transposed_matrix_transformation(self, transposed_matrix):
    &#34;&#34;&#34;
    Returns a function corresponding to the linear
    transformation represented by the transposed 
    matrix passed.

    Parameters
    ----------
    matrix (np.ndarray, list, tuple)
        The matrix.
    &#34;&#34;&#34;
    transposed_matrix = np.array(transposed_matrix)
    if transposed_matrix.shape == (2, 2):
        new_matrix = np.identity(3)
        new_matrix[:2, :2] = transposed_matrix
        transposed_matrix = new_matrix
    elif transposed_matrix.shape != (3, 3):
        raise Exception(&#34;Matrix has bad dimensions&#34;)
    return lambda point: np.dot(point, transposed_matrix)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.get_unit_square"><code class="name flex">
<span>def <span class="ident">get_unit_square</span></span>(<span>self, color='#FFFF00', opacity=0.3, stroke_width=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a unit square for the current NumberPlane.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unit_square(self, color=YELLOW, opacity=0.3, stroke_width=3):
    &#34;&#34;&#34;
    Returns a unit square for the current NumberPlane.
    &#34;&#34;&#34;
    square = self.square = Rectangle(
        color=color,
        width=self.plane.get_x_unit_size(),
        height=self.plane.get_y_unit_size(),
        stroke_color=color,
        stroke_width=stroke_width,
        fill_color=color,
        fill_opacity=opacity
    )
    square.move_to(self.plane.coords_to_point(0, 0), DL)
    return square</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.get_vector_movement"><code class="name flex">
<span>def <span class="ident">get_vector_movement</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns an animation that moves a mobject
in "self.moving_vectors"
to its corresponding .target value.
func is a function that determines where the .target goes.</p>
<h2 id="parameters">Parameters</h2>
<p>func (function)
The function that determines where the .target of
the moving mobject goes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Animation</code></dt>
<dd>The animation of the movement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vector_movement(self, func):
    &#34;&#34;&#34;
    This method returns an animation that moves a mobject
    in &#34;self.moving_vectors&#34;  to its corresponding .target value.
    func is a function that determines where the .target goes.

    Parameters
    ----------

    func (function)
        The function that determines where the .target of
        the moving mobject goes.
    
    Returns
    -------
    Animation
        The animation of the movement.
    &#34;&#34;&#34;
    for v in self.moving_vectors:
        v.target = Vector(func(v.get_end()), color=v.get_color())
        norm = get_norm(v.target.get_end())
        if norm &lt; 0.1:
            v.target.get_tip().scale_in_place(norm)
    return self.get_piece_movement(self.moving_vectors)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.LinearTransformationScene.write_vector_coordinates"><code class="name flex">
<span>def <span class="ident">write_vector_coordinates</span></span>(<span>self, vector, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a column matrix indicating the vector coordinates,
after writing them to the screen, and adding them to the
special list self.foreground_mobjects</p>
<h2 id="parameters">Parameters</h2>
<p>vector (Arrow)
The arrow representing the vector.</p>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword arguments of VectorScene.write_vector_coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Matrix</code></dt>
<dd>The column matrix representing the vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_vector_coordinates(self, vector, **kwargs):
    &#34;&#34;&#34;
    Returns a column matrix indicating the vector coordinates,
    after writing them to the screen, and adding them to the
    special list self.foreground_mobjects

    Parameters
    ----------
    vector (Arrow)
        The arrow representing the vector.
    
    **kwargs
        Any valid keyword arguments of VectorScene.write_vector_coordinates

    Returns
    -------
    Matrix
        The column matrix representing the vector.
    &#34;&#34;&#34;
    coords = VectorScene.write_vector_coordinates(self, vector, **kwargs)
    self.add_foreground_mobject(coords)
    return coords</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.scene.vector_space_scene.VectorScene" href="#manimlib.scene.vector_space_scene.VectorScene">VectorScene</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add" href="scene.html#manimlib.scene.scene.Scene.add">add</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_axes" href="#manimlib.scene.vector_space_scene.VectorScene.add_axes">add_axes</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_foreground_mobjects" href="scene.html#manimlib.scene.scene.Scene.add_foreground_mobjects">add_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_frames" href="scene.html#manimlib.scene.scene.Scene.add_frames">add_frames</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_mobjects_among" href="scene.html#manimlib.scene.scene.Scene.add_mobjects_among">add_mobjects_among</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_plane" href="#manimlib.scene.vector_space_scene.VectorScene.add_plane">add_plane</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_sound" href="scene.html#manimlib.scene.scene.Scene.add_sound">add_sound</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.begin_animations" href="scene.html#manimlib.scene.scene.Scene.begin_animations">begin_animations</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.bring_to_back" href="scene.html#manimlib.scene.scene.Scene.bring_to_back">bring_to_back</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.bring_to_front" href="scene.html#manimlib.scene.scene.Scene.bring_to_front">bring_to_front</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.capture_mobjects_in_camera" href="scene.html#manimlib.scene.scene.Scene.capture_mobjects_in_camera">capture_mobjects_in_camera</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.clean_up_animations" href="scene.html#manimlib.scene.scene.Scene.clean_up_animations">clean_up_animations</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.clear" href="scene.html#manimlib.scene.scene.Scene.clear">clear</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.compile_play_args_to_animation_list" href="scene.html#manimlib.scene.scene.Scene.compile_play_args_to_animation_list">compile_play_args_to_animation_list</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.construct" href="scene.html#manimlib.scene.scene.Scene.construct">construct</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.coords_to_vector" href="#manimlib.scene.vector_space_scene.VectorScene.coords_to_vector">coords_to_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.finish_animations" href="scene.html#manimlib.scene.scene.Scene.finish_animations">finish_animations</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.force_skipping" href="scene.html#manimlib.scene.scene.Scene.force_skipping">force_skipping</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_animation_time_progression" href="scene.html#manimlib.scene.scene.Scene.get_animation_time_progression">get_animation_time_progression</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_attrs" href="scene.html#manimlib.scene.scene.Scene.get_attrs">get_attrs</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_basis_vector_labels" href="#manimlib.scene.vector_space_scene.VectorScene.get_basis_vector_labels">get_basis_vector_labels</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_basis_vectors" href="#manimlib.scene.vector_space_scene.VectorScene.get_basis_vectors">get_basis_vectors</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_frame" href="scene.html#manimlib.scene.scene.Scene.get_frame">get_frame</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_image" href="scene.html#manimlib.scene.scene.Scene.get_image">get_image</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_mobject_copies" href="scene.html#manimlib.scene.scene.Scene.get_mobject_copies">get_mobject_copies</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_mobject_family_members" href="scene.html#manimlib.scene.scene.Scene.get_mobject_family_members">get_mobject_family_members</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_mobjects" href="scene.html#manimlib.scene.scene.Scene.get_mobjects">get_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_mobjects_from_last_animation" href="scene.html#manimlib.scene.scene.Scene.get_mobjects_from_last_animation">get_mobjects_from_last_animation</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_moving_mobjects" href="scene.html#manimlib.scene.scene.Scene.get_moving_mobjects">get_moving_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_restructured_mobject_list" href="scene.html#manimlib.scene.scene.Scene.get_restructured_mobject_list">get_restructured_mobject_list</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_run_time" href="scene.html#manimlib.scene.scene.Scene.get_run_time">get_run_time</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_time" href="scene.html#manimlib.scene.scene.Scene.get_time">get_time</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_time_progression" href="scene.html#manimlib.scene.scene.Scene.get_time_progression">get_time_progression</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_top_level_mobjects" href="scene.html#manimlib.scene.scene.Scene.get_top_level_mobjects">get_top_level_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_vector" href="#manimlib.scene.vector_space_scene.VectorScene.get_vector">get_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_vector_label" href="#manimlib.scene.vector_space_scene.VectorScene.get_vector_label">get_vector_label</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_wait_time_progression" href="scene.html#manimlib.scene.scene.Scene.get_wait_time_progression">get_wait_time_progression</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.handle_play_like_call" href="scene.html#manimlib.scene.scene.Scene.handle_play_like_call">handle_play_like_call</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.idle_stream" href="scene.html#manimlib.scene.scene.Scene.idle_stream">idle_stream</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.increment_time" href="scene.html#manimlib.scene.scene.Scene.increment_time">increment_time</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.label_vector" href="#manimlib.scene.vector_space_scene.VectorScene.label_vector">label_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.lock_in_faded_grid" href="#manimlib.scene.vector_space_scene.VectorScene.lock_in_faded_grid">lock_in_faded_grid</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.print_end_message" href="scene.html#manimlib.scene.scene.Scene.print_end_message">print_end_message</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.progress_through_animations" href="scene.html#manimlib.scene.scene.Scene.progress_through_animations">progress_through_animations</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.remove" href="scene.html#manimlib.scene.scene.Scene.remove">remove</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.remove_foreground_mobject" href="scene.html#manimlib.scene.scene.Scene.remove_foreground_mobject">remove_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.remove_foreground_mobjects" href="scene.html#manimlib.scene.scene.Scene.remove_foreground_mobjects">remove_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.reset_camera" href="scene.html#manimlib.scene.scene.Scene.reset_camera">reset_camera</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.restructure_mobjects" href="scene.html#manimlib.scene.scene.Scene.restructure_mobjects">restructure_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.revert_to_original_skipping_status" href="scene.html#manimlib.scene.scene.Scene.revert_to_original_skipping_status">revert_to_original_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.set_camera" href="scene.html#manimlib.scene.scene.Scene.set_camera">set_camera</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.set_camera_background" href="scene.html#manimlib.scene.scene.Scene.set_camera_background">set_camera_background</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.set_camera_pixel_array" href="scene.html#manimlib.scene.scene.Scene.set_camera_pixel_array">set_camera_pixel_array</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.set_variables_as_attrs" href="scene.html#manimlib.scene.scene.Scene.set_variables_as_attrs">set_variables_as_attrs</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.setup" href="scene.html#manimlib.scene.scene.Scene.setup">setup</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.should_update_mobjects" href="scene.html#manimlib.scene.scene.Scene.should_update_mobjects">should_update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.show_frame" href="scene.html#manimlib.scene.scene.Scene.show_frame">show_frame</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.show_ghost_movement" href="#manimlib.scene.vector_space_scene.VectorScene.show_ghost_movement">show_ghost_movement</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.tear_down" href="scene.html#manimlib.scene.scene.Scene.tear_down">tear_down</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.update_frame" href="scene.html#manimlib.scene.scene.Scene.update_frame">update_frame</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.update_mobjects" href="scene.html#manimlib.scene.scene.Scene.update_mobjects">update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.update_skipping_status" href="scene.html#manimlib.scene.scene.Scene.update_skipping_status">update_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.vector_to_coords" href="#manimlib.scene.vector_space_scene.VectorScene.vector_to_coords">vector_to_coords</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.wait_until" href="scene.html#manimlib.scene.scene.Scene.wait_until">wait_until</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene"><code class="flex name class">
<span>class <span class="ident">VectorScene</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Scene can be thought of as the Canvas of your animation.
All of your own named Scenes will be subclasses of this Scene, or
other named scenes.</p>
<p>Use a construct() function to tell Manim what should go on in the Scene.</p>
<p>E.G:</p>
<pre><code>class MyScene(Scene):
    def construct(self):
        self.play(
            Write(Text("Hello World!"))
        )
</code></pre>
<p>Some important variables to note are:
camera: The camera object to be used for the scene.
file_writer : The object that writes the animations in the scene to a video file.
mobjects : The list of mobjects present in the scene.
foreground_mobjects : List of mobjects explicitly in the foreground.
num_plays : Number of play() functions in the scene.
time: time elapsed since initialisation of scene.
random_seed: The seed with which all random operations are done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorScene(Scene):
    CONFIG = {
        &#34;basis_vector_stroke_width&#34;: 6
    }

    def add_plane(self, animate=False, **kwargs):
        &#34;&#34;&#34;
        Adds a NumberPlane object to the background.

        Parameters
        ----------
        animate : (bool=False)
            Whether or not to animate the addition of the plane via ShowCreation.
        **kwargs
            Any valid keyword arguments accepted by NumberPlane.
        
        Returns
        -------
        NumberPlane
            The NumberPlane object.
        &#34;&#34;&#34;
        plane = NumberPlane(**kwargs)
        if animate:
            self.play(ShowCreation(plane, lag_ratio=0.5))
        self.add(plane)
        return plane

    def add_axes(self, animate=False, color=WHITE, **kwargs):
        &#34;&#34;&#34;
        Adds a pair of Axes to the Scene.

        Parameters
        ----------
        animate (bool=False)
            Whether or not to animate the addition of the axes through ShowCreation.
        color (str)
            The color of the axes. Defaults to WHITE.
        &#34;&#34;&#34;
        axes = Axes(color=color, tick_frequency=1)
        if animate:
            self.play(ShowCreation(axes))
        self.add(axes)
        return axes

    def lock_in_faded_grid(self, dimness=0.7, axes_dimness=0.5):
        &#34;&#34;&#34;
        This method freezes the NumberPlane and Axes that were already
        in the background, and adds new, manipulatable ones to the foreground.
        
        Parameters
        ----------
        dimness (Union[int,float=0.7])
            The required dimness of the NumberPlane
        
        axes_dimness (Union[int,float=0.5])
            The required dimness of the Axes.
        &#34;&#34;&#34;
        plane = self.add_plane()
        axes = plane.get_axes()
        plane.fade(dimness)
        axes.set_color(WHITE)
        axes.fade(axes_dimness)
        self.add(axes)
        self.freeze_background()

    def get_vector(self, numerical_vector, **kwargs):
        &#34;&#34;&#34;
        Returns an arrow on the Plane given an input numerical vector.
        
        Parameters
        ----------
        numerical_vector : Union(np.ndarray, list, tuple)
            The Vector to plot.
        **kwargs
            Any valid keyword argument of Arrow.
        
        Returns
        -------
        Arrow
            The Arrow representing the Vector.
        &#34;&#34;&#34;
        return Arrow(
            self.plane.coords_to_point(0, 0),
            self.plane.coords_to_point(*numerical_vector[:2]),
            buff=0,
            **kwargs
        )

    def add_vector(self, vector, color=YELLOW, animate=True, **kwargs):
        &#34;&#34;&#34;
        Returns the Vector after adding it to the Plane.

        Parameters
        ----------
        vector Union(Arrow,list,tuple,np.ndarray)
            It can be a pre-made graphical vector, or the
            coordinates of one.
        
        color (str)
            The string of the hex color of the vector.
            This is only taken into consideration if
            &#39;vector&#39; is not an Arrow. Defaults to YELLOW.
        
        animate (bool=True)
            Whether or not to animate the addition of the vector
            by using GrowArrow
        
        **kwargs
            Any valid keyword argument of Arrow.
            These are only considered if vector is not
            an Arrow.
        
        Returns
        -------
        Arrow
            The arrow representing the vector.
        &#34;&#34;&#34;
        if not isinstance(vector, Arrow):
            vector = Vector(vector, color=color, **kwargs)
        if animate:
            self.play(GrowArrow(vector))
        self.add(vector)
        return vector

    def write_vector_coordinates(self, vector, **kwargs):
        &#34;&#34;&#34;
        Returns a column matrix indicating the vector coordinates,
        after writing them to the screen.

        Parameters
        ----------
        vector (Arrow)
            The arrow representing the vector.
        
        **kwargs
            Any valid keyword arguments of matrix.vector_coordinate_label
            
            integer_labels (True) : Whether or not to round the coordinates
                                    to integers.
            n_dim (2) : The number of dimensions of the vector.
            color (WHITE) : The color of the label.

        Returns
        -------
        Matrix
            The column matrix representing the vector.
        &#34;&#34;&#34;
        coords = vector_coordinate_label(vector, **kwargs)
        self.play(Write(coords))
        return coords

    def get_basis_vectors(self, i_hat_color=X_COLOR, j_hat_color=Y_COLOR):
        &#34;&#34;&#34;
        Returns a VGroup of the Basis Vectors (1,0) and (0,1)

        Parameters
        ----------
        i_hat_color (str)
            The hex colour to use for the basis vector in the x direction
        
        j_hat_color (str)
            The hex colour to use for the basis vector in the y direction
        
        Returns
        -------
        VGroup
            VGroup of the Vector Mobjects representing the basis vectors.
        &#34;&#34;&#34;
        return VGroup(*[
            Vector(
                vect,
                color=color,
                stroke_width=self.basis_vector_stroke_width
            )
            for vect, color in [
                ([1, 0], i_hat_color),
                ([0, 1], j_hat_color)
            ]
        ])

    def get_basis_vector_labels(self, **kwargs):
        &#34;&#34;&#34;
        Returns naming labels for the basis vectors.

        Parameters
        ----------
        **kwargs
            Any valid keyword arguments of get_vector_label:
                vector,
                label (str,TexMobject)
                at_tip (bool=False),
                direction (str=&#34;left&#34;),
                rotate (bool),
                color (str),
                label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),
        &#34;&#34;&#34;
        i_hat, j_hat = self.get_basis_vectors()
        return VGroup(*[
            self.get_vector_label(
                vect, label, color=color,
                label_scale_factor=1,
                **kwargs
            )
            for vect, label, color in [
                (i_hat, &#34;\\hat{\\imath}&#34;, X_COLOR),
                (j_hat, &#34;\\hat{\\jmath}&#34;, Y_COLOR),
            ]
        ])

    def get_vector_label(self, vector, label,
                         at_tip=False,
                         direction=&#34;left&#34;,
                         rotate=False,
                         color=None,
                         label_scale_factor=VECTOR_LABEL_SCALE_FACTOR):
        &#34;&#34;&#34;
        Returns naming labels for the passed vector.

        Parameters
        ----------
        vector
            Vector Object for which to get the label.
        at_tip (bool)
            Whether or not to place the label at the tip of the vector.
        direction (str=&#34;left&#34;)
            If the label should be on the &#34;left&#34; or right of the vector.
        rotate (bool=False)
            Whether or not to rotate it to align it with the vector.
        color (str)
            The color to give the label.
        label_scale_factor (Union[int,float])
            How much to scale the label by.
        
        Returns
        -------
        TexMobject
            The TexMobject of the label.
        &#34;&#34;&#34;
        if not isinstance(label, TexMobject):
            if len(label) == 1:
                label = &#34;\\vec{\\textbf{%s}}&#34; % label
            label = TexMobject(label)
            if color is None:
                color = vector.get_color()
            label.set_color(color)
        label.scale(label_scale_factor)
        label.add_background_rectangle()

        if at_tip:
            vect = vector.get_vector()
            vect /= get_norm(vect)
            label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)
        else:
            angle = vector.get_angle()
            if not rotate:
                label.rotate(-angle, about_point=ORIGIN)
            if direction == &#34;left&#34;:
                label.shift(-label.get_bottom() + 0.1 * UP)
            else:
                label.shift(-label.get_top() + 0.1 * DOWN)
            label.rotate(angle, about_point=ORIGIN)
            label.shift((vector.get_end() - vector.get_start()) / 2)
        return label

    def label_vector(self, vector, label, animate=True, **kwargs):
        &#34;&#34;&#34;
        Shortcut method for creating, and animating the addition of
        a label for the vector.

        Parameters
        ----------
        vector (Vector)
            The vector for which the label must be added.
        label (TexMobject,str)
            The TexMobject/string of the label.
        animate (bool=True)
            Whether or not to animate the labelling w/ Write
        **kwargs
            Any valid keyword argument of get_vector_label
        
        Returns
        -------
        TexMobject
            The TexMobject of the label.
        &#34;&#34;&#34;
        label = self.get_vector_label(vector, label, **kwargs)
        if animate:
            self.play(Write(label, run_time=1))
        self.add(label)
        return label

    def position_x_coordinate(self, x_coord, x_line, vector): #TODO Write DocStrings for this.
        x_coord.next_to(x_line, -np.sign(vector[1]) * UP)
        x_coord.set_color(X_COLOR)
        return x_coord

    def position_y_coordinate(self, y_coord, y_line, vector): #TODO Write DocStrings for this.
        y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)
        y_coord.set_color(Y_COLOR)
        return y_coord

    def coords_to_vector(self, vector, coords_start=2 * RIGHT + 2 * UP, clean_up=True):
        &#34;&#34;&#34;
        This method writes the vector as a column matrix (henceforth called the label),
        takes the values in it one by one, and form the corresponding
        lines that make up the x and y components of the vector. Then, an
        Vector() based vector is created between the lines on the Screen.

        Parameters
        ----------
        vector Union(np.ndarray, list, tuple)
            The vector to show.
        
        coords_start Union(np.ndarray,list,tuple)
            The starting point of the location of 
            the label of the vector that shows it 
            numerically.
            Defaults to 2 * RIGHT + 2 * UP or (2,2)
        
        clean_up (bool=True)
            Whether or not to remove whatever
            this method did after it&#39;s done.

        &#34;&#34;&#34;
        starting_mobjects = list(self.mobjects)
        array = Matrix(vector)
        array.shift(coords_start)
        arrow = Vector(vector)
        x_line = Line(ORIGIN, vector[0] * RIGHT)
        y_line = Line(x_line.get_end(), arrow.get_end())
        x_line.set_color(X_COLOR)
        y_line.set_color(Y_COLOR)
        x_coord, y_coord = array.get_mob_matrix().flatten()

        self.play(Write(array, run_time=1))
        self.wait()
        self.play(ApplyFunction(
            lambda x: self.position_x_coordinate(x, x_line, vector),
            x_coord
        ))
        self.play(ShowCreation(x_line))
        self.play(
            ApplyFunction(
                lambda y: self.position_y_coordinate(y, y_line, vector),
                y_coord
            ),
            FadeOut(array.get_brackets())
        )
        y_coord, brackets = self.get_mobjects_from_last_animation()
        self.play(ShowCreation(y_line))
        self.play(ShowCreation(arrow))
        self.wait()
        if clean_up:
            self.clear()
            self.add(*starting_mobjects)

    def vector_to_coords(self, vector, integer_labels=True, clean_up=True):
        &#34;&#34;&#34;
        This method displays vector as a Vector() based vector, and then shows 
        the corresponding lines that make up the x and y components of the vector. 
        Then, a column matrix (henceforth called the label) is created near the 
        head of the Vector.

        Parameters
        ----------
        vector Union(np.ndarray, list, tuple)
            The vector to show.
        
        integer_label (bool=True)
            Whether or not to round the value displayed.
            in the vector&#39;s label to the nearest integer
        
        clean_up (bool=True)
            Whether or not to remove whatever
            this method did after it&#39;s done.

        &#34;&#34;&#34;
        starting_mobjects = list(self.mobjects)
        show_creation = False
        if isinstance(vector, Arrow):
            arrow = vector
            vector = arrow.get_end()[:2]
        else:
            arrow = Vector(vector)
            show_creation = True
        array = vector_coordinate_label(arrow, integer_labels=integer_labels)
        x_line = Line(ORIGIN, vector[0] * RIGHT)
        y_line = Line(x_line.get_end(), arrow.get_end())
        x_line.set_color(X_COLOR)
        y_line.set_color(Y_COLOR)
        x_coord, y_coord = array.get_mob_matrix().flatten()
        x_coord_start = self.position_x_coordinate(
            x_coord.copy(), x_line, vector
        )
        y_coord_start = self.position_y_coordinate(
            y_coord.copy(), y_line, vector
        )
        brackets = array.get_brackets()

        if show_creation:
            self.play(ShowCreation(arrow))
        self.play(
            ShowCreation(x_line),
            Write(x_coord_start),
            run_time=1
        )
        self.play(
            ShowCreation(y_line),
            Write(y_coord_start),
            run_time=1
        )
        self.wait()
        self.play(
            Transform(x_coord_start, x_coord, lag_ratio=0),
            Transform(y_coord_start, y_coord, lag_ratio=0),
            Write(brackets, run_time=1),
        )
        self.wait()

        self.remove(x_coord_start, y_coord_start, brackets)
        self.add(array)
        if clean_up:
            self.clear()
            self.add(*starting_mobjects)
        return array, x_line, y_line

    def show_ghost_movement(self, vector):
        &#34;&#34;&#34;
        This method plays an animation that partially shows the entire plane moving
        in the direction of a particular vector. This is useful when you wish to 
        convey the idea of mentally moving the entire plane in a direction, without
        actually moving the plane.

        Parameters
        ----------
        vector (Union[Arrow, list, tuple, np.ndarray])
            The vector which indicates the direction of movement.
        &#34;&#34;&#34;
        if isinstance(vector, Arrow):
            vector = vector.get_end() - vector.get_start()
        elif len(vector) == 2:
            vector = np.append(np.array(vector), 0.0)
        x_max = int(FRAME_X_RADIUS + abs(vector[0]))
        y_max = int(FRAME_Y_RADIUS + abs(vector[1]))
        dots = VMobject(*[
            Dot(x * RIGHT + y * UP)
            for x in range(-x_max, x_max)
            for y in range(-y_max, y_max)
        ])
        dots.set_fill(BLACK, opacity=0)
        dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)
        dots_end = dots.copy().shift(vector)

        self.play(Transform(
            dots, dots_halfway, rate_func=rush_into
        ))
        self.play(Transform(
            dots, dots_end, rate_func=rush_from
        ))
        self.remove(dots)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.scene.scene.Scene" href="scene.html#manimlib.scene.scene.Scene">Scene</a></li>
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.scene.vector_space_scene.LinearTransformationScene" href="#manimlib.scene.vector_space_scene.LinearTransformationScene">LinearTransformationScene</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.scene.vector_space_scene.VectorScene.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.scene.vector_space_scene.VectorScene.add_axes"><code class="name flex">
<span>def <span class="ident">add_axes</span></span>(<span>self, animate=False, color='#FFFFFF', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a pair of Axes to the Scene.</p>
<h2 id="parameters">Parameters</h2>
<p>animate (bool=False)
Whether or not to animate the addition of the axes through ShowCreation.
color (str)
The color of the axes. Defaults to WHITE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_axes(self, animate=False, color=WHITE, **kwargs):
    &#34;&#34;&#34;
    Adds a pair of Axes to the Scene.

    Parameters
    ----------
    animate (bool=False)
        Whether or not to animate the addition of the axes through ShowCreation.
    color (str)
        The color of the axes. Defaults to WHITE.
    &#34;&#34;&#34;
    axes = Axes(color=color, tick_frequency=1)
    if animate:
        self.play(ShowCreation(axes))
    self.add(axes)
    return axes</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.add_plane"><code class="name flex">
<span>def <span class="ident">add_plane</span></span>(<span>self, animate=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a NumberPlane object to the background.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>animate</code></strong> :&ensp;<code>(bool=False)</code></dt>
<dd>Whether or not to animate the addition of the plane via ShowCreation.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword arguments accepted by NumberPlane.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NumberPlane</code></dt>
<dd>The NumberPlane object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_plane(self, animate=False, **kwargs):
    &#34;&#34;&#34;
    Adds a NumberPlane object to the background.

    Parameters
    ----------
    animate : (bool=False)
        Whether or not to animate the addition of the plane via ShowCreation.
    **kwargs
        Any valid keyword arguments accepted by NumberPlane.
    
    Returns
    -------
    NumberPlane
        The NumberPlane object.
    &#34;&#34;&#34;
    plane = NumberPlane(**kwargs)
    if animate:
        self.play(ShowCreation(plane, lag_ratio=0.5))
    self.add(plane)
    return plane</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.add_vector"><code class="name flex">
<span>def <span class="ident">add_vector</span></span>(<span>self, vector, color='#FFFF00', animate=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Vector after adding it to the Plane.</p>
<h2 id="parameters">Parameters</h2>
<p>vector Union(Arrow,list,tuple,np.ndarray)
It can be a pre-made graphical vector, or the
coordinates of one.</p>
<p>color (str)
The string of the hex color of the vector.
This is only taken into consideration if
'vector' is not an Arrow. Defaults to YELLOW.</p>
<p>animate (bool=True)
Whether or not to animate the addition of the vector
by using GrowArrow</p>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of Arrow.
These are only considered if vector is not
an Arrow.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Arrow</code></dt>
<dd>The arrow representing the vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vector(self, vector, color=YELLOW, animate=True, **kwargs):
    &#34;&#34;&#34;
    Returns the Vector after adding it to the Plane.

    Parameters
    ----------
    vector Union(Arrow,list,tuple,np.ndarray)
        It can be a pre-made graphical vector, or the
        coordinates of one.
    
    color (str)
        The string of the hex color of the vector.
        This is only taken into consideration if
        &#39;vector&#39; is not an Arrow. Defaults to YELLOW.
    
    animate (bool=True)
        Whether or not to animate the addition of the vector
        by using GrowArrow
    
    **kwargs
        Any valid keyword argument of Arrow.
        These are only considered if vector is not
        an Arrow.
    
    Returns
    -------
    Arrow
        The arrow representing the vector.
    &#34;&#34;&#34;
    if not isinstance(vector, Arrow):
        vector = Vector(vector, color=color, **kwargs)
    if animate:
        self.play(GrowArrow(vector))
    self.add(vector)
    return vector</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.coords_to_vector"><code class="name flex">
<span>def <span class="ident">coords_to_vector</span></span>(<span>self, vector, coords_start=array([2., 2., 0.]), clean_up=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This method writes the vector as a column matrix (henceforth called the label),
takes the values in it one by one, and form the corresponding
lines that make up the x and y components of the vector. Then, an
Vector() based vector is created between the lines on the Screen.</p>
<h2 id="parameters">Parameters</h2>
<p>vector Union(np.ndarray, list, tuple)
The vector to show.</p>
<p>coords_start Union(np.ndarray,list,tuple)
The starting point of the location of
the label of the vector that shows it
numerically.
Defaults to 2 * RIGHT + 2 * UP or (2,2)</p>
<p>clean_up (bool=True)
Whether or not to remove whatever
this method did after it's done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coords_to_vector(self, vector, coords_start=2 * RIGHT + 2 * UP, clean_up=True):
    &#34;&#34;&#34;
    This method writes the vector as a column matrix (henceforth called the label),
    takes the values in it one by one, and form the corresponding
    lines that make up the x and y components of the vector. Then, an
    Vector() based vector is created between the lines on the Screen.

    Parameters
    ----------
    vector Union(np.ndarray, list, tuple)
        The vector to show.
    
    coords_start Union(np.ndarray,list,tuple)
        The starting point of the location of 
        the label of the vector that shows it 
        numerically.
        Defaults to 2 * RIGHT + 2 * UP or (2,2)
    
    clean_up (bool=True)
        Whether or not to remove whatever
        this method did after it&#39;s done.

    &#34;&#34;&#34;
    starting_mobjects = list(self.mobjects)
    array = Matrix(vector)
    array.shift(coords_start)
    arrow = Vector(vector)
    x_line = Line(ORIGIN, vector[0] * RIGHT)
    y_line = Line(x_line.get_end(), arrow.get_end())
    x_line.set_color(X_COLOR)
    y_line.set_color(Y_COLOR)
    x_coord, y_coord = array.get_mob_matrix().flatten()

    self.play(Write(array, run_time=1))
    self.wait()
    self.play(ApplyFunction(
        lambda x: self.position_x_coordinate(x, x_line, vector),
        x_coord
    ))
    self.play(ShowCreation(x_line))
    self.play(
        ApplyFunction(
            lambda y: self.position_y_coordinate(y, y_line, vector),
            y_coord
        ),
        FadeOut(array.get_brackets())
    )
    y_coord, brackets = self.get_mobjects_from_last_animation()
    self.play(ShowCreation(y_line))
    self.play(ShowCreation(arrow))
    self.wait()
    if clean_up:
        self.clear()
        self.add(*starting_mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.get_basis_vector_labels"><code class="name flex">
<span>def <span class="ident">get_basis_vector_labels</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns naming labels for the basis vectors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword arguments of get_vector_label:
vector,
label (str,TexMobject)
at_tip (bool=False),
direction (str="left"),
rotate (bool),
color (str),
label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_basis_vector_labels(self, **kwargs):
    &#34;&#34;&#34;
    Returns naming labels for the basis vectors.

    Parameters
    ----------
    **kwargs
        Any valid keyword arguments of get_vector_label:
            vector,
            label (str,TexMobject)
            at_tip (bool=False),
            direction (str=&#34;left&#34;),
            rotate (bool),
            color (str),
            label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),
    &#34;&#34;&#34;
    i_hat, j_hat = self.get_basis_vectors()
    return VGroup(*[
        self.get_vector_label(
            vect, label, color=color,
            label_scale_factor=1,
            **kwargs
        )
        for vect, label, color in [
            (i_hat, &#34;\\hat{\\imath}&#34;, X_COLOR),
            (j_hat, &#34;\\hat{\\jmath}&#34;, Y_COLOR),
        ]
    ])</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.get_basis_vectors"><code class="name flex">
<span>def <span class="ident">get_basis_vectors</span></span>(<span>self, i_hat_color='#83C167', j_hat_color='#FC6255')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a VGroup of the Basis Vectors (1,0) and (0,1)</p>
<h2 id="parameters">Parameters</h2>
<p>i_hat_color (str)
The hex colour to use for the basis vector in the x direction</p>
<p>j_hat_color (str)
The hex colour to use for the basis vector in the y direction</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>VGroup</code></dt>
<dd>VGroup of the Vector Mobjects representing the basis vectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_basis_vectors(self, i_hat_color=X_COLOR, j_hat_color=Y_COLOR):
    &#34;&#34;&#34;
    Returns a VGroup of the Basis Vectors (1,0) and (0,1)

    Parameters
    ----------
    i_hat_color (str)
        The hex colour to use for the basis vector in the x direction
    
    j_hat_color (str)
        The hex colour to use for the basis vector in the y direction
    
    Returns
    -------
    VGroup
        VGroup of the Vector Mobjects representing the basis vectors.
    &#34;&#34;&#34;
    return VGroup(*[
        Vector(
            vect,
            color=color,
            stroke_width=self.basis_vector_stroke_width
        )
        for vect, color in [
            ([1, 0], i_hat_color),
            ([0, 1], j_hat_color)
        ]
    ])</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.get_vector"><code class="name flex">
<span>def <span class="ident">get_vector</span></span>(<span>self, numerical_vector, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an arrow on the Plane given an input numerical vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>numerical_vector</code></strong> :&ensp;<code>Union(np.ndarray, list, tuple)</code></dt>
<dd>The Vector to plot.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of Arrow.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Arrow</code></dt>
<dd>The Arrow representing the Vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vector(self, numerical_vector, **kwargs):
    &#34;&#34;&#34;
    Returns an arrow on the Plane given an input numerical vector.
    
    Parameters
    ----------
    numerical_vector : Union(np.ndarray, list, tuple)
        The Vector to plot.
    **kwargs
        Any valid keyword argument of Arrow.
    
    Returns
    -------
    Arrow
        The Arrow representing the Vector.
    &#34;&#34;&#34;
    return Arrow(
        self.plane.coords_to_point(0, 0),
        self.plane.coords_to_point(*numerical_vector[:2]),
        buff=0,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.get_vector_label"><code class="name flex">
<span>def <span class="ident">get_vector_label</span></span>(<span>self, vector, label, at_tip=False, direction='left', rotate=False, color=None, label_scale_factor=0.8)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns naming labels for the passed vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vector</code></strong></dt>
<dd>Vector Object for which to get the label.</dd>
</dl>
<p>at_tip (bool)
Whether or not to place the label at the tip of the vector.
direction (str="left")
If the label should be on the "left" or right of the vector.
rotate (bool=False)
Whether or not to rotate it to align it with the vector.
color (str)
The color to give the label.
label_scale_factor (Union[int,float])
How much to scale the label by.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TexMobject</code></dt>
<dd>The TexMobject of the label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vector_label(self, vector, label,
                     at_tip=False,
                     direction=&#34;left&#34;,
                     rotate=False,
                     color=None,
                     label_scale_factor=VECTOR_LABEL_SCALE_FACTOR):
    &#34;&#34;&#34;
    Returns naming labels for the passed vector.

    Parameters
    ----------
    vector
        Vector Object for which to get the label.
    at_tip (bool)
        Whether or not to place the label at the tip of the vector.
    direction (str=&#34;left&#34;)
        If the label should be on the &#34;left&#34; or right of the vector.
    rotate (bool=False)
        Whether or not to rotate it to align it with the vector.
    color (str)
        The color to give the label.
    label_scale_factor (Union[int,float])
        How much to scale the label by.
    
    Returns
    -------
    TexMobject
        The TexMobject of the label.
    &#34;&#34;&#34;
    if not isinstance(label, TexMobject):
        if len(label) == 1:
            label = &#34;\\vec{\\textbf{%s}}&#34; % label
        label = TexMobject(label)
        if color is None:
            color = vector.get_color()
        label.set_color(color)
    label.scale(label_scale_factor)
    label.add_background_rectangle()

    if at_tip:
        vect = vector.get_vector()
        vect /= get_norm(vect)
        label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)
    else:
        angle = vector.get_angle()
        if not rotate:
            label.rotate(-angle, about_point=ORIGIN)
        if direction == &#34;left&#34;:
            label.shift(-label.get_bottom() + 0.1 * UP)
        else:
            label.shift(-label.get_top() + 0.1 * DOWN)
        label.rotate(angle, about_point=ORIGIN)
        label.shift((vector.get_end() - vector.get_start()) / 2)
    return label</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.label_vector"><code class="name flex">
<span>def <span class="ident">label_vector</span></span>(<span>self, vector, label, animate=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut method for creating, and animating the addition of
a label for the vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>vector (Vector)</dt>
<dt>The vector for which the label must be added.</dt>
<dt>label (TexMobject,str)</dt>
<dt>The TexMobject/string of the label.</dt>
<dt>animate (bool=True)</dt>
<dt>Whether or not to animate the labelling w/ Write</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any valid keyword argument of get_vector_label</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TexMobject</code></dt>
<dd>The TexMobject of the label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label_vector(self, vector, label, animate=True, **kwargs):
    &#34;&#34;&#34;
    Shortcut method for creating, and animating the addition of
    a label for the vector.

    Parameters
    ----------
    vector (Vector)
        The vector for which the label must be added.
    label (TexMobject,str)
        The TexMobject/string of the label.
    animate (bool=True)
        Whether or not to animate the labelling w/ Write
    **kwargs
        Any valid keyword argument of get_vector_label
    
    Returns
    -------
    TexMobject
        The TexMobject of the label.
    &#34;&#34;&#34;
    label = self.get_vector_label(vector, label, **kwargs)
    if animate:
        self.play(Write(label, run_time=1))
    self.add(label)
    return label</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.lock_in_faded_grid"><code class="name flex">
<span>def <span class="ident">lock_in_faded_grid</span></span>(<span>self, dimness=0.7, axes_dimness=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>This method freezes the NumberPlane and Axes that were already
in the background, and adds new, manipulatable ones to the foreground.</p>
<h2 id="parameters">Parameters</h2>
<p>dimness (Union[int,float=0.7])
The required dimness of the NumberPlane</p>
<p>axes_dimness (Union[int,float=0.5])
The required dimness of the Axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lock_in_faded_grid(self, dimness=0.7, axes_dimness=0.5):
    &#34;&#34;&#34;
    This method freezes the NumberPlane and Axes that were already
    in the background, and adds new, manipulatable ones to the foreground.
    
    Parameters
    ----------
    dimness (Union[int,float=0.7])
        The required dimness of the NumberPlane
    
    axes_dimness (Union[int,float=0.5])
        The required dimness of the Axes.
    &#34;&#34;&#34;
    plane = self.add_plane()
    axes = plane.get_axes()
    plane.fade(dimness)
    axes.set_color(WHITE)
    axes.fade(axes_dimness)
    self.add(axes)
    self.freeze_background()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.position_x_coordinate"><code class="name flex">
<span>def <span class="ident">position_x_coordinate</span></span>(<span>self, x_coord, x_line, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_x_coordinate(self, x_coord, x_line, vector): #TODO Write DocStrings for this.
    x_coord.next_to(x_line, -np.sign(vector[1]) * UP)
    x_coord.set_color(X_COLOR)
    return x_coord</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.position_y_coordinate"><code class="name flex">
<span>def <span class="ident">position_y_coordinate</span></span>(<span>self, y_coord, y_line, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_y_coordinate(self, y_coord, y_line, vector): #TODO Write DocStrings for this.
    y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)
    y_coord.set_color(Y_COLOR)
    return y_coord</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.show_ghost_movement"><code class="name flex">
<span>def <span class="ident">show_ghost_movement</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<div class="desc"><p>This method plays an animation that partially shows the entire plane moving
in the direction of a particular vector. This is useful when you wish to
convey the idea of mentally moving the entire plane in a direction, without
actually moving the plane.</p>
<h2 id="parameters">Parameters</h2>
<p>vector (Union[Arrow, list, tuple, np.ndarray])
The vector which indicates the direction of movement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_ghost_movement(self, vector):
    &#34;&#34;&#34;
    This method plays an animation that partially shows the entire plane moving
    in the direction of a particular vector. This is useful when you wish to 
    convey the idea of mentally moving the entire plane in a direction, without
    actually moving the plane.

    Parameters
    ----------
    vector (Union[Arrow, list, tuple, np.ndarray])
        The vector which indicates the direction of movement.
    &#34;&#34;&#34;
    if isinstance(vector, Arrow):
        vector = vector.get_end() - vector.get_start()
    elif len(vector) == 2:
        vector = np.append(np.array(vector), 0.0)
    x_max = int(FRAME_X_RADIUS + abs(vector[0]))
    y_max = int(FRAME_Y_RADIUS + abs(vector[1]))
    dots = VMobject(*[
        Dot(x * RIGHT + y * UP)
        for x in range(-x_max, x_max)
        for y in range(-y_max, y_max)
    ])
    dots.set_fill(BLACK, opacity=0)
    dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)
    dots_end = dots.copy().shift(vector)

    self.play(Transform(
        dots, dots_halfway, rate_func=rush_into
    ))
    self.play(Transform(
        dots, dots_end, rate_func=rush_from
    ))
    self.remove(dots)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.vector_to_coords"><code class="name flex">
<span>def <span class="ident">vector_to_coords</span></span>(<span>self, vector, integer_labels=True, clean_up=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This method displays vector as a Vector() based vector, and then shows
the corresponding lines that make up the x and y components of the vector.
Then, a column matrix (henceforth called the label) is created near the
head of the Vector.</p>
<h2 id="parameters">Parameters</h2>
<p>vector Union(np.ndarray, list, tuple)
The vector to show.</p>
<p>integer_label (bool=True)
Whether or not to round the value displayed.
in the vector's label to the nearest integer</p>
<p>clean_up (bool=True)
Whether or not to remove whatever
this method did after it's done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_to_coords(self, vector, integer_labels=True, clean_up=True):
    &#34;&#34;&#34;
    This method displays vector as a Vector() based vector, and then shows 
    the corresponding lines that make up the x and y components of the vector. 
    Then, a column matrix (henceforth called the label) is created near the 
    head of the Vector.

    Parameters
    ----------
    vector Union(np.ndarray, list, tuple)
        The vector to show.
    
    integer_label (bool=True)
        Whether or not to round the value displayed.
        in the vector&#39;s label to the nearest integer
    
    clean_up (bool=True)
        Whether or not to remove whatever
        this method did after it&#39;s done.

    &#34;&#34;&#34;
    starting_mobjects = list(self.mobjects)
    show_creation = False
    if isinstance(vector, Arrow):
        arrow = vector
        vector = arrow.get_end()[:2]
    else:
        arrow = Vector(vector)
        show_creation = True
    array = vector_coordinate_label(arrow, integer_labels=integer_labels)
    x_line = Line(ORIGIN, vector[0] * RIGHT)
    y_line = Line(x_line.get_end(), arrow.get_end())
    x_line.set_color(X_COLOR)
    y_line.set_color(Y_COLOR)
    x_coord, y_coord = array.get_mob_matrix().flatten()
    x_coord_start = self.position_x_coordinate(
        x_coord.copy(), x_line, vector
    )
    y_coord_start = self.position_y_coordinate(
        y_coord.copy(), y_line, vector
    )
    brackets = array.get_brackets()

    if show_creation:
        self.play(ShowCreation(arrow))
    self.play(
        ShowCreation(x_line),
        Write(x_coord_start),
        run_time=1
    )
    self.play(
        ShowCreation(y_line),
        Write(y_coord_start),
        run_time=1
    )
    self.wait()
    self.play(
        Transform(x_coord_start, x_coord, lag_ratio=0),
        Transform(y_coord_start, y_coord, lag_ratio=0),
        Write(brackets, run_time=1),
    )
    self.wait()

    self.remove(x_coord_start, y_coord_start, brackets)
    self.add(array)
    if clean_up:
        self.clear()
        self.add(*starting_mobjects)
    return array, x_line, y_line</code></pre>
</details>
</dd>
<dt id="manimlib.scene.vector_space_scene.VectorScene.write_vector_coordinates"><code class="name flex">
<span>def <span class="ident">write_vector_coordinates</span></span>(<span>self, vector, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a column matrix indicating the vector coordinates,
after writing them to the screen.</p>
<h2 id="parameters">Parameters</h2>
<p>vector (Arrow)
The arrow representing the vector.</p>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Any valid keyword arguments of matrix.vector_coordinate_label</p>
<p>integer_labels (True) : Whether or not to round the coordinates
to integers.
n_dim (2) : The number of dimensions of the vector.
color (WHITE) : The color of the label.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Matrix</code></dt>
<dd>The column matrix representing the vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_vector_coordinates(self, vector, **kwargs):
    &#34;&#34;&#34;
    Returns a column matrix indicating the vector coordinates,
    after writing them to the screen.

    Parameters
    ----------
    vector (Arrow)
        The arrow representing the vector.
    
    **kwargs
        Any valid keyword arguments of matrix.vector_coordinate_label
        
        integer_labels (True) : Whether or not to round the coordinates
                                to integers.
        n_dim (2) : The number of dimensions of the vector.
        color (WHITE) : The color of the label.

    Returns
    -------
    Matrix
        The column matrix representing the vector.
    &#34;&#34;&#34;
    coords = vector_coordinate_label(vector, **kwargs)
    self.play(Write(coords))
    return coords</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="manimlib.scene.scene.Scene" href="scene.html#manimlib.scene.scene.Scene">Scene</a></b></code>:
<ul class="hlist">
<li><code><a title="manimlib.scene.scene.Scene.add" href="scene.html#manimlib.scene.scene.Scene.add">add</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_foreground_mobject" href="scene.html#manimlib.scene.scene.Scene.add_foreground_mobject">add_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_foreground_mobjects" href="scene.html#manimlib.scene.scene.Scene.add_foreground_mobjects">add_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_frames" href="scene.html#manimlib.scene.scene.Scene.add_frames">add_frames</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_mobjects_among" href="scene.html#manimlib.scene.scene.Scene.add_mobjects_among">add_mobjects_among</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_sound" href="scene.html#manimlib.scene.scene.Scene.add_sound">add_sound</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.begin_animations" href="scene.html#manimlib.scene.scene.Scene.begin_animations">begin_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.bring_to_back" href="scene.html#manimlib.scene.scene.Scene.bring_to_back">bring_to_back</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.bring_to_front" href="scene.html#manimlib.scene.scene.Scene.bring_to_front">bring_to_front</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.capture_mobjects_in_camera" href="scene.html#manimlib.scene.scene.Scene.capture_mobjects_in_camera">capture_mobjects_in_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.clean_up_animations" href="scene.html#manimlib.scene.scene.Scene.clean_up_animations">clean_up_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.clear" href="scene.html#manimlib.scene.scene.Scene.clear">clear</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.compile_play_args_to_animation_list" href="scene.html#manimlib.scene.scene.Scene.compile_play_args_to_animation_list">compile_play_args_to_animation_list</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.construct" href="scene.html#manimlib.scene.scene.Scene.construct">construct</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.finish_animations" href="scene.html#manimlib.scene.scene.Scene.finish_animations">finish_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.force_skipping" href="scene.html#manimlib.scene.scene.Scene.force_skipping">force_skipping</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_animation_time_progression" href="scene.html#manimlib.scene.scene.Scene.get_animation_time_progression">get_animation_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_attrs" href="scene.html#manimlib.scene.scene.Scene.get_attrs">get_attrs</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_frame" href="scene.html#manimlib.scene.scene.Scene.get_frame">get_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_image" href="scene.html#manimlib.scene.scene.Scene.get_image">get_image</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobject_copies" href="scene.html#manimlib.scene.scene.Scene.get_mobject_copies">get_mobject_copies</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobject_family_members" href="scene.html#manimlib.scene.scene.Scene.get_mobject_family_members">get_mobject_family_members</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobjects" href="scene.html#manimlib.scene.scene.Scene.get_mobjects">get_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobjects_from_last_animation" href="scene.html#manimlib.scene.scene.Scene.get_mobjects_from_last_animation">get_mobjects_from_last_animation</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_moving_mobjects" href="scene.html#manimlib.scene.scene.Scene.get_moving_mobjects">get_moving_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_restructured_mobject_list" href="scene.html#manimlib.scene.scene.Scene.get_restructured_mobject_list">get_restructured_mobject_list</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_run_time" href="scene.html#manimlib.scene.scene.Scene.get_run_time">get_run_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_time" href="scene.html#manimlib.scene.scene.Scene.get_time">get_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_time_progression" href="scene.html#manimlib.scene.scene.Scene.get_time_progression">get_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_top_level_mobjects" href="scene.html#manimlib.scene.scene.Scene.get_top_level_mobjects">get_top_level_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_wait_time_progression" href="scene.html#manimlib.scene.scene.Scene.get_wait_time_progression">get_wait_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.handle_play_like_call" href="scene.html#manimlib.scene.scene.Scene.handle_play_like_call">handle_play_like_call</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.idle_stream" href="scene.html#manimlib.scene.scene.Scene.idle_stream">idle_stream</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.increment_time" href="scene.html#manimlib.scene.scene.Scene.increment_time">increment_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.print_end_message" href="scene.html#manimlib.scene.scene.Scene.print_end_message">print_end_message</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.progress_through_animations" href="scene.html#manimlib.scene.scene.Scene.progress_through_animations">progress_through_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove" href="scene.html#manimlib.scene.scene.Scene.remove">remove</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove_foreground_mobject" href="scene.html#manimlib.scene.scene.Scene.remove_foreground_mobject">remove_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove_foreground_mobjects" href="scene.html#manimlib.scene.scene.Scene.remove_foreground_mobjects">remove_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.reset_camera" href="scene.html#manimlib.scene.scene.Scene.reset_camera">reset_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.restructure_mobjects" href="scene.html#manimlib.scene.scene.Scene.restructure_mobjects">restructure_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.revert_to_original_skipping_status" href="scene.html#manimlib.scene.scene.Scene.revert_to_original_skipping_status">revert_to_original_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera" href="scene.html#manimlib.scene.scene.Scene.set_camera">set_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera_background" href="scene.html#manimlib.scene.scene.Scene.set_camera_background">set_camera_background</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera_pixel_array" href="scene.html#manimlib.scene.scene.Scene.set_camera_pixel_array">set_camera_pixel_array</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_variables_as_attrs" href="scene.html#manimlib.scene.scene.Scene.set_variables_as_attrs">set_variables_as_attrs</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.setup" href="scene.html#manimlib.scene.scene.Scene.setup">setup</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.should_update_mobjects" href="scene.html#manimlib.scene.scene.Scene.should_update_mobjects">should_update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.show_frame" href="scene.html#manimlib.scene.scene.Scene.show_frame">show_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.tear_down" href="scene.html#manimlib.scene.scene.Scene.tear_down">tear_down</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_frame" href="scene.html#manimlib.scene.scene.Scene.update_frame">update_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_mobjects" href="scene.html#manimlib.scene.scene.Scene.update_mobjects">update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_skipping_status" href="scene.html#manimlib.scene.scene.Scene.update_skipping_status">update_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.wait_until" href="scene.html#manimlib.scene.scene.Scene.wait_until">wait_until</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.scene" href="index.html">manimlib.scene</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene" href="#manimlib.scene.vector_space_scene.LinearTransformationScene">LinearTransformationScene</a></code></h4>
<ul class="">
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.CONFIG" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_background_mobject" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_background_mobject">add_background_mobject</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_foreground_mobject" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_foreground_mobject">add_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_moving_mobject" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_moving_mobject">add_moving_mobject</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_special_mobjects" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_special_mobjects">add_special_mobjects</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_title" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_title">add_title</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_transformable_label" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_transformable_label">add_transformable_label</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_transformable_mobject" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_transformable_mobject">add_transformable_mobject</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_unit_square" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_unit_square">add_unit_square</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.add_vector" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.add_vector">add_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_function" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.apply_function">apply_function</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_inverse" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.apply_inverse">apply_inverse</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_inverse_transpose" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.apply_inverse_transpose">apply_inverse_transpose</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_matrix" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.apply_matrix">apply_matrix</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_nonlinear_transformation" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.apply_nonlinear_transformation">apply_nonlinear_transformation</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.apply_transposed_matrix" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.apply_transposed_matrix">apply_transposed_matrix</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.get_matrix_transformation" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.get_matrix_transformation">get_matrix_transformation</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.get_moving_mobject_movement" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.get_moving_mobject_movement">get_moving_mobject_movement</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.get_piece_movement" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.get_piece_movement">get_piece_movement</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.get_transformable_label_movement" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.get_transformable_label_movement">get_transformable_label_movement</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.get_transposed_matrix_transformation" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.get_transposed_matrix_transformation">get_transposed_matrix_transformation</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.get_unit_square" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.get_unit_square">get_unit_square</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.get_vector_movement" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.get_vector_movement">get_vector_movement</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.LinearTransformationScene.write_vector_coordinates" href="#manimlib.scene.vector_space_scene.LinearTransformationScene.write_vector_coordinates">write_vector_coordinates</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="manimlib.scene.vector_space_scene.VectorScene" href="#manimlib.scene.vector_space_scene.VectorScene">VectorScene</a></code></h4>
<ul class="">
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.CONFIG" href="#manimlib.scene.vector_space_scene.VectorScene.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_axes" href="#manimlib.scene.vector_space_scene.VectorScene.add_axes">add_axes</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_plane" href="#manimlib.scene.vector_space_scene.VectorScene.add_plane">add_plane</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.add_vector" href="#manimlib.scene.vector_space_scene.VectorScene.add_vector">add_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.coords_to_vector" href="#manimlib.scene.vector_space_scene.VectorScene.coords_to_vector">coords_to_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_basis_vector_labels" href="#manimlib.scene.vector_space_scene.VectorScene.get_basis_vector_labels">get_basis_vector_labels</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_basis_vectors" href="#manimlib.scene.vector_space_scene.VectorScene.get_basis_vectors">get_basis_vectors</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_vector" href="#manimlib.scene.vector_space_scene.VectorScene.get_vector">get_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.get_vector_label" href="#manimlib.scene.vector_space_scene.VectorScene.get_vector_label">get_vector_label</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.label_vector" href="#manimlib.scene.vector_space_scene.VectorScene.label_vector">label_vector</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.lock_in_faded_grid" href="#manimlib.scene.vector_space_scene.VectorScene.lock_in_faded_grid">lock_in_faded_grid</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.position_x_coordinate" href="#manimlib.scene.vector_space_scene.VectorScene.position_x_coordinate">position_x_coordinate</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.position_y_coordinate" href="#manimlib.scene.vector_space_scene.VectorScene.position_y_coordinate">position_y_coordinate</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.show_ghost_movement" href="#manimlib.scene.vector_space_scene.VectorScene.show_ghost_movement">show_ghost_movement</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.vector_to_coords" href="#manimlib.scene.vector_space_scene.VectorScene.vector_to_coords">vector_to_coords</a></code></li>
<li><code><a title="manimlib.scene.vector_space_scene.VectorScene.write_vector_coordinates" href="#manimlib.scene.vector_space_scene.VectorScene.write_vector_coordinates">write_vector_coordinates</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>